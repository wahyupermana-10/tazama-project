{
	"info": {
		"_postman_id": "57f9521a-84f3-4c9b-a37e-efa5df8896d6",
		"name": "0.2. Condition Management - All",
		"description": "This test collection relies on the deployment of Tazama using the Full-Stack-Docker-Tazama with the following options enabled:\n\n1. \\[ - \\] Authentication\n    \n2. \\[ - \\] Basic Logs\n    \n3. \\[ - \\] \\[Elastic\\] Logging\n    \n4. \\[ - \\] \\[Elastic\\] APM\n    \n5. \\[ - \\] Demo UI\n    \n6. \\[ X \\] Relay\n    \n7. \\[ - \\] Config Service\n    \n\n99\\. \\[ X \\] NATS Utilities",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "36724395"
	},
	"item": [
		{
			"name": "Account Conditions",
			"item": [
				{
					"name": "Negative testing",
					"item": [
						{
							"name": "Create New Account Condition Manually - Unknown debtor account - missing evtTp",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 400,\r",
											"    \"code\": \"FST_ERR_VALIDATION\",\r",
											"    \"error\": \"Bad Request\",\r",
											"    \"message\": \"body must have required property 'evtTp'\"\r",
											"};\r",
											"\r",
											"pm.test(\"Status code is 400\", function () {\r",
											"    pm.response.to.have.status(400);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message code matches target result message code - ${targetConditionResult.code}`, function () {\r",
											"    pm.expect(responseJSON.code).to.be.eql(targetConditionResult.code);\r",
											"});\r",
											"\r",
											"pm.test(`Result message matches target result message - ${targetConditionResult.message}`, function () {\r",
											"    pm.expect(responseJSON.message).to.be.eql(targetConditionResult.message);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"console.log(dbtrAcctId)\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = {\r",
											"//    \"evtTp\": [\"pain.001.001.11\", \"pain.013.001.09\", \"pacs.008.001.10\", \"pacs.002.001.12\"],\r",
											"    \"condTp\": \"non-overridable-block\",\r",
											"    \"prsptv\": \"both\",\r",
											"    \"condRsn\": \"Default Test Condition\",\r",
											"    \"acct\":\r",
											"    {\r",
											"        \"id\": `${dbtrAcctId.id}`,\r",
											"        \"schmeNm\":\r",
											"        {\r",
											"            \"prtry\": \"MSISDN\"\r",
											"        },\r",
											"        \"agt\": {\r",
											"            \"finInstnId\": {\r",
											"                \"clrSysMmbId\": {\r",
											"                    \"mmbId\": \"fsp001\"\r",
											"                }\r",
											"            }\r",
											"        }\r",
											"    },\r",
											"    \"forceCret\": true,\r",
											"    \"usr\": \"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-account-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-account-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Account Condition Manually - Unknown debtor account - invalid evtTp 0",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 400,\r",
											"    \"code\": \"FST_ERR_VALIDATION\",\r",
											"    \"error\": \"Bad Request\",\r",
											"    \"message\": \"body/evtTp/0 must be equal to one of the allowed values\"\r",
											"};\r",
											"\r",
											"pm.test(\"Status code is 400\", function () {\r",
											"    pm.response.to.have.status(400);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message code matches target result message code - ${targetConditionResult.code}`, function () {\r",
											"    pm.expect(responseJSON.code).to.be.eql(targetConditionResult.code);\r",
											"});\r",
											"\r",
											"pm.test(`Result message matches target result message - ${targetConditionResult.message}`, function () {\r",
											"    pm.expect(responseJSON.message).to.be.eql(targetConditionResult.message);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"console.log(dbtrAcctId)\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = {\r",
											"    \"evtTp\": [\"pain.001.001.11vv\", \"pain.013.001.09\", \"pacs.008.001.10\", \"pacs.002.001.12\"],\r",
											"    \"condTp\": \"non-overridable-block\",\r",
											"    \"prsptv\": \"both\",\r",
											"    \"condRsn\": \"Default Test Condition\",\r",
											"    \"acct\":\r",
											"    {\r",
											"        \"id\": `${dbtrAcctId.id}`,\r",
											"        \"schmeNm\":\r",
											"        {\r",
											"            \"prtry\": \"MSISDN\"\r",
											"        },\r",
											"        \"agt\": {\r",
											"            \"finInstnId\": {\r",
											"                \"clrSysMmbId\": {\r",
											"                    \"mmbId\": \"fsp001\"\r",
											"                }\r",
											"            }\r",
											"        }\r",
											"    },\r",
											"    \"forceCret\": true,\r",
											"    \"usr\": \"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-account-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-account-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Account Condition Manually - Unknown debtor account - invalid evtTp 1",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 400,\r",
											"    \"code\": \"FST_ERR_VALIDATION\",\r",
											"    \"error\": \"Bad Request\",\r",
											"    \"message\": \"body/evtTp/1 must be equal to one of the allowed values\"\r",
											"};\r",
											"\r",
											"pm.test(\"Status code is 400\", function () {\r",
											"    pm.response.to.have.status(400);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message code matches target result message code - ${targetConditionResult.code}`, function () {\r",
											"    pm.expect(responseJSON.code).to.be.eql(targetConditionResult.code);\r",
											"});\r",
											"\r",
											"pm.test(`Result message matches target result message - ${targetConditionResult.message}`, function () {\r",
											"    pm.expect(responseJSON.message).to.be.eql(targetConditionResult.message);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"console.log(dbtrAcctId)\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = {\r",
											"    \"evtTp\": [\"pain.001.001.11\", \"pain.013.001.09xx\", \"pacs.008.001.10\", \"pacs.002.001.12\"],\r",
											"    \"condTp\": \"non-overridable-block\",\r",
											"    \"prsptv\": \"both\",\r",
											"    \"condRsn\": \"Default Test Condition\",\r",
											"    \"acct\":\r",
											"    {\r",
											"        \"id\": `${dbtrAcctId.id}`,\r",
											"        \"schmeNm\":\r",
											"        {\r",
											"            \"prtry\": \"MSISDN\"\r",
											"        },\r",
											"        \"agt\": {\r",
											"            \"finInstnId\": {\r",
											"                \"clrSysMmbId\": {\r",
											"                    \"mmbId\": \"fsp001\"\r",
											"                }\r",
											"            }\r",
											"        }\r",
											"    },\r",
											"    \"forceCret\": true,\r",
											"    \"usr\": \"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-account-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-account-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Account Condition Manually - Unknown debtor account - invalid evtTp 2",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 400,\r",
											"    \"code\": \"FST_ERR_VALIDATION\",\r",
											"    \"error\": \"Bad Request\",\r",
											"    \"message\": \"body/evtTp/2 must be equal to one of the allowed values\"\r",
											"};\r",
											"\r",
											"pm.test(\"Status code is 400\", function () {\r",
											"    pm.response.to.have.status(400);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message code matches target result message code - ${targetConditionResult.code}`, function () {\r",
											"    pm.expect(responseJSON.code).to.be.eql(targetConditionResult.code);\r",
											"});\r",
											"\r",
											"pm.test(`Result message matches target result message - ${targetConditionResult.message}`, function () {\r",
											"    pm.expect(responseJSON.message).to.be.eql(targetConditionResult.message);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"console.log(dbtrAcctId)\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = {\r",
											"    \"evtTp\": [\"pain.001.001.11\", \"pain.013.001.09\", \"pacs.008.001.10xx\", \"pacs.002.001.12\"],\r",
											"    \"condTp\": \"non-overridable-block\",\r",
											"    \"prsptv\": \"both\",\r",
											"    \"condRsn\": \"Default Test Condition\",\r",
											"    \"acct\":\r",
											"    {\r",
											"        \"id\": `${dbtrAcctId.id}`,\r",
											"        \"schmeNm\":\r",
											"        {\r",
											"            \"prtry\": \"MSISDN\"\r",
											"        },\r",
											"        \"agt\": {\r",
											"            \"finInstnId\": {\r",
											"                \"clrSysMmbId\": {\r",
											"                    \"mmbId\": \"fsp001\"\r",
											"                }\r",
											"            }\r",
											"        }\r",
											"    },\r",
											"    \"forceCret\": true,\r",
											"    \"usr\": \"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-account-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-account-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Account Condition Manually - Unknown debtor account - invalid evtTp 3",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 400,\r",
											"    \"code\": \"FST_ERR_VALIDATION\",\r",
											"    \"error\": \"Bad Request\",\r",
											"    \"message\": \"body/evtTp/3 must be equal to one of the allowed values\"\r",
											"};\r",
											"\r",
											"pm.test(\"Status code is 400\", function () {\r",
											"    pm.response.to.have.status(400);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message code matches target result message code - ${targetConditionResult.code}`, function () {\r",
											"    pm.expect(responseJSON.code).to.be.eql(targetConditionResult.code);\r",
											"});\r",
											"\r",
											"pm.test(`Result message matches target result message - ${targetConditionResult.message}`, function () {\r",
											"    pm.expect(responseJSON.message).to.be.eql(targetConditionResult.message);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"console.log(dbtrAcctId)\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = {\r",
											"    \"evtTp\": [\"pain.001.001.11\", \"pain.013.001.09\", \"pacs.008.001.10\", \"pacs.002.001.12vv\"],\r",
											"    \"condTp\": \"non-overridable-block\",\r",
											"    \"prsptv\": \"both\",\r",
											"    \"condRsn\": \"Default Test Condition\",\r",
											"    \"acct\":\r",
											"    {\r",
											"        \"id\": `${dbtrAcctId.id}`,\r",
											"        \"schmeNm\":\r",
											"        {\r",
											"            \"prtry\": \"MSISDN\"\r",
											"        },\r",
											"        \"agt\": {\r",
											"            \"finInstnId\": {\r",
											"                \"clrSysMmbId\": {\r",
											"                    \"mmbId\": \"fsp001\"\r",
											"                }\r",
											"            }\r",
											"        }\r",
											"    },\r",
											"    \"forceCret\": true,\r",
											"    \"usr\": \"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-account-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-account-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Account Condition Manually - Unknown debtor account - invalid evtTp duplicates",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 400,\r",
											"    \"code\": \"FST_ERR_VALIDATION\",\r",
											"    \"error\": \"Bad Request\",\r",
											"    \"message\": \"body/evtTp/3 must be equal to one of the allowed values\"\r",
											"};\r",
											"\r",
											"pm.test(\"Status code is 400\", function () {\r",
											"    pm.response.to.have.status(400);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message code matches target result message code - ${targetConditionResult.code}`, function () {\r",
											"    pm.expect(responseJSON.code).to.be.eql(targetConditionResult.code);\r",
											"});\r",
											"\r",
											"pm.test(`Result message includes \"duplicate\"`, function () {\r",
											"   pm.expect(responseJSON.message).to.include(\"duplicate\");\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"console.log(dbtrAcctId)\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = {\r",
											"    \"evtTp\": [\"pain.013.001.09\",\"pain.013.001.09\"],\r",
											"    \"condTp\": \"non-overridable-block\",\r",
											"    \"prsptv\": \"both\",\r",
											"    \"condRsn\": \"Default Test Condition\",\r",
											"    \"acct\":\r",
											"    {\r",
											"        \"id\": `${dbtrAcctId.id}`,\r",
											"        \"schmeNm\":\r",
											"        {\r",
											"            \"prtry\": \"MSISDN\"\r",
											"        },\r",
											"        \"agt\": {\r",
											"            \"finInstnId\": {\r",
											"                \"clrSysMmbId\": {\r",
											"                    \"mmbId\": \"fsp001\"\r",
											"                }\r",
											"            }\r",
											"        }\r",
											"    },\r",
											"    \"forceCret\": true,\r",
											"    \"usr\": \"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-account-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-account-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Account Condition Manually - Unknown debtor account - missing condTp",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 400,\r",
											"    \"code\": \"FST_ERR_VALIDATION\",\r",
											"    \"error\": \"Bad Request\",\r",
											"    \"message\": \"body must have required property 'condTp'\"\r",
											"};\r",
											"\r",
											"pm.test(\"Status code is 400\", function () {\r",
											"    pm.response.to.have.status(400);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message code matches target result message code - ${targetConditionResult.code}`, function () {\r",
											"    pm.expect(responseJSON.code).to.be.eql(targetConditionResult.code);\r",
											"});\r",
											"\r",
											"pm.test(`Result message matches target result message - ${targetConditionResult.message}`, function () {\r",
											"    pm.expect(responseJSON.message).to.be.eql(targetConditionResult.message);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"console.log(dbtrAcctId)\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = {\r",
											"    \"evtTp\": [\"pain.001.001.11\", \"pain.013.001.09\", \"pacs.008.001.10\", \"pacs.002.001.12\"],\r",
											"//    \"condTp\": \"non-overridable-block\",\r",
											"    \"prsptv\": \"both\",\r",
											"    \"condRsn\": \"Default Test Condition\",\r",
											"    \"acct\":\r",
											"    {\r",
											"        \"id\": `${dbtrAcctId.id}`,\r",
											"        \"schmeNm\":\r",
											"        {\r",
											"            \"prtry\": \"MSISDN\"\r",
											"        },\r",
											"        \"agt\": {\r",
											"            \"finInstnId\": {\r",
											"                \"clrSysMmbId\": {\r",
											"                    \"mmbId\": \"fsp001\"\r",
											"                }\r",
											"            }\r",
											"        }\r",
											"    },\r",
											"    \"forceCret\": true,\r",
											"    \"usr\": \"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-account-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-account-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Account Condition Manually - Unknown debtor account - invalid condTp",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 400,\r",
											"    \"code\": \"FST_ERR_VALIDATION\",\r",
											"    \"error\": \"Bad Request\",\r",
											"    \"message\": \"body/condTp must be equal to one of the allowed values\"\r",
											"};\r",
											"\r",
											"pm.test(\"Status code is 400\", function () {\r",
											"    pm.response.to.have.status(400);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message code matches target result message code - ${targetConditionResult.code}`, function () {\r",
											"    pm.expect(responseJSON.code).to.be.eql(targetConditionResult.code);\r",
											"});\r",
											"\r",
											"pm.test(`Result message matches target result message - ${targetConditionResult.message}`, function () {\r",
											"    pm.expect(responseJSON.message).to.be.eql(targetConditionResult.message);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"console.log(dbtrAcctId)\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = {\r",
											"    \"evtTp\": [\"pain.001.001.11\", \"pain.013.001.09\", \"pacs.008.001.10\", \"pacs.002.001.12\"],\r",
											"    \"condTp\": \"non-overridable000block\",\r",
											"    \"prsptv\": \"both\",\r",
											"    \"condRsn\": \"Default Test Condition\",\r",
											"    \"acct\":\r",
											"    {\r",
											"        \"id\": `${dbtrAcctId.id}`,\r",
											"        \"schmeNm\":\r",
											"        {\r",
											"            \"prtry\": \"MSISDN\"\r",
											"        },\r",
											"        \"agt\": {\r",
											"            \"finInstnId\": {\r",
											"                \"clrSysMmbId\": {\r",
											"                    \"mmbId\": \"fsp001\"\r",
											"                }\r",
											"            }\r",
											"        }\r",
											"    },\r",
											"    \"forceCret\": true,\r",
											"    \"usr\": \"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-account-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-account-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Account Condition Manually - Unknown debtor account - missing prsptv",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 400,\r",
											"    \"code\": \"FST_ERR_VALIDATION\",\r",
											"    \"error\": \"Bad Request\",\r",
											"    \"message\": \"body must have required property 'prsptv'\"\r",
											"};\r",
											"\r",
											"pm.test(\"Status code is 400\", function () {\r",
											"    pm.response.to.have.status(400);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message code matches target result message code - ${targetConditionResult.code}`, function () {\r",
											"    pm.expect(responseJSON.code).to.be.eql(targetConditionResult.code);\r",
											"});\r",
											"\r",
											"pm.test(`Result message matches target result message - ${targetConditionResult.message}`, function () {\r",
											"    pm.expect(responseJSON.message).to.be.eql(targetConditionResult.message);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"console.log(dbtrAcctId)\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = {\r",
											"    \"evtTp\": [\"pain.001.001.11\", \"pain.013.001.09\", \"pacs.008.001.10\", \"pacs.002.001.12\"],\r",
											"    \"condTp\": \"non-overridable-block\",\r",
											"//    \"prsptv\": \"both\",\r",
											"    \"condRsn\": \"Default Test Condition\",\r",
											"    \"acct\":\r",
											"    {\r",
											"        \"id\": `${dbtrAcctId.id}`,\r",
											"        \"schmeNm\":\r",
											"        {\r",
											"            \"prtry\": \"MSISDN\"\r",
											"        },\r",
											"        \"agt\": {\r",
											"            \"finInstnId\": {\r",
											"                \"clrSysMmbId\": {\r",
											"                    \"mmbId\": \"fsp001\"\r",
											"                }\r",
											"            }\r",
											"        }\r",
											"    },\r",
											"    \"forceCret\": true,\r",
											"    \"usr\": \"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-account-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-account-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Account Condition Manually - Unknown debtor account - invalid prsptv",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 400,\r",
											"    \"code\": \"FST_ERR_VALIDATION\",\r",
											"    \"error\": \"Bad Request\",\r",
											"    \"message\": \"body/prsptv must be equal to one of the allowed values\"\r",
											"};\r",
											"\r",
											"pm.test(\"Status code is 400\", function () {\r",
											"    pm.response.to.have.status(400);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message code matches target result message code - ${targetConditionResult.code}`, function () {\r",
											"    pm.expect(responseJSON.code).to.be.eql(targetConditionResult.code);\r",
											"});\r",
											"\r",
											"pm.test(`Result message matches target result message - ${targetConditionResult.message}`, function () {\r",
											"    pm.expect(responseJSON.message).to.be.eql(targetConditionResult.message);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"console.log(dbtrAcctId)\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = {\r",
											"    \"evtTp\": [\"pain.001.001.11\", \"pain.013.001.09\", \"pacs.008.001.10\", \"pacs.002.001.12\"],\r",
											"    \"condTp\": \"non-overridable-block\",\r",
											"    \"prsptv\": \"any\",\r",
											"    \"condRsn\": \"Default Test Condition\",\r",
											"    \"acct\":\r",
											"    {\r",
											"        \"id\": `${dbtrAcctId.id}`,\r",
											"        \"schmeNm\":\r",
											"        {\r",
											"            \"prtry\": \"MSISDN\"\r",
											"        },\r",
											"        \"agt\": {\r",
											"            \"finInstnId\": {\r",
											"                \"clrSysMmbId\": {\r",
											"                    \"mmbId\": \"fsp001\"\r",
											"                }\r",
											"            }\r",
											"        }\r",
											"    },\r",
											"    \"forceCret\": true,\r",
											"    \"usr\": \"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-account-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-account-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Account Condition Manually - Unknown debtor account - missing condRsn",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 400,\r",
											"    \"code\": \"FST_ERR_VALIDATION\",\r",
											"    \"error\": \"Bad Request\",\r",
											"    \"message\": \"body must have required property 'condRsn'\"\r",
											"};\r",
											"\r",
											"pm.test(\"Status code is 400\", function () {\r",
											"    pm.response.to.have.status(400);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message code matches target result message code - ${targetConditionResult.code}`, function () {\r",
											"    pm.expect(responseJSON.code).to.be.eql(targetConditionResult.code);\r",
											"});\r",
											"\r",
											"pm.test(`Result message matches target result message - ${targetConditionResult.message}`, function () {\r",
											"    pm.expect(responseJSON.message).to.be.eql(targetConditionResult.message);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"console.log(dbtrAcctId)\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = {\r",
											"    \"evtTp\": [\"pain.001.001.11\", \"pain.013.001.09\", \"pacs.008.001.10\", \"pacs.002.001.12\"],\r",
											"    \"condTp\": \"non-overridable-block\",\r",
											"    \"prsptv\": \"both\",\r",
											"//    \"condRsn\": \"Default Test Condition\",\r",
											"    \"acct\":\r",
											"    {\r",
											"        \"id\": `${dbtrAcctId.id}`,\r",
											"        \"schmeNm\":\r",
											"        {\r",
											"            \"prtry\": \"MSISDN\"\r",
											"        },\r",
											"        \"agt\": {\r",
											"            \"finInstnId\": {\r",
											"                \"clrSysMmbId\": {\r",
											"                    \"mmbId\": \"fsp001\"\r",
											"                }\r",
											"            }\r",
											"        }\r",
											"    },\r",
											"    \"forceCret\": true,\r",
											"    \"usr\": \"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-account-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-account-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Account Condition Manually - Unknown debtor account - missing acct",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 400,\r",
											"    \"code\": \"FST_ERR_VALIDATION\",\r",
											"    \"error\": \"Bad Request\",\r",
											"    \"message\": \"body must have required property 'acct'\"\r",
											"};\r",
											"\r",
											"pm.test(\"Status code is 400\", function () {\r",
											"    pm.response.to.have.status(400);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message code matches target result message code - ${targetConditionResult.code}`, function () {\r",
											"    pm.expect(responseJSON.code).to.be.eql(targetConditionResult.code);\r",
											"});\r",
											"\r",
											"pm.test(`Result message matches target result message - ${targetConditionResult.message}`, function () {\r",
											"    pm.expect(responseJSON.message).to.be.eql(targetConditionResult.message);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"console.log(dbtrAcctId)\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = {\r",
											"    \"evtTp\": [\"pain.001.001.11\", \"pain.013.001.09\", \"pacs.008.001.10\", \"pacs.002.001.12\"],\r",
											"    \"condTp\": \"non-overridable-block\",\r",
											"    \"prsptv\": \"both\",\r",
											"    \"condRsn\": \"Default Test Condition\",\r",
											"//    \"acct\":\r",
											"//    {\r",
											"//        \"id\": `${dbtrAcctId.id}`,\r",
											"//        \"schmeNm\":\r",
											"//        {\r",
											"//            \"prtry\": \"MSISDN\"\r",
											"//        },\r",
											"//        \"agt\": {\r",
											"//            \"finInstnId\": {\r",
											"//                \"clrSysMmbId\": {\r",
											"//                    \"mmbId\": \"fsp001\"\r",
											"//                }\r",
											"//            }\r",
											"//        }\r",
											"//    },\r",
											"    \"forceCret\": true,\r",
											"    \"usr\": \"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-account-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-account-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Account Condition Manually - Unknown debtor account - missing acct.id",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 400,\r",
											"    \"code\": \"FST_ERR_VALIDATION\",\r",
											"    \"error\": \"Bad Request\",\r",
											"    \"message\": \"body/acct must have required property 'id'\"\r",
											"};\r",
											"\r",
											"pm.test(\"Status code is 400\", function () {\r",
											"    pm.response.to.have.status(400);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message code matches target result message code - ${targetConditionResult.code}`, function () {\r",
											"    pm.expect(responseJSON.code).to.be.eql(targetConditionResult.code);\r",
											"});\r",
											"\r",
											"pm.test(`Result message matches target result message - ${targetConditionResult.message}`, function () {\r",
											"    pm.expect(responseJSON.message).to.be.eql(targetConditionResult.message);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"console.log(dbtrAcctId)\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = {\r",
											"    \"evtTp\": [\"pain.001.001.11\", \"pain.013.001.09\", \"pacs.008.001.10\", \"pacs.002.001.12\"],\r",
											"    \"condTp\": \"non-overridable-block\",\r",
											"    \"prsptv\": \"both\",\r",
											"    \"condRsn\": \"Default Test Condition\",\r",
											"    \"acct\":\r",
											"    {\r",
											"//        \"id\": `${dbtrAcctId.id}`,\r",
											"        \"schmeNm\":\r",
											"        {\r",
											"            \"prtry\": \"MSISDN\"\r",
											"        },\r",
											"        \"agt\": {\r",
											"            \"finInstnId\": {\r",
											"                \"clrSysMmbId\": {\r",
											"                    \"mmbId\": \"fsp001\"\r",
											"                }\r",
											"            }\r",
											"        }\r",
											"    },\r",
											"    \"forceCret\": true,\r",
											"    \"usr\": \"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-account-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-account-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Account Condition Manually - Unknown debtor account - missing acct.schmeNm.prtry",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 400,\r",
											"    \"code\": \"FST_ERR_VALIDATION\",\r",
											"    \"error\": \"Bad Request\",\r",
											"    \"message\": \"body/acct/schmeNm must have required property 'prtry'\"\r",
											"};\r",
											"\r",
											"pm.test(\"Status code is 400\", function () {\r",
											"    pm.response.to.have.status(400);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message code matches target result message code - ${targetConditionResult.code}`, function () {\r",
											"    pm.expect(responseJSON.code).to.be.eql(targetConditionResult.code);\r",
											"});\r",
											"\r",
											"pm.test(`Result message matches target result message - ${targetConditionResult.message}`, function () {\r",
											"    pm.expect(responseJSON.message).to.be.eql(targetConditionResult.message);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"console.log(dbtrAcctId)\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = {\r",
											"    \"evtTp\": [\"pain.001.001.11\", \"pain.013.001.09\", \"pacs.008.001.10\", \"pacs.002.001.12\"],\r",
											"    \"condTp\": \"non-overridable-block\",\r",
											"    \"prsptv\": \"both\",\r",
											"    \"condRsn\": \"Default Test Condition\",\r",
											"    \"acct\":\r",
											"    {\r",
											"        \"id\": `${dbtrAcctId.id}`,\r",
											"        \"schmeNm\":\r",
											"        {\r",
											"//            \"prtry\": \"MSISDN\"\r",
											"        },\r",
											"        \"agt\": {\r",
											"            \"finInstnId\": {\r",
											"                \"clrSysMmbId\": {\r",
											"                    \"mmbId\": \"fsp001\"\r",
											"                }\r",
											"            }\r",
											"        }\r",
											"    },\r",
											"    \"forceCret\": true,\r",
											"    \"usr\": \"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-account-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-account-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Account Condition Manually - Unknown debtor account - missing acct.schmeNm",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 400,\r",
											"    \"code\": \"FST_ERR_VALIDATION\",\r",
											"    \"error\": \"Bad Request\",\r",
											"    \"message\": \"body/acct must have required property 'schmeNm'\"\r",
											"};\r",
											"\r",
											"pm.test(\"Status code is 400\", function () {\r",
											"    pm.response.to.have.status(400);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message code matches target result message code - ${targetConditionResult.code}`, function () {\r",
											"    pm.expect(responseJSON.code).to.be.eql(targetConditionResult.code);\r",
											"});\r",
											"\r",
											"pm.test(`Result message matches target result message - ${targetConditionResult.message}`, function () {\r",
											"    pm.expect(responseJSON.message).to.be.eql(targetConditionResult.message);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"console.log(dbtrAcctId)\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = {\r",
											"    \"evtTp\": [\"pain.001.001.11\", \"pain.013.001.09\", \"pacs.008.001.10\", \"pacs.002.001.12\"],\r",
											"    \"condTp\": \"non-overridable-block\",\r",
											"    \"prsptv\": \"both\",\r",
											"    \"condRsn\": \"Default Test Condition\",\r",
											"    \"acct\":\r",
											"    {\r",
											"        \"id\": `${dbtrAcctId.id}`,\r",
											"//        \"schmeNm\":\r",
											"//        {\r",
											"//            \"prtry\": \"MSISDN\"\r",
											"//        },\r",
											"        \"agt\": {\r",
											"            \"finInstnId\": {\r",
											"                \"clrSysMmbId\": {\r",
											"                    \"mmbId\": \"fsp001\"\r",
											"                }\r",
											"            }\r",
											"        }\r",
											"    },\r",
											"    \"forceCret\": true,\r",
											"    \"usr\": \"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-account-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-account-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Account Condition Manually - Unknown debtor account - missing acct.agt",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 400,\r",
											"    \"code\": \"FST_ERR_VALIDATION\",\r",
											"    \"error\": \"Bad Request\",\r",
											"    \"message\": \"body/acct must have required property 'agt'\"\r",
											"};\r",
											"\r",
											"pm.test(\"Status code is 400\", function () {\r",
											"    pm.response.to.have.status(400);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message code matches target result message code - ${targetConditionResult.code}`, function () {\r",
											"    pm.expect(responseJSON.code).to.be.eql(targetConditionResult.code);\r",
											"});\r",
											"\r",
											"pm.test(`Result message matches target result message - ${targetConditionResult.message}`, function () {\r",
											"    pm.expect(responseJSON.message).to.be.eql(targetConditionResult.message);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"console.log(dbtrAcctId)\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = {\r",
											"    \"evtTp\": [\"pain.001.001.11\", \"pain.013.001.09\", \"pacs.008.001.10\", \"pacs.002.001.12\"],\r",
											"    \"condTp\": \"non-overridable-block\",\r",
											"    \"prsptv\": \"both\",\r",
											"    \"condRsn\": \"Default Test Condition\",\r",
											"    \"acct\":\r",
											"    {\r",
											"        \"id\": `${dbtrAcctId.id}`,\r",
											"        \"schmeNm\":\r",
											"        {\r",
											"            \"prtry\": \"MSISDN\"\r",
											"        },\r",
											"//        \"agt\": {\r",
											"//            \"finInstnId\": {\r",
											"//                \"clrSysMmbId\": {\r",
											"//                    \"mmbId\": \"fsp001\"\r",
											"//               }\r",
											"//            }\r",
											"//        }\r",
											"    },\r",
											"    \"forceCret\": true,\r",
											"    \"usr\": \"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-account-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-account-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Account Condition Manually - Unknown debtor account - missing acct.agt.mmbId",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"console.log(dbtrAcctId)\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = {\r",
											"    \"evtTp\": [\"pain.001.001.11\", \"pain.013.001.09\", \"pacs.008.001.10\", \"pacs.002.001.12\"],\r",
											"    \"condTp\": \"non-overridable-block\",\r",
											"    \"prsptv\": \"both\",\r",
											"    \"condRsn\": \"Default Test Condition\",\r",
											"    \"acct\":\r",
											"    {\r",
											"        \"id\": `${dbtrAcctId.id}`,\r",
											"        \"schmeNm\":\r",
											"        {\r",
											"            \"prtry\": \"MSISDN\"\r",
											"        },\r",
											"        \"agt\": {\r",
											"            \"finInstnId\": {\r",
											"                \"clrSysMmbId\": {\r",
											"                    //                    \"mmbId\": \"fsp001\"\r",
											"                }\r",
											"            }\r",
											"        }\r",
											"    },\r",
											"    \"forceCret\": true,\r",
											"    \"usr\": \"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 400,\r",
											"    \"code\": \"FST_ERR_VALIDATION\",\r",
											"    \"error\": \"Bad Request\",\r",
											"    \"message\": \"body/acct/agt/finInstnId/clrSysMmbId must have required property 'mmbId'\"\r",
											"};\r",
											"\r",
											"pm.test(\"Status code is 400\", function () {\r",
											"    pm.response.to.have.status(400);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message code matches target result message code - ${targetConditionResult.code}`, function () {\r",
											"    pm.expect(responseJSON.code).to.be.eql(targetConditionResult.code);\r",
											"});\r",
											"\r",
											"pm.test(`Result message matches target result message - ${targetConditionResult.message}`, function () {\r",
											"    pm.expect(responseJSON.message).to.be.eql(targetConditionResult.message);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-account-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-account-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Account Condition Manually - Unknown debtor account - missing acct.fininstId",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 400,\r",
											"    \"code\": \"FST_ERR_VALIDATION\",\r",
											"    \"error\": \"Bad Request\",\r",
											"    \"message\": \"body/acct/agt must have required property 'finInstnId'\"\r",
											"};\r",
											"\r",
											"pm.test(\"Status code is 400\", function () {\r",
											"    pm.response.to.have.status(400);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message code matches target result message code - ${targetConditionResult.code}`, function () {\r",
											"    pm.expect(responseJSON.code).to.be.eql(targetConditionResult.code);\r",
											"});\r",
											"\r",
											"pm.test(`Result message matches target result message - ${targetConditionResult.message}`, function () {\r",
											"    pm.expect(responseJSON.message).to.be.eql(targetConditionResult.message);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"console.log(dbtrAcctId)\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = {\r",
											"    \"evtTp\": [\"pain.001.001.11\", \"pain.013.001.09\", \"pacs.008.001.10\", \"pacs.002.001.12\"],\r",
											"    \"condTp\": \"non-overridable-block\",\r",
											"    \"prsptv\": \"both\",\r",
											"    \"condRsn\": \"Default Test Condition\",\r",
											"    \"acct\":\r",
											"    {\r",
											"        \"id\": `${dbtrAcctId.id}`,\r",
											"        \"schmeNm\":\r",
											"        {\r",
											"            \"prtry\": \"MSISDN\"\r",
											"        },\r",
											"        \"agt\": {\r",
											"//            \"finInstnId\": {\r",
											"//                \"clrSysMmbId\": {\r",
											"//                    \"mmbId\": \"fsp001\"\r",
											"//               }\r",
											"//            }\r",
											"        }\r",
											"    },\r",
											"    \"forceCret\": true,\r",
											"    \"usr\": \"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-account-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-account-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Account Condition Manually - Unknown debtor account - missing forceCret",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 400,\r",
											"    \"code\": \"FST_ERR_VALIDATION\",\r",
											"    \"error\": \"Bad Request\",\r",
											"    \"message\": \"body must have required property 'forceCret'\"\r",
											"};\r",
											"\r",
											"pm.test(\"Status code is 400\", function () {\r",
											"    pm.response.to.have.status(400);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message code matches target result message code - ${targetConditionResult.code}`, function () {\r",
											"    pm.expect(responseJSON.code).to.be.eql(targetConditionResult.code);\r",
											"});\r",
											"\r",
											"pm.test(`Result message matches target result message - ${targetConditionResult.message}`, function () {\r",
											"    pm.expect(responseJSON.message).to.be.eql(targetConditionResult.message);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"console.log(dbtrAcctId)\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = {\r",
											"    \"evtTp\": [\"pain.001.001.11\", \"pain.013.001.09\", \"pacs.008.001.10\", \"pacs.002.001.12\"],\r",
											"    \"condTp\": \"non-overridable-block\",\r",
											"    \"prsptv\": \"both\",\r",
											"    \"condRsn\": \"Default Test Condition\",\r",
											"    \"acct\":\r",
											"    {\r",
											"        \"id\": `${dbtrAcctId.id}`,\r",
											"        \"schmeNm\":\r",
											"        {\r",
											"            \"prtry\": \"MSISDN\"\r",
											"        },\r",
											"        \"agt\": {\r",
											"            \"finInstnId\": {\r",
											"                \"clrSysMmbId\": {\r",
											"                    \"mmbId\": \"fsp001\"\r",
											"                }\r",
											"            }\r",
											"        }\r",
											"    },\r",
											"//    \"forceCret\": true,\r",
											"    \"usr\": \"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-account-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-account-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Account Condition Manually - Unknown debtor account - missing usr",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 400,\r",
											"    \"code\": \"FST_ERR_VALIDATION\",\r",
											"    \"error\": \"Bad Request\",\r",
											"    \"message\": \"body must have required property 'usr'\"\r",
											"};\r",
											"\r",
											"pm.test(\"Status code is 400\", function () {\r",
											"    pm.response.to.have.status(400);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message code matches target result message code - ${targetConditionResult.code}`, function () {\r",
											"    pm.expect(responseJSON.code).to.be.eql(targetConditionResult.code);\r",
											"});\r",
											"\r",
											"pm.test(`Result message matches target result message - ${targetConditionResult.message}`, function () {\r",
											"    pm.expect(responseJSON.message).to.be.eql(targetConditionResult.message);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"console.log(dbtrAcctId)\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = {\r",
											"    \"evtTp\": [\"pain.001.001.11\", \"pain.013.001.09\", \"pacs.008.001.10\", \"pacs.002.001.12\"],\r",
											"    \"condTp\": \"non-overridable-block\",\r",
											"    \"prsptv\": \"both\",\r",
											"    \"condRsn\": \"Default Test Condition\",\r",
											"    \"acct\":\r",
											"    {\r",
											"        \"id\": `${dbtrAcctId.id}`,\r",
											"        \"schmeNm\":\r",
											"        {\r",
											"            \"prtry\": \"MSISDN\"\r",
											"        },\r",
											"        \"agt\": {\r",
											"            \"finInstnId\": {\r",
											"                \"clrSysMmbId\": {\r",
											"                    \"mmbId\": \"fsp001\"\r",
											"                }\r",
											"            }\r",
											"        }\r",
											"    },\r",
											"    \"forceCret\": true,\r",
											"//    \"usr\": \"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-account-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-account-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Account Condition Manually - Unknown debtor account - override missing expiration",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 500,\r",
											"    \"error\": \"Internal Server Error\",\r",
											"    \"message\": \"Error: Expiration date needs to be provided for override conditions.\"\r",
											"}\r",
											"\r",
											"pm.test(\"Status code is 500\", function () {\r",
											"    pm.response.to.have.status(500);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message matches target result message - ${targetConditionResult.message}`, function () {\r",
											"    pm.expect(responseJSON.message).to.be.eql(targetConditionResult.message);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"console.log(dbtrAcctId)\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = {\r",
											"    \"evtTp\": [\"pain.001.001.11\", \"pain.013.001.09\", \"pacs.008.001.10\", \"pacs.002.001.12\"],\r",
											"    \"condTp\": \"override\",\r",
											"    \"prsptv\": \"both\",\r",
											"    \"condRsn\": \"Default Test Condition\",\r",
											"    \"acct\":\r",
											"    {\r",
											"        \"id\": `${dbtrAcctId.id}`,\r",
											"        \"schmeNm\":\r",
											"        {\r",
											"            \"prtry\": \"MSISDN\"\r",
											"        },\r",
											"        \"agt\": {\r",
											"            \"finInstnId\": {\r",
											"                \"clrSysMmbId\": {\r",
											"                    \"mmbId\": \"fsp001\"\r",
											"                }\r",
											"            }\r",
											"        }\r",
											"    },\r",
											"    \"forceCret\": true,\r",
											"    \"usr\": \"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-account-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-account-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Account Condition Manually - Unknown debtor account - expiration before now",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 500,\r",
											"    \"error\": \"Internal Server Error\",\r",
											"    \"message\": \"Error: Expiration date must be after inception date.\"\r",
											"}\r",
											"\r",
											"pm.test(\"Status code is 500\", function () {\r",
											"    pm.response.to.have.status(500);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message matches target result message - ${targetConditionResult.message}`, function () {\r",
											"    pm.expect(responseJSON.message).to.be.eql(targetConditionResult.message);\r",
											"});\r",
											"\r",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"console.log(dbtrAcctId)\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = {\r",
											"    \"evtTp\": [\"pain.001.001.11\", \"pain.013.001.09\", \"pacs.008.001.10\", \"pacs.002.001.12\"],\r",
											"    \"condTp\": \"override\",\r",
											"    \"prsptv\": \"both\",\r",
											"    \"condRsn\": \"Default Test Condition\",\r",
											"    \"xprtnDtTm\": \"2021-03-03T22:00:00.999Z\",\r",
											"    \"acct\":\r",
											"    {\r",
											"        \"id\": `${dbtrAcctId.id}`,\r",
											"        \"schmeNm\":\r",
											"        {\r",
											"            \"prtry\": \"MSISDN\"\r",
											"        },\r",
											"        \"agt\": {\r",
											"            \"finInstnId\": {\r",
											"                \"clrSysMmbId\": {\r",
											"                    \"mmbId\": \"fsp001\"\r",
											"                }\r",
											"            }\r",
											"        }\r",
											"    },\r",
											"    \"forceCret\": true,\r",
											"    \"usr\": \"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-account-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-account-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Account Condition Manually - Unknown debtor account - expiration invalid",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 500,\r",
											"    \"error\": \"Internal Server Error\",\r",
											"    \"message\": \"Error: the provided xprtnDtTm: '2025-02-31T24:00:00.999Z' is invalid\"\r",
											"};\r",
											"\r",
											"pm.test(\"Status code is 500\", function () {\r",
											"    pm.response.to.have.status(500);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message matches target result message - ${targetConditionResult.message}`, function () {\r",
											"    pm.expect(responseJSON.message).to.be.eql(targetConditionResult.message);\r",
											"});\r",
											"\r",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"console.log(dbtrAcctId)\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = {\r",
											"    \"evtTp\": [\"pain.001.001.11\", \"pain.013.001.09\", \"pacs.008.001.10\", \"pacs.002.001.12\"],\r",
											"    \"condTp\": \"override\",\r",
											"    \"prsptv\": \"both\",\r",
											"    \"condRsn\": \"Default Test Condition\",\r",
											"    \"xprtnDtTm\": \"2025-02-31T24:00:00.999Z\",\r",
											"    \"acct\":\r",
											"    {\r",
											"        \"id\": `${dbtrAcctId.id}`,\r",
											"        \"schmeNm\":\r",
											"        {\r",
											"            \"prtry\": \"MSISDN\"\r",
											"        },\r",
											"        \"agt\": {\r",
											"            \"finInstnId\": {\r",
											"                \"clrSysMmbId\": {\r",
											"                    \"mmbId\": \"fsp001\"\r",
											"                }\r",
											"            }\r",
											"        }\r",
											"    },\r",
											"    \"forceCret\": true,\r",
											"    \"usr\": \"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-account-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-account-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Account Condition Manually - Unknown debtor account - inception invalid",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 500,\r",
											"    \"error\": \"Internal Server Error\",\r",
											"    \"message\": \"Error: the provided incptnDtTm: '2025-10-03T25:00:00.999Z' is invalid\"\r",
											"};\r",
											"\r",
											"pm.test(\"Status code is 500\", function () {\r",
											"    pm.response.to.have.status(500);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message matches target result message - ${targetConditionResult.message}`, function () {\r",
											"    pm.expect(responseJSON.message).to.be.eql(targetConditionResult.message);\r",
											"});\r",
											"\r",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"console.log(dbtrAcctId)\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = {\r",
											"    \"evtTp\": [\"pain.001.001.11\", \"pain.013.001.09\", \"pacs.008.001.10\", \"pacs.002.001.12\"],\r",
											"    \"condTp\": \"override\",\r",
											"    \"prsptv\": \"both\",\r",
											"    \"condRsn\": \"Default Test Condition\",\r",
											"    \"incptnDtTm\": \"2025-10-03T25:00:00.999Z\",\r",
											"    \"xprtnDtTm\": \"2026-10-31T21:00:00.999Z\",\r",
											"    \"acct\":\r",
											"    {\r",
											"        \"id\": `${dbtrAcctId.id}`,\r",
											"        \"schmeNm\":\r",
											"        {\r",
											"            \"prtry\": \"MSISDN\"\r",
											"        },\r",
											"        \"agt\": {\r",
											"            \"finInstnId\": {\r",
											"                \"clrSysMmbId\": {\r",
											"                    \"mmbId\": \"fsp001\"\r",
											"                }\r",
											"            }\r",
											"        }\r",
											"    },\r",
											"    \"forceCret\": true,\r",
											"    \"usr\": \"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-account-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-account-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Account Condition Manually - Unknown debtor account - expiration before inception",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 500,\r",
											"    \"error\": \"Internal Server Error\",\r",
											"    \"message\": \"Error: Expiration date must be after inception date.\"\r",
											"}\r",
											"\r",
											"pm.test(\"Status code is 500\", function () {\r",
											"    pm.response.to.have.status(500);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message matches target result message - ${targetConditionResult.message}`, function () {\r",
											"    pm.expect(responseJSON.message).to.be.eql(targetConditionResult.message);\r",
											"});\r",
											"\r",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"console.log(dbtrAcctId)\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = {\r",
											"    \"evtTp\": [\"pain.001.001.11\", \"pain.013.001.09\", \"pacs.008.001.10\", \"pacs.002.001.12\"],\r",
											"    \"condTp\": \"override\",\r",
											"    \"prsptv\": \"both\",\r",
											"    \"condRsn\": \"Default Test Condition\",\r",
											"    \"incptnDtTm\": \"2026-10-05T21:00:00.999Z\",\r",
											"    \"xprtnDtTm\": \"2026-10-04T21:00:00.999Z\",\r",
											"    \"acct\":\r",
											"    {\r",
											"        \"id\": `${dbtrAcctId.id}`,\r",
											"        \"schmeNm\":\r",
											"        {\r",
											"            \"prtry\": \"MSISDN\"\r",
											"        },\r",
											"        \"agt\": {\r",
											"            \"finInstnId\": {\r",
											"                \"clrSysMmbId\": {\r",
											"                    \"mmbId\": \"fsp001\"\r",
											"                }\r",
											"            }\r",
											"        }\r",
											"    },\r",
											"    \"forceCret\": true,\r",
											"    \"usr\": \"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-account-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-account-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Account Condition Manually - Unknown debtor account - inception before now",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 500,\r",
											"    \"error\": \"Internal Server Error\",\r",
											"    \"message\": \"Error: Inception date cannot be before current date/time\"\r",
											"};\r",
											"\r",
											"pm.test(\"Status code is 500\", function () {\r",
											"    pm.response.to.have.status(500);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message matches target result message - ${targetConditionResult.message}`, function () {\r",
											"    pm.expect(responseJSON.message).to.be.eql(targetConditionResult.message);\r",
											"});\r",
											"\r",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"console.log(dbtrAcctId)\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = {\r",
											"    \"evtTp\": [\"pain.001.001.11\", \"pain.013.001.09\", \"pacs.008.001.10\", \"pacs.002.001.12\"],\r",
											"    \"condTp\": \"override\",\r",
											"    \"prsptv\": \"both\",\r",
											"    \"condRsn\": \"Default Test Condition\",\r",
											"    \"incptnDtTm\": \"2023-10-02T21:00:00.999Z\",\r",
											"    \"acct\":\r",
											"    {\r",
											"        \"id\": `${dbtrAcctId.id}`,\r",
											"        \"schmeNm\":\r",
											"        {\r",
											"            \"prtry\": \"MSISDN\"\r",
											"        },\r",
											"        \"agt\": {\r",
											"            \"finInstnId\": {\r",
											"                \"clrSysMmbId\": {\r",
											"                    \"mmbId\": \"fsp001\"\r",
											"                }\r",
											"            }\r",
											"        }\r",
											"    },\r",
											"    \"forceCret\": true,\r",
											"    \"usr\": \"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-account-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-account-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Account Condition Manually - Unknown debtor account - inception default now",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"let inceptionDate = responseJSON.result.conditions[0].incptnDtTm;\r",
											"\r",
											"var now = new Date();\r",
											"pm.globals.set(\"currentDateTime\", now.toISOString());\r",
											"// Retrieve the variable from the environment to use in the script\r",
											"var currentDateTime = pm.globals.get(\"currentDateTime\");\r",
											"\r",
											"var inceptionDt = inceptionDate.substring(0, 10);\r",
											"var currentDt = currentDateTime.substring(0, 10);\r",
											"\r",
											"pm.test(\"Status code is 200\", function () {\r",
											"    pm.response.to.have.status(200);\r",
											"});\r",
											"\r",
											"pm.test(`Inception date  ${inceptionDate} equals current date  ${currentDt} `, function () {\r",
											"    pm.expect(inceptionDt).to.be.eql(currentDt);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"console.log(dbtrAcctId)\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = {\r",
											"    \"evtTp\": [\"pain.001.001.11\", \"pain.013.001.09\", \"pacs.008.001.10\", \"pacs.002.001.12\"],\r",
											"    \"condTp\": \"non-overridable-block\",\r",
											"    \"prsptv\": \"both\",\r",
											"    \"condRsn\": \"Default Test Condition\",\r",
											"    \"acct\":\r",
											"    {\r",
											"        \"id\": `${dbtrAcctId.id}`,\r",
											"        \"schmeNm\":\r",
											"        {\r",
											"            \"prtry\": \"MSISDN\"\r",
											"        },\r",
											"        \"agt\": {\r",
											"            \"finInstnId\": {\r",
											"                \"clrSysMmbId\": {\r",
											"                    \"mmbId\": \"fsp001\"\r",
											"                }\r",
											"            }\r",
											"        }\r",
											"    },\r",
											"    \"forceCret\": true,\r",
											"    \"usr\": \"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-account-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-account-condition}}"
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "Basic Functionality",
					"item": [
						{
							"name": "Fetch Account Conditions - non-existent debtor account",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.text();\r",
											"const tenantId = pm.globals.get(\"tenantId\");\r",
											"const acctId = pm.globals.get(\"dbtrAcctId\");\r",
											"const acctIdSchme = pm.globals.get(\"dbtrAcctIdSchmeNm\");\r",
											"const acctAgt = pm.globals.get(\"dbtrAgt\");\r",
											"const targetAccountId = acctId + acctIdSchme + acctAgt;\r",
											"\r",
											"pm.test(\"Status code is 404 Not Found\", function () {\r",
											"    pm.response.to.have.status(404);\r",
											"});\r",
											"\r",
											"pm.test(\"Response is 'Account does not exist in the database'\", function () {\r",
											"    pm.expect(responseJSON).to.be.equal(\"Account does not exist in the database\");\r",
											"});\r",
											"\r",
											"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetAccountId, false);\r",
											"\r",
											"await pm.sendRequest(postRequest, (error, response) => {\r",
											"    if (utils.getLogLevel() === 'DEBUG') {\r",
											"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
											"    }\r",
											"    const conditionResult = response.json().data;\r",
											"\r",
											"    pm.test(`No governed_as_debtor_account_by conditions for account [${targetAccountId}] exists in the database`, function () {\r",
											"        pm.expect(conditionResult.governed_as_debtor_account_by).to.be.empty;\r",
											"    });\r",
											"\r",
											"    pm.test(`No governed_as_creditor_account_by conditions for account [${targetAccountId}] exists in the database`, function () {\r",
											"        pm.expect(conditionResult.governed_as_debtor_account_by).to.be.empty;\r",
											"    });\r",
											"\r",
											"});\r",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"// Create identifier variables from the pacs.008 message\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const tenantId = submittedPacs008Message.TenantId;\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"tenantId\", tenantId);\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"pm.globals.set(\"synccache\", \"no\");"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"protocolProfileBehavior": {
								"disableBodyPruning": true
							},
							"request": {
								"method": "GET",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/admin/event-flow-control/account?tenantid={{tenantId}}&id={{dbtrNttyId}}&schmenm={{cdtrNttyIdSchmeNm}}&agt={{dbtrAgt}}&synccache={{synccache}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"admin",
										"event-flow-control",
										"account"
									],
									"query": [
										{
											"key": "tenantid",
											"value": "{{tenantId}}"
										},
										{
											"key": "id",
											"value": "{{dbtrNttyId}}"
										},
										{
											"key": "schmenm",
											"value": "{{cdtrNttyIdSchmeNm}}"
										},
										{
											"key": "agt",
											"value": "{{dbtrAgt}}"
										},
										{
											"key": "synccache",
											"value": "{{synccache}}"
										}
									]
								}
							},
							"response": [
								{
									"name": "Fetch Account Conditions - non-existent debtor account",
									"originalRequest": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/admin/event-flow-control/account?id={{dbtrNttyId}}&schmenm={{cdtrNttyIdSchmeNm}}&agt={{dbtrAgt}}&synccache={{synccache}}",
											"host": [
												"{{tazamaAdminUrl}}{{path-admin-api-version}}"
											],
											"path": [
												"admin",
												"event-flow-control",
												"account"
											],
											"query": [
												{
													"key": "id",
													"value": "{{dbtrNttyId}}"
												},
												{
													"key": "schmenm",
													"value": "{{cdtrNttyIdSchmeNm}}"
												},
												{
													"key": "agt",
													"value": "{{dbtrAgt}}"
												},
												{
													"key": "synccache",
													"value": "{{synccache}}"
												}
											]
										}
									},
									"status": "Not Found",
									"code": 404,
									"_postman_previewlanguage": "plain",
									"header": [
										{
											"key": "access-control-allow-origin",
											"value": "*"
										},
										{
											"key": "content-type",
											"value": "text/plain; charset=utf-8"
										},
										{
											"key": "content-length",
											"value": "38"
										},
										{
											"key": "Date",
											"value": "Thu, 01 May 2025 05:41:28 GMT"
										},
										{
											"key": "Connection",
											"value": "keep-alive"
										},
										{
											"key": "Keep-Alive",
											"value": "timeout=72"
										}
									],
									"cookie": [],
									"body": "Account does not exist in the database"
								}
							]
						},
						{
							"name": "Fetch Account Conditions - new debtor account",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.text();\r",
											"const tenantId = pm.globals.get(\"tenantId\");\r",
											"const acctId = pm.globals.get(\"dbtrAcctId\");\r",
											"const acctIdSchme = pm.globals.get(\"dbtrAcctIdSchmeNm\");\r",
											"const acctAgt = pm.globals.get(\"dbtrAgt\");\r",
											"const targetAccountId = acctId + acctIdSchme + acctAgt;\r",
											"\r",
											"pm.test(\"Status code is 204\", function () {\r",
											"    pm.response.to.have.status(204);\r",
											"});\r",
											"\r",
											"pm.test(\"Result is an empty response\", function () {\r",
											"    pm.expect(responseJSON).to.be.equal( \"\" );\r",
											"});\r",
											"\r",
											"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetAccountId, false);;\r",
											"\r",
											"await pm.sendRequest(postRequest, (error, response) => {\r",
											"    if (utils.getLogLevel() === 'DEBUG') {\r",
											"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
											"    }\r",
											"    conditionResult = response.json().data;\r",
											"    console.log(`Database condition graph: ${JSON.stringify(conditionResult)}`);\r",
											"\r",
											"    pm.test(`No governed_as_debtor_account_by conditions for account [${targetAccountId}] exists in the database`, function () {\r",
											"        pm.expect(conditionResult.governed_as_debtor_account_by).to.be.empty;\r",
											"    });\r",
											"\r",
											"    pm.test(`No governed_as_creditor_account_by conditions for account [${targetAccountId}] exists in the database`, function () {\r",
											"        pm.expect(conditionResult.governed_as_debtor_account_by).to.be.empty;\r",
											"    });\r",
											"\r",
											"});\r",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSets = await utils.createTransactionSetsInDatabase();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSets[0].pacs008);\r",
											"\r",
											"// Create identifier variables from the pacs.008 message\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const tenantId = submittedPacs008Message.TenantId;\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"tenantId\", tenantId);\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"pm.globals.set(\"synccache\", \"no\");"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"protocolProfileBehavior": {
								"disableBodyPruning": true
							},
							"request": {
								"method": "GET",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/admin/event-flow-control/account?id={{dbtrAcctId}}&schmenm={{dbtrAcctIdSchmeNm}}&agt={{dbtrAgt}}&synccache={{synccache}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"admin",
										"event-flow-control",
										"account"
									],
									"query": [
										{
											"key": "id",
											"value": "{{dbtrAcctId}}"
										},
										{
											"key": "schmenm",
											"value": "{{dbtrAcctIdSchmeNm}}"
										},
										{
											"key": "agt",
											"value": "{{dbtrAgt}}"
										},
										{
											"key": "synccache",
											"value": "{{synccache}}"
										}
									]
								}
							},
							"response": [
								{
									"name": "Fetch Account Conditions - new debtor account",
									"originalRequest": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/admin/event-flow-control/account?id={{dbtrAcctId}}&schmenm={{dbtrAcctIdSchmeNm}}&agt={{dbtrAgt}}&synccache={{synccache}}",
											"host": [
												"{{tazamaAdminUrl}}{{path-admin-api-version}}"
											],
											"path": [
												"admin",
												"event-flow-control",
												"account"
											],
											"query": [
												{
													"key": "id",
													"value": "{{dbtrAcctId}}"
												},
												{
													"key": "schmenm",
													"value": "{{dbtrAcctIdSchmeNm}}"
												},
												{
													"key": "agt",
													"value": "{{dbtrAgt}}"
												},
												{
													"key": "synccache",
													"value": "{{synccache}}"
												}
											]
										}
									},
									"status": "No Content",
									"code": 204,
									"_postman_previewlanguage": "plain",
									"header": [
										{
											"key": "access-control-allow-origin",
											"value": "*"
										},
										{
											"key": "Date",
											"value": "Thu, 01 May 2025 05:41:40 GMT"
										},
										{
											"key": "Connection",
											"value": "keep-alive"
										},
										{
											"key": "Keep-Alive",
											"value": "timeout=72"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						},
						{
							"name": "Create New Account Condition - Unknown debtor account",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"let conditionResult = responseJSON.result.conditions;\r",
											"let conditionAccount = responseJSON.result.acct;\r",
											"let requestMessage = responseJSON.message;\r",
											"let tenantId = pm.globals.get(\"tenantId\");\r",
											"let acctId = pm.globals.get(\"dbtrAcctId\");\r",
											"let acctIdSchme = pm.globals.get(\"dbtrAcctIdSchmeNm\");\r",
											"let acctAgt = pm.globals.get(\"dbtrAgt\");\r",
											"let targetAccountId = acctId + acctIdSchme + acctAgt;\r",
											"\r",
											"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
											"targetRequestMessage = \"New condition was saved successfully.\"\r",
											"\r",
											"if (utils.getLogLevel() === 'DEBUG') {\r",
											"    console.log(`Post-response inputs:\r",
											"    responseJSON: ${JSON.stringify(responseJSON)}\r",
											"    conditionResult: ${JSON.stringify(conditionResult)}\r",
											"    conditionAccount: ${JSON.stringify(conditionAccount)}\r",
											"    requestMessage: ${requestMessage}\r",
											"    tenantId: ${tenantId}\r",
											"    acctId: ${acctId}\r",
											"    acctIdSchme: ${acctIdSchme}\r",
											"    acctAgt: ${acctAgt}\r",
											"    targetAccountId: ${targetAccountId}\r",
											"    targetConditionResult: ${JSON.stringify(targetConditionResult)}`);\r",
											"}\r",
											"\r",
											"pm.test(\"Status code is 200\", function () {\r",
											"    pm.response.to.have.status(200);\r",
											"});\r",
											"\r",
											"pm.test(\"Result message matches target result message\", function () {\r",
											"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
											"});\r",
											"\r",
											"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
											"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
											"});\r",
											"\r",
											"pm.test(\"Result conditions array only contains a single condition\", function () {\r",
											"    pm.expect(conditionResult.length).to.be.eql(1);\r",
											"});\r",
											"\r",
											"let firstElement = conditionResult[0];\r",
											"\r",
											"pm.test(\"Result condition has a non-empty condId\", function () {\r",
											"    pm.expect(firstElement.condId).to.exist.and.not.be.empty;\r",
											"});\r",
											"\r",
											"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
											"    pm.expect(firstElement.condTp).to.be.eql(targetConditionResult.condTp);\r",
											"});\r",
											"\r",
											"if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
											"    pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
											"        pm.expect(firstElement.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
											"    });\r",
											"} else {    // if not, one must have been defaulted\r",
											"    pm.test(\"Result condition has a non-empty incptnDtTm\", function () {\r",
											"        pm.expect(firstElement.incptnDtTm).to.exist.and.not.be.empty;\r",
											"    });\r",
											"}\r",
											"\r",
											"if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
											"    pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
											"        pm.expect(firstElement.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
											"    });\r",
											"} else {    // if not, one must not have been defaulted\r",
											"    pm.test(\"Result condition does not have an xprtnDtTm\", function () {\r",
											"        pm.expect(firstElement.xprtnDtTm).to.not.exist;\r",
											"    });\r",
											"}\r",
											"\r",
											"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
											"    pm.expect(firstElement.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
											"});\r",
											"\r",
											"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
											"    pm.expect(firstElement.usr).to.be.eql(targetConditionResult.usr);\r",
											"});\r",
											"\r",
											"pm.test(\"Result condition has a non-empty creDtTm\", function () {\r",
											"    pm.expect(firstElement.creDtTm).to.exist.and.not.be.empty;\r",
											"});\r",
											"\r",
											"// create an array that only includes the perspective descriptions so that we can evaluate them easily\r",
											"let perspectives = firstElement.prsptvs.map(({ prsptv }) => prsptv);\r",
											"\r",
											"if (targetConditionResult.prsptv === \"both\") {\r",
											"    pm.test(\"Result prsptv array contains only 2 perspectives\", function () {\r",
											"        pm.expect(firstElement.prsptvs.length).to.be.eql(2);\r",
											"    });\r",
											"\r",
											"    let targetPerspectives = [\"governed_as_creditor_account_by\", \"governed_as_debtor_account_by\"];\r",
											"\r",
											"    pm.test(`Result prsptv array contains both ${JSON.stringify(targetPerspectives)} perspectives`, function () {\r",
											"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
											"    });\r",
											"\r",
											"} else if (targetConditionResult.prsptv === \"debtor\") {\r",
											"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
											"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
											"    });\r",
											"\r",
											"    let targetPerspectives = [\"governed_as_debtor_by\"];\r",
											"\r",
											"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
											"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
											"    });\r",
											"\r",
											"} else if (targetConditionResult.prsptv === \"creditor\") {\r",
											"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
											"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
											"    });\r",
											"\r",
											"    let targetPerspectives = [\"governed_as_creditor_by\"];\r",
											"\r",
											"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
											"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
											"    });\r",
											"\r",
											"};\r",
											"\r",
											"for (let i = 0; i < firstElement.prsptvs.length; i++) {   // for each perspective\r",
											"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} contains a non-empty evtTp array`, function () {\r",
											"        pm.expect(firstElement.prsptvs[i].evtTp).to.be.an('array').and.not.be.empty;\r",
											"    });\r",
											"\r",
											"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} evtTp array matches submitted condition`, function () {\r",
											"        pm.expect(firstElement.prsptvs[i].evtTp).to.include.members(targetConditionResult.evtTp);\r",
											"    });\r",
											"\r",
											"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
											"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches submitted condition`, function () {\r",
											"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
											"        });\r",
											"    } else {    // if not, one must have been defaulted\r",
											"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches created condition incptDtTm`, function () {\r",
											"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.eql(firstElement.incptnDtTm);\r",
											"        });\r",
											"    }\r",
											"\r",
											"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
											"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} xprtnDtTm matches submitted condition`, function () {\r",
											"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
											"        });\r",
											"    } else {    // if not, one must not have been defaulted\r",
											"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} does not have an xprtnDtTm`, function () {\r",
											"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.not.exist;\r",
											"        });\r",
											"    }\r",
											"\r",
											"}\r",
											"\r",
											"pm.test(\"Result condition acct.id matches submitted condition\", function () {\r",
											"    pm.expect(conditionAccount.id).to.be.eql(targetConditionResult.acct.id);\r",
											"});\r",
											"\r",
											"pm.test(\"Result condition acct.schmeNm.prtry matches submitted condition\", function () {\r",
											"    pm.expect(conditionAccount.schmeNm.prtry).to.be.eql(targetConditionResult.acct.schmeNm.prtry);\r",
											"});\r",
											"\r",
											"pm.test(\"Result condition acct.agt.finInstnId.clrSysMmbId.mmbId matches submitted condition\", function () {\r",
											"    pm.expect(conditionAccount.agt.finInstnId.clrSysMmbId.mmbId).to.be.eql(targetConditionResult.acct.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"});\r",
											"\r",
											"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetAccountId, false);\r",
											"if (utils.getLogLevel() === 'DEBUG') {\r",
											"    console.log(postRequest);\r",
											"}\r",
											"await pm.sendRequest(postRequest, (error, response) => {\r",
											"    if (utils.getLogLevel() === 'DEBUG') {\r",
											"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
											"    }\r",
											"    databaseConditionResult = response.json().data;\r",
											"\r",
											"    if (utils.getLogLevel() === 'DEBUG') {\r",
											"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
											"    }\r",
											"\r",
											"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
											"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
											"\r",
											"    pm.test(`Only one condition for account [${targetAccountId}] exists in the database`, function () {\r",
											"        pm.expect(graphConditionList.length).to.eql(1);\r",
											"    });\r",
											"\r",
											"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
											"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
											"            pm.expect(conditionGraph.v[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
											"        });\r",
											"    }\r",
											"\r",
											"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
											"        pm.expect(conditionGraph.v[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
											"        pm.expect(conditionGraph.v[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
											"    });\r",
											"\r",
											"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
											"        pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
											"            pm.expect(conditionGraph.v[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
											"        });\r",
											"    } else {    // if not, one must have been defaulted\r",
											"        pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
											"            pm.expect(conditionGraph.v[0].incptnDtTm).to.exist.and.not.be.empty;\r",
											"        });\r",
											"    }\r",
											"\r",
											"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
											"        pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
											"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
											"        });\r",
											"    } else {    // if not, one must not have been defaulted\r",
											"        pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
											"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.not.exist;\r",
											"        });\r",
											"    }\r",
											"\r",
											"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
											"        pm.expect(conditionGraph.v[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Result condition acct.id matches submitted condition\", function () {\r",
											"        pm.expect(conditionAccount.id).to.be.eql(targetConditionResult.acct.id);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Result condition acct.schmeNm.prtry matches submitted condition\", function () {\r",
											"        pm.expect(conditionAccount.schmeNm.prtry).to.be.eql(targetConditionResult.acct.schmeNm.prtry);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Result condition acct.agt.finInstnId.clrSysMmbId.mmbId matches submitted condition\", function () {\r",
											"        pm.expect(conditionAccount.agt.finInstnId.clrSysMmbId.mmbId).to.be.eql(targetConditionResult.acct.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
											"        pm.expect(conditionGraph.v[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
											"        pm.expect(conditionGraph.v[0].usr).to.be.eql(targetConditionResult.usr);\r",
											"    });\r",
											"\r",
											"    let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, conditionGraph.v[0]._key);\r",
											"\r",
											"    pm.test(`Database \"governed_as_debtor_account_by\" edge exists`, function () {\r",
											"        pm.expect(edgeList).to.include.members([\"governed_as_debtor_account_by\"]);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database 'governed_as_creditor_account_by' edge exists\", function () {\r",
											"        pm.expect(edgeList).to.include.members([\"governed_as_creditor_account_by\"]);\r",
											"    });\r",
											"\r",
											"    pm.test(`Database \"governed_as_debtor_by\" edge does not exist`, function () {\r",
											"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_by\"]);\r",
											"    });\r",
											"\r",
											"    pm.test(`Database \"governed_as_creditor_by\" edge does not exist`, function () {\r",
											"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_by\"]);\r",
											"    });\r",
											"\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const tenantId = submittedPacs008Message.TenantId;\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"tenantId\", tenantId);\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = utils.getCreateAccountConditionBody(\r",
											"    /* Event Types */ null,             // null defaults ['pain.001.001.13', 'pain.013.001.09', 'pacs.008.01.10', 'pacs.002.01.11']\r",
											"    /* Condition Type */ null,          // null defaults 'non-overridable-block'\r",
											"    /* Perspetive */ null,              // null defaults 'both'\r",
											"    /* Inception Date */ null,          // null defaults now()\r",
											"    /* Expiration Date */ null,         // null defaults now() + 24 hours\r",
											"    /* Condition Reason */ null,        // null defaults 'Default Test Condition'\r",
											"    /* Account */ dbtrAcctId,            // null defaults new unknown account\r",
											"    /* Force Create */ false,           // null defaults true\r",
											"    /* User ID */ null                  // null defaults 'POSTMAN'\r",
											");\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', messageBody);\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-account-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-account-condition}}"
									]
								}
							},
							"response": [
								{
									"name": "Create New Account Condition - Unknown debtor account",
									"originalRequest": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-account-condition}}",
											"host": [
												"{{tazamaAdminUrl}}{{path-admin-api-version}}"
											],
											"path": [
												"{{path-account-condition}}"
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "json",
									"header": [
										{
											"key": "access-control-allow-origin",
											"value": "*"
										},
										{
											"key": "content-type",
											"value": "application/json; charset=utf-8"
										},
										{
											"key": "content-length",
											"value": "775"
										},
										{
											"key": "Date",
											"value": "Thu, 01 May 2025 05:41:46 GMT"
										},
										{
											"key": "Connection",
											"value": "keep-alive"
										},
										{
											"key": "Keep-Alive",
											"value": "timeout=72"
										}
									],
									"cookie": [],
									"body": "{\n    \"message\": \"New condition was saved successfully.\",\n    \"result\": {\n        \"conditions\": [\n            {\n                \"condId\": \"74364848-d6fd-46e6-be4e-09e9bf8b1ca7\",\n                \"condTp\": \"non-overridable-block\",\n                \"incptnDtTm\": \"2025-05-01T05:41:46.721Z\",\n                \"condRsn\": \"Default Test Condition\",\n                \"usr\": \"POSTMAN\",\n                \"creDtTm\": \"2025-05-01T05:41:46.721Z\",\n                \"prsptvs\": [\n                    {\n                        \"prsptv\": \"governed_as_creditor_account_by\",\n                        \"evtTp\": [\n                            \"pain.001.001.11\",\n                            \"pain.013.001.09\",\n                            \"pacs.008.001.10\",\n                            \"pacs.002.001.12\"\n                        ],\n                        \"incptnDtTm\": \"2025-05-01T05:41:46.721Z\"\n                    },\n                    {\n                        \"prsptv\": \"governed_as_debtor_account_by\",\n                        \"evtTp\": [\n                            \"pain.001.001.11\",\n                            \"pain.013.001.09\",\n                            \"pacs.008.001.10\",\n                            \"pacs.002.001.12\"\n                        ],\n                        \"incptnDtTm\": \"2025-05-01T05:41:46.721Z\"\n                    }\n                ]\n            }\n        ],\n        \"acct\": {\n            \"id\": \"dbtrAcct_d1cf30fe9ce244aea8cf5eac6cf2dcd4\",\n            \"schmeNm\": {\n                \"prtry\": \"MSISDN\"\n            },\n            \"agt\": {\n                \"finInstnId\": {\n                    \"clrSysMmbId\": {\n                        \"mmbId\": \"fsp001\"\n                    }\n                }\n            }\n        }\n    }\n}"
								}
							]
						},
						{
							"name": "Create New Account Condition Manually - Unknown debtor account",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"let conditionResult = responseJSON.result.conditions;\r",
											"let conditionAccount = responseJSON.result.acct;\r",
											"let requestMessage = responseJSON.message;\r",
											"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
											"let tenantId = pm.globals.get(\"tenantId\");\r",
											"let acctId = pm.globals.get(\"dbtrAcctId\");\r",
											"let acctIdSchme = pm.globals.get(\"dbtrAcctIdSchmeNm\");\r",
											"let acctAgt = pm.globals.get(\"dbtrAgt\");\r",
											"let targetAccountId = acctId + acctIdSchme + acctAgt;\r",
											"\r",
											"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
											"targetRequestMessage = \"New condition was saved successfully.\"\r",
											"\r",
											"pm.test(\"Status code is 200\", function () {\r",
											"    pm.response.to.have.status(200);\r",
											"});\r",
											"\r",
											"pm.test(\"Result message matches target result message\", function () {\r",
											"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
											"});\r",
											"\r",
											"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
											"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
											"});\r",
											"\r",
											"pm.test(\"Result conditions array only contains a single condition\", function () {\r",
											"    pm.expect(conditionResult.length).to.be.eql(1);\r",
											"});\r",
											"\r",
											"let firstElement = conditionResult[0];\r",
											"\r",
											"pm.test(\"Result condition has a non-empty condId\", function () {\r",
											"    pm.expect(firstElement.condId).to.exist.and.not.be.empty;\r",
											"});\r",
											"\r",
											"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
											"    pm.expect(firstElement.condTp).to.be.eql(targetConditionResult.condTp);\r",
											"});\r",
											"\r",
											"if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
											"    pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
											"        pm.expect(firstElement.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
											"    });\r",
											"} else {    // if not, one must have been defaulted\r",
											"    pm.test(\"Result condition has a non-empty incptnDtTm\", function () {\r",
											"        pm.expect(firstElement.incptnDtTm).to.exist.and.not.be.empty;\r",
											"    });\r",
											"}\r",
											"\r",
											"if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
											"    pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
											"        pm.expect(firstElement.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
											"    });\r",
											"} else {    // if not, one must not have been defaulted\r",
											"    pm.test(\"Result condition does not have an xprtnDtTm\", function () {\r",
											"        pm.expect(firstElement.xprtnDtTm).to.not.exist;\r",
											"    });\r",
											"}\r",
											"\r",
											"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
											"    pm.expect(firstElement.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
											"});\r",
											"\r",
											"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
											"    pm.expect(firstElement.usr).to.be.eql(targetConditionResult.usr);\r",
											"});\r",
											"\r",
											"pm.test(\"Result condition has a non-empty creDtTm\", function () {\r",
											"    pm.expect(firstElement.creDtTm).to.exist.and.not.be.empty;\r",
											"});\r",
											"\r",
											"// create an array that only includes the perspective descriptions so that we can evaluate them easily\r",
											"let perspectives = firstElement.prsptvs.map(({ prsptv }) => prsptv);\r",
											"\r",
											"if (targetConditionResult.prsptv === \"both\") {\r",
											"    pm.test(\"Result prsptv array contains only 2 perspectives\", function () {\r",
											"        pm.expect(firstElement.prsptvs.length).to.be.eql(2);\r",
											"    });\r",
											"\r",
											"    let targetPerspectives = [\"governed_as_creditor_account_by\", \"governed_as_debtor_account_by\"];\r",
											"\r",
											"    pm.test(`Result prsptv array contains both ${JSON.stringify(targetPerspectives)} perspectives`, function () {\r",
											"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
											"    });\r",
											"\r",
											"} else if (targetConditionResult.prsptv === \"debtor\") {\r",
											"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
											"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
											"    });\r",
											"\r",
											"    let targetPerspectives = [\"governed_as_debtor_account_by\"];\r",
											"\r",
											"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
											"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
											"    });\r",
											"\r",
											"} else if (targetConditionResult.prsptv === \"creditor\") {\r",
											"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
											"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
											"    });\r",
											"\r",
											"    let targetPerspectives = [\"governed_as_creditor_by\"];\r",
											"\r",
											"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
											"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
											"    });\r",
											"\r",
											"};\r",
											"\r",
											"for (let i = 0; i < firstElement.prsptvs.length; i++) {   // for each perspective\r",
											"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} contains a non-empty evtTp array`, function () {\r",
											"        pm.expect(firstElement.prsptvs[i].evtTp).to.be.an('array').and.not.be.empty;\r",
											"    });\r",
											"\r",
											"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} evtTp array matches submitted condition`, function () {\r",
											"        pm.expect(firstElement.prsptvs[i].evtTp).to.include.members(targetConditionResult.evtTp);\r",
											"    });\r",
											"\r",
											"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
											"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches submitted condition`, function () {\r",
											"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
											"        });\r",
											"    } else {    // if not, one must have been defaulted\r",
											"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches created condition incptDtTm`, function () {\r",
											"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.eql(firstElement.incptnDtTm);\r",
											"        });\r",
											"    }\r",
											"\r",
											"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
											"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} xprtnDtTm matches submitted condition`, function () {\r",
											"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
											"        });\r",
											"    } else {    // if not, one must not have been defaulted\r",
											"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} does not have an xprtnDtTm`, function () {\r",
											"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.not.exist;\r",
											"        });\r",
											"    }\r",
											"\r",
											"}\r",
											"\r",
											"pm.test(\"Result condition acct.id matches submitted condition\", function () {\r",
											"    pm.expect(conditionAccount.id).to.be.eql(targetConditionResult.acct.id);\r",
											"});\r",
											"\r",
											"pm.test(\"Result condition acct.schmeNm.prtry matches submitted condition\", function () {\r",
											"    pm.expect(conditionAccount.schmeNm.prtry).to.be.eql(targetConditionResult.acct.schmeNm.prtry);\r",
											"});\r",
											"\r",
											"pm.test(\"Result condition acct.agt.finInstnId.clrSysMmbId.mmbId matches submitted condition\", function () {\r",
											"    pm.expect(conditionAccount.agt.finInstnId.clrSysMmbId.mmbId).to.be.eql(targetConditionResult.acct.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"});\r",
											"\r",
											"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetAccountId, false);\r",
											"\r",
											"await pm.sendRequest(postRequest, (error, response) => {\r",
											"    if (utils.getLogLevel() === 'DEBUG') {\r",
											"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
											"    }\r",
											"    databaseConditionResult = response.json().data;\r",
											"\r",
											"    if (utils.getLogLevel() === 'DEBUG') {\r",
											"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
											"    }\r",
											"\r",
											"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
											"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
											"\r",
											"    pm.test(`Only one condition for account [${targetAccountId}] exists in the database`, function () {\r",
											"        pm.expect(graphConditionList.length).to.eql(1);\r",
											"    });\r",
											"\r",
											"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
											"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
											"            pm.expect(conditionGraph.v[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
											"        });\r",
											"    }\r",
											"\r",
											"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
											"        pm.expect(conditionGraph.v[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
											"        pm.expect(conditionGraph.v[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
											"    });\r",
											"\r",
											"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
											"        pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
											"            pm.expect(conditionGraph.v[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
											"        });\r",
											"    } else {    // if not, one must have been defaulted\r",
											"        pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
											"            pm.expect(conditionGraph.v[0].incptnDtTm).to.exist.and.not.be.empty;\r",
											"        });\r",
											"    }\r",
											"\r",
											"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
											"        pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
											"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
											"        });\r",
											"    } else {    // if not, one must not have been defaulted\r",
											"        pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
											"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.not.exist;\r",
											"        });\r",
											"    }\r",
											"\r",
											"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
											"        pm.expect(conditionGraph.v[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database condition.acct.id matches submitted condition\", function () {\r",
											"        pm.expect(conditionGraph.v[0].acct.id).to.be.eql(targetConditionResult.acct.id);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database condition.acct.schmeNm.prtry matches submitted condition\", function () {\r",
											"        pm.expect(conditionGraph.v[0].acct.schmeNm.prtry).to.be.eql(targetConditionResult.acct.schmeNm.prtry);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database condition.acct.agt.finInstnId.clrSysMmbId.mmbId matches submitted condition\", function () {\r",
											"        pm.expect(conditionGraph.v[0].acct.agt.finInstnId.clrSysMmbId.mmbId).to.be.eql(targetConditionResult.acct.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
											"        pm.expect(conditionGraph.v[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
											"        pm.expect(conditionGraph.v[0].usr).to.be.eql(targetConditionResult.usr);\r",
											"    });\r",
											"\r",
											"    let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, conditionGraph.v[0]._key);\r",
											"\r",
											"    pm.test(`Database \"governed_as_debtor_account-by\" edge exists`, function () {\r",
											"        pm.expect(edgeList).to.include.members([\"governed_as_debtor_account_by\"]);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database 'governed_as_creditor_account_by' edge exists\", function () {\r",
											"        pm.expect(edgeList).to.include.members([\"governed_as_creditor_account_by\"]);\r",
											"    });\r",
											"\r",
											"    pm.test(`Database \"governed_as_debtor_by\" edge does not exist`, function () {\r",
											"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_by\"]);\r",
											"    });\r",
											"\r",
											"    pm.test(`Database \"governed_as_creditor_by\" edge does not exist`, function () {\r",
											"        pm.expect(edgeList).to.not.include.members([\"governed_as_credito_by\"]);\r",
											"    });\r",
											"\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"console.log(dbtrAcctId)\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = {\r",
											"    \"evtTp\": [\"pain.001.001.11\", \"pain.013.001.09\", \"pacs.008.001.10\", \"pacs.002.001.12\"],\r",
											"    \"condTp\": \"non-overridable-block\",\r",
											"    \"prsptv\": \"both\",\r",
											"    \"condRsn\": \"Default Test Condition\",\r",
											"    \"acct\":\r",
											"    {\r",
											"        \"id\": `${dbtrAcctId.id}`,\r",
											"        \"schmeNm\":\r",
											"        {\r",
											"            \"prtry\": \"MSISDN\"\r",
											"        },\r",
											"        \"agt\": {\r",
											"            \"finInstnId\": {\r",
											"                \"clrSysMmbId\": {\r",
											"                    \"mmbId\": \"fsp001\"\r",
											"                }\r",
											"            }\r",
											"        }\r",
											"    },\r",
											"    \"forceCret\": true,\r",
											"    \"usr\": \"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-account-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-account-condition}}"
									]
								}
							},
							"response": [
								{
									"name": "Create New Account Condition Manually - Unknown debtor account",
									"originalRequest": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-account-condition}}",
											"host": [
												"{{tazamaAdminUrl}}{{path-admin-api-version}}"
											],
											"path": [
												"{{path-account-condition}}"
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "json",
									"header": [
										{
											"key": "access-control-allow-origin",
											"value": "*"
										},
										{
											"key": "content-type",
											"value": "application/json; charset=utf-8"
										},
										{
											"key": "content-length",
											"value": "775"
										},
										{
											"key": "Date",
											"value": "Thu, 01 May 2025 05:41:50 GMT"
										},
										{
											"key": "Connection",
											"value": "keep-alive"
										},
										{
											"key": "Keep-Alive",
											"value": "timeout=72"
										}
									],
									"cookie": [],
									"body": "{\n    \"message\": \"New condition was saved successfully.\",\n    \"result\": {\n        \"conditions\": [\n            {\n                \"condId\": \"bda2e2e8-3922-429d-83fa-01849b469692\",\n                \"condTp\": \"non-overridable-block\",\n                \"incptnDtTm\": \"2025-05-01T05:41:50.723Z\",\n                \"condRsn\": \"Default Test Condition\",\n                \"usr\": \"POSTMAN\",\n                \"creDtTm\": \"2025-05-01T05:41:50.723Z\",\n                \"prsptvs\": [\n                    {\n                        \"prsptv\": \"governed_as_creditor_account_by\",\n                        \"evtTp\": [\n                            \"pain.001.001.11\",\n                            \"pain.013.001.09\",\n                            \"pacs.008.001.10\",\n                            \"pacs.002.001.12\"\n                        ],\n                        \"incptnDtTm\": \"2025-05-01T05:41:50.723Z\"\n                    },\n                    {\n                        \"prsptv\": \"governed_as_debtor_account_by\",\n                        \"evtTp\": [\n                            \"pain.001.001.11\",\n                            \"pain.013.001.09\",\n                            \"pacs.008.001.10\",\n                            \"pacs.002.001.12\"\n                        ],\n                        \"incptnDtTm\": \"2025-05-01T05:41:50.723Z\"\n                    }\n                ]\n            }\n        ],\n        \"acct\": {\n            \"id\": \"dbtrAcct_656eab0a5dab4129b0a767d0ac71b917\",\n            \"schmeNm\": {\n                \"prtry\": \"MSISDN\"\n            },\n            \"agt\": {\n                \"finInstnId\": {\n                    \"clrSysMmbId\": {\n                        \"mmbId\": \"fsp001\"\n                    }\n                }\n            }\n        }\n    }\n}"
								}
							]
						},
						{
							"name": "Create New Account Condition - Existing debtor account",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"let conditionResult = responseJSON.result.conditions;\r",
											"let conditionAccount = responseJSON.result.acct;\r",
											"let requestMessage = responseJSON.message;\r",
											"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
											"let tenantId = pm.globals.get(\"tenantId\");\r",
											"let acctId = pm.globals.get(\"dbtrAcctId\");\r",
											"let acctIdSchme = pm.globals.get(\"dbtrAcctIdSchmeNm\");\r",
											"let acctAgt = pm.globals.get(\"dbtrAgt\");\r",
											"let targetAccountId = acctId + acctIdSchme + acctAgt;\r",
											"\r",
											"\r",
											"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
											"targetRequestMessage = \"New condition was saved successfully.\"\r",
											"\r",
											"console.log('targetAccountId')\r",
											"console.log(targetAccountId)\r",
											"\r",
											"pm.test(\"Status code is 200\", function () {\r",
											"    pm.response.to.have.status(200);\r",
											"});\r",
											"\r",
											"pm.test(\"Result message matches target result message\", function () {\r",
											"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
											"});\r",
											"\r",
											"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
											"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
											"});\r",
											"\r",
											"pm.test(\"Result conditions array only contains a single condition\", function () {\r",
											"    pm.expect(conditionResult.length).to.be.eql(1);\r",
											"});\r",
											"\r",
											"let firstElement = conditionResult[0];\r",
											"\r",
											"pm.test(\"Result condition has a non-empty condId\", function () {\r",
											"    pm.expect(firstElement.condId).to.exist.and.not.be.empty;\r",
											"});\r",
											"\r",
											"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
											"    pm.expect(firstElement.condTp).to.be.eql(targetConditionResult.condTp);\r",
											"});\r",
											"\r",
											"if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
											"    pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
											"        pm.expect(firstElement.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
											"    });\r",
											"} else {    // if not, one must have been defaulted\r",
											"    pm.test(\"Result condition has a non-empty incptnDtTm\", function () {\r",
											"        pm.expect(firstElement.incptnDtTm).to.exist.and.not.be.empty;\r",
											"    });\r",
											"}\r",
											"\r",
											"if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
											"    pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
											"        pm.expect(firstElement.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
											"    });\r",
											"} else {    // if not, one must not have been defaulted\r",
											"    pm.test(\"Result condition does not have an xprtnDtTm\", function () {\r",
											"        pm.expect(firstElement.xprtnDtTm).to.not.exist;\r",
											"    });\r",
											"}\r",
											"\r",
											"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
											"    pm.expect(firstElement.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
											"});\r",
											"\r",
											"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
											"    pm.expect(firstElement.usr).to.be.eql(targetConditionResult.usr);\r",
											"});\r",
											"\r",
											"pm.test(\"Result condition has a non-empty creDtTm\", function () {\r",
											"    pm.expect(firstElement.creDtTm).to.exist.and.not.be.empty;\r",
											"});\r",
											"\r",
											"// create an array that only includes the perspective descriptions so that we can evaluate them easily\r",
											"let perspectives = firstElement.prsptvs.map(({ prsptv }) => prsptv);\r",
											"\r",
											"if (targetConditionResult.prsptv === \"both\") {\r",
											"    pm.test(\"Result prsptv array contains only 2 perspectives\", function () {\r",
											"        pm.expect(firstElement.prsptvs.length).to.be.eql(2);\r",
											"    });\r",
											"\r",
											"    let targetPerspectives = [\"governed_as_creditor_account_by\", \"governed_as_debtor_account_by\"];\r",
											"\r",
											"    pm.test(`Result prsptv array contains both ${JSON.stringify(targetPerspectives)} perspectives`, function () {\r",
											"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
											"    });\r",
											"\r",
											"} else if (targetConditionResult.prsptv === \"debtor\") {\r",
											"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
											"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
											"    });\r",
											"\r",
											"    let targetPerspectives = [\"governed_as_debtor_account_by\"];\r",
											"\r",
											"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
											"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
											"    });\r",
											"\r",
											"} else if (targetConditionResult.prsptv === \"creditor\") {\r",
											"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
											"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
											"    });\r",
											"\r",
											"    let targetPerspectives = [\"governed_as_creditor_account_by\"];\r",
											"\r",
											"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
											"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
											"    });\r",
											"\r",
											"};\r",
											"\r",
											"for (let i = 0; i < firstElement.prsptvs.length; i++) {   // for each perspective\r",
											"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} contains a non-empty evtTp array`, function () {\r",
											"        pm.expect(firstElement.prsptvs[i].evtTp).to.be.an('array').and.not.be.empty;\r",
											"    });\r",
											"\r",
											"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} evtTp array matches submitted condition`, function () {\r",
											"        pm.expect(firstElement.prsptvs[i].evtTp).to.include.members(targetConditionResult.evtTp);\r",
											"    });\r",
											"\r",
											"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
											"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches submitted condition`, function () {\r",
											"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
											"        });\r",
											"    } else {    // if not, one must have been defaulted\r",
											"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches created condition incptDtTm`, function () {\r",
											"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.eql(firstElement.incptnDtTm);\r",
											"        });\r",
											"    }\r",
											"\r",
											"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
											"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} xprtnDtTm matches submitted condition`, function () {\r",
											"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
											"        });\r",
											"    } else {    // if not, one must not have been defaulted\r",
											"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} does not have an xprtnDtTm`, function () {\r",
											"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.not.exist;\r",
											"        });\r",
											"    }\r",
											"\r",
											"}\r",
											"\r",
											"pm.test(\"Result condition acct.id matches submitted condition\", function () {\r",
											"    pm.expect(conditionAccount.id).to.be.eql(targetConditionResult.acct.id);\r",
											"});\r",
											"\r",
											"pm.test(\"Result condition acct.schmeNm.prtry matches submitted condition\", function () {\r",
											"    pm.expect(conditionAccount.schmeNm.prtry).to.be.eql(targetConditionResult.acct.schmeNm.prtry);\r",
											"});\r",
											"\r",
											"pm.test(\"Result condition acct.agt.finInstnId.clrSysMmbId.mmbId matches submitted condition\", function () {\r",
											"    pm.expect(conditionAccount.agt.finInstnId.clrSysMmbId.mmbId).to.be.eql(targetConditionResult.acct.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"});\r",
											"\r",
											"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetAccountId, false);\r",
											"\r",
											"await pm.sendRequest(postRequest, (error, response) => {\r",
											"    if (utils.getLogLevel() === 'DEBUG') {\r",
											"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
											"    }\r",
											"    databaseConditionResult = response.json().data;\r",
											"\r",
											"    if (utils.getLogLevel() === 'DEBUG') {\r",
											"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
											"    }\r",
											"\r",
											"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
											"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
											"\r",
											"    pm.test(`Only one condition for account [${targetAccountId}] exists in the database`, function () {\r",
											"        pm.expect(graphConditionList.length).to.eql(1);\r",
											"    });\r",
											"\r",
											"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
											"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
											"            pm.expect(conditionGraph.v[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
											"        });\r",
											"    }\r",
											"\r",
											"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
											"        pm.expect(conditionGraph.v[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
											"        pm.expect(conditionGraph.v[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
											"    });\r",
											"\r",
											"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
											"        pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
											"            pm.expect(conditionGraph.v[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
											"        });\r",
											"    } else {    // if not, one must have been defaulted\r",
											"        pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
											"            pm.expect(conditionGraph.v[0].incptnDtTm).to.exist.and.not.be.empty;\r",
											"        });\r",
											"    }\r",
											"\r",
											"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
											"        pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
											"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
											"        });\r",
											"    } else {    // if not, one must not have been defaulted\r",
											"        pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
											"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.not.exist;\r",
											"        });\r",
											"    }\r",
											"\r",
											"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
											"        pm.expect(conditionGraph.v[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database condition.acct.id matches submitted condition\", function () {\r",
											"        pm.expect(conditionGraph.v[0].acct.id).to.be.eql(targetConditionResult.acct.id);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database condition.acct.schmeNm.prtry matches submitted condition\", function () {\r",
											"        pm.expect(conditionGraph.v[0].acct.schmeNm.prtry).to.be.eql(targetConditionResult.acct.schmeNm.prtry);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database condition.acct.agt.finInstnId.clrSysMmbId.mmbId matches submitted condition\", function () {\r",
											"        pm.expect(conditionGraph.v[0].acct.agt.finInstnId.clrSysMmbId.mmbId).to.be.eql(targetConditionResult.acct.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
											"        pm.expect(conditionGraph.v[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
											"        pm.expect(conditionGraph.v[0].usr).to.be.eql(targetConditionResult.usr);\r",
											"    });\r",
											"\r",
											"    let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, conditionGraph.v[0]._key);\r",
											"\r",
											"    pm.test(`Database \"governed_as_debtor_account_by\" edge exists`, function () {\r",
											"        pm.expect(edgeList).to.include.members([\"governed_as_debtor_account_by\"]);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database 'governed_as_creditor_account_by' edge exists\", function () {\r",
											"        pm.expect(edgeList).to.include.members([\"governed_as_creditor_account_by\"]);\r",
											"    });\r",
											"\r",
											"    pm.test(`Database \"governed_as_debtor_by\" edge does not exist`, function () {\r",
											"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_by\"]);\r",
											"    });\r",
											"\r",
											"    pm.test(`Database \"governed_as_creditor_by\" edge does not exist`, function () {\r",
											"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_by\"]);\r",
											"    });\r",
											"\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction (in the databases)\r",
											"messageSets = await utils.createTransactionSetsInDatabase();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSets[0].pacs008);\r",
											"\r",
											"// Stash the created pacs.008 message\r",
											"pm.globals.set(\"pacs008\", JSON.stringify(submittedPacs008Message));\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const tenantId = submittedPacs008Message.TenantId;\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"tenantId\", tenantId);\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = utils.getCreateAccountConditionBody(\r",
											"    /* Event Types */ null,             // null defaults ['pain.001.001.13', 'pain.013.001.09', 'pacs.008.01.10', 'pacs.002.01.11']\r",
											"    /* Condition Type */ null,          // null defaults 'non-overridable-block'\r",
											"    /* Perspetive */ null,              // null defaults 'both'\r",
											"    /* Inception Date */ null,          // null defaults now()\r",
											"    /* Expiration Date */ null,         // null defaults now() + 24 hours\r",
											"    /* Condition Reason */ null,        // null defaults 'Default Test Condition'\r",
											"    /* Account */ dbtrAcctId,            // null defaults new unknown account\r",
											"    /* Force Create */ false,           // null defaults true\r",
											"    /* User ID */ null                  // null defaults 'POSTMAN'\r",
											");\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', messageBody);\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-account-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-account-condition}}"
									]
								}
							},
							"response": [
								{
									"name": "Create New Account Condition - Existing debtor account",
									"originalRequest": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-account-condition}}",
											"host": [
												"{{tazamaAdminUrl}}{{path-admin-api-version}}"
											],
											"path": [
												"{{path-account-condition}}"
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "json",
									"header": [
										{
											"key": "access-control-allow-origin",
											"value": "*"
										},
										{
											"key": "content-type",
											"value": "application/json; charset=utf-8"
										},
										{
											"key": "content-length",
											"value": "775"
										},
										{
											"key": "Date",
											"value": "Thu, 01 May 2025 05:41:55 GMT"
										},
										{
											"key": "Connection",
											"value": "keep-alive"
										},
										{
											"key": "Keep-Alive",
											"value": "timeout=72"
										}
									],
									"cookie": [],
									"body": "{\n    \"message\": \"New condition was saved successfully.\",\n    \"result\": {\n        \"conditions\": [\n            {\n                \"condId\": \"cb83a030-f77b-422b-ac0f-cfa327c24fd2\",\n                \"condTp\": \"non-overridable-block\",\n                \"incptnDtTm\": \"2025-05-01T05:41:55.944Z\",\n                \"condRsn\": \"Default Test Condition\",\n                \"usr\": \"POSTMAN\",\n                \"creDtTm\": \"2025-05-01T05:41:55.944Z\",\n                \"prsptvs\": [\n                    {\n                        \"prsptv\": \"governed_as_creditor_account_by\",\n                        \"evtTp\": [\n                            \"pain.001.001.11\",\n                            \"pain.013.001.09\",\n                            \"pacs.008.001.10\",\n                            \"pacs.002.001.12\"\n                        ],\n                        \"incptnDtTm\": \"2025-05-01T05:41:55.944Z\"\n                    },\n                    {\n                        \"prsptv\": \"governed_as_debtor_account_by\",\n                        \"evtTp\": [\n                            \"pain.001.001.11\",\n                            \"pain.013.001.09\",\n                            \"pacs.008.001.10\",\n                            \"pacs.002.001.12\"\n                        ],\n                        \"incptnDtTm\": \"2025-05-01T05:41:55.944Z\"\n                    }\n                ]\n            }\n        ],\n        \"acct\": {\n            \"id\": \"dbtrAcct_a524004bc6204c279fccabd3380881e8\",\n            \"schmeNm\": {\n                \"prtry\": \"MSISDN\"\n            },\n            \"agt\": {\n                \"finInstnId\": {\n                    \"clrSysMmbId\": {\n                        \"mmbId\": \"fsp001\"\n                    }\n                }\n            }\n        }\n    }\n}"
								}
							]
						},
						{
							"name": "Create Another New Account Condition - Existing debtor account",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"let conditionResult = responseJSON.result.conditions;\r",
											"let conditionAccount = responseJSON.result.acct;\r",
											"let requestMessage = responseJSON.message;\r",
											"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
											"let tenantId = pm.globals.get(\"tenantId\");\r",
											"let acctId = pm.globals.get(\"dbtrAcctId\");\r",
											"let acctIdSchme = pm.globals.get(\"dbtrAcctIdSchmeNm\");\r",
											"let acctAgt = pm.globals.get(\"dbtrAgt\");\r",
											"let targetAccountId = acctId + acctIdSchme + acctAgt;\r",
											"\r",
											"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
											"targetRequestMessage = \"1 conditions already exist for the account\"\r",
											"\r",
											"pm.test(\"Status code is 200\", function () {\r",
											"    pm.response.to.have.status(200);\r",
											"});\r",
											"\r",
											"pm.test(\"Result message matches target result message\", function () {\r",
											"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
											"});\r",
											"\r",
											"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
											"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
											"});\r",
											"\r",
											"pm.test(\"Result conditions array contains two conditions\", function () {\r",
											"    pm.expect(conditionResult.length).to.be.eql(2);\r",
											"});\r",
											"\r",
											"let newElement = conditionResult[conditionResult.length - 1];  // the last element is the newly submitted condition\r",
											"\r",
											"pm.test(\"Result condition has a non-empty condId\", function () {\r",
											"    pm.expect(newElement.condId).to.exist.and.not.be.empty;\r",
											"});\r",
											"\r",
											"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
											"    pm.expect(newElement.condTp).to.be.eql(targetConditionResult.condTp);\r",
											"});\r",
											"\r",
											"if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
											"    pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
											"        pm.expect(newElement.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
											"    });\r",
											"} else {    // if not, one must have been defaulted\r",
											"    pm.test(\"Result condition has a non-empty incptnDtTm\", function () {\r",
											"        pm.expect(newElement.incptnDtTm).to.exist.and.not.be.empty;\r",
											"    });\r",
											"}\r",
											"\r",
											"if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
											"    pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
											"        pm.expect(newElement.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
											"    });\r",
											"} else {    // if not, one must not have been defaulted\r",
											"    pm.test(\"Result condition does not have an xprtnDtTm\", function () {\r",
											"        pm.expect(newElement.xprtnDtTm).to.not.exist;\r",
											"    });\r",
											"}\r",
											"\r",
											"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
											"    pm.expect(newElement.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
											"});\r",
											"\r",
											"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
											"    pm.expect(newElement.usr).to.be.eql(targetConditionResult.usr);\r",
											"});\r",
											"\r",
											"pm.test(\"Result condition has a non-empty creDtTm\", function () {\r",
											"    pm.expect(newElement.creDtTm).to.exist.and.not.be.empty;\r",
											"});\r",
											"\r",
											"// create an array that only includes the perspective descriptions so that we can evaluate them easily\r",
											"let perspectives = newElement.prsptvs.map(({ prsptv }) => prsptv);\r",
											"\r",
											"if (targetConditionResult.prsptv === \"both\") {\r",
											"    pm.test(\"Result prsptv array contains only 2 perspectives\", function () {\r",
											"        pm.expect(newElement.prsptvs.length).to.be.eql(2);\r",
											"    });\r",
											"\r",
											"    let targetPerspectives = [\"governed_as_creditor_account_by\", \"governed_as_debtor_account_by\"];\r",
											"\r",
											"    pm.test(`Result prsptv array contains both ${JSON.stringify(targetPerspectives)} perspectives`, function () {\r",
											"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
											"    });\r",
											"\r",
											"} else if (targetConditionResult.prsptv === \"debtor\") {\r",
											"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
											"        pm.expect(newElement.prsptvs.length).to.be.eql(1);\r",
											"    });\r",
											"\r",
											"    let targetPerspectives = [\"governed_as_debtor_by\"];\r",
											"\r",
											"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
											"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
											"    });\r",
											"\r",
											"} else if (targetConditionResult.prsptv === \"creditor\") {\r",
											"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
											"        pm.expect(newElement.prsptvs.length).to.be.eql(1);\r",
											"    });\r",
											"\r",
											"    let targetPerspectives = [\"governed_as_creditor_by\"];\r",
											"\r",
											"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
											"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
											"    });\r",
											"\r",
											"};\r",
											"\r",
											"for (let i = 0; i < newElement.prsptvs.length; i++) {   // for each perspective\r",
											"    pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} contains a non-empty evtTp array`, function () {\r",
											"        pm.expect(newElement.prsptvs[i].evtTp).to.be.an('array').and.not.be.empty;\r",
											"    });\r",
											"\r",
											"    pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} evtTp array matches submitted condition`, function () {\r",
											"        pm.expect(newElement.prsptvs[i].evtTp).to.include.members(targetConditionResult.evtTp);\r",
											"    });\r",
											"\r",
											"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
											"        pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} incptnDtTm matches submitted condition`, function () {\r",
											"            pm.expect(newElement.prsptvs[i].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
											"        });\r",
											"    } else {    // if not, one must have been defaulted\r",
											"        pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} incptnDtTm matches created condition incptDtTm`, function () {\r",
											"            pm.expect(newElement.prsptvs[i].incptnDtTm).to.eql(newElement.incptnDtTm);\r",
											"        });\r",
											"    }\r",
											"\r",
											"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
											"        pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} xprtnDtTm matches submitted condition`, function () {\r",
											"            pm.expect(newElement.prsptvs[i].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
											"        });\r",
											"    } else {    // if not, one must not have been defaulted\r",
											"        pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} does not have an xprtnDtTm`, function () {\r",
											"            pm.expect(newElement.prsptvs[i].xprtnDtTm).to.not.exist;\r",
											"        });\r",
											"    }\r",
											"\r",
											"}\r",
											"\r",
											"pm.test(\"Result condition acct.id matches submitted condition\", function () {\r",
											"    pm.expect(conditionAccount.id).to.be.eql(targetConditionResult.acct.id);\r",
											"});\r",
											"\r",
											"pm.test(\"Result condition acct.schmeNm.prtry matches submitted condition\", function () {\r",
											"    pm.expect(conditionAccount.schmeNm.prtry).to.be.eql(targetConditionResult.acct.schmeNm.prtry);\r",
											"});\r",
											"\r",
											"pm.test(\"Result condition acct.agt.finInstnId.clrSysMmbId.mmbId matches submitted condition\", function () {\r",
											"    pm.expect(conditionAccount.agt.finInstnId.clrSysMmbId.mmbId).to.be.eql(targetConditionResult.acct.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"});\r",
											"\r",
											"// Now we want to test that the data in the database matches the submitted data AND the response data\r",
											"\r",
											"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetAccountId, false);\r",
											"\r",
											"await pm.sendRequest(postRequest, (error, response) => {\r",
											"    if (utils.getLogLevel() === 'DEBUG') {\r",
											"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
											"    }\r",
											"    databaseConditionResult = response.json().data;\r",
											"\r",
											"    if (utils.getLogLevel() === 'DEBUG') {\r",
											"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
											"    }\r",
											"\r",
											"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
											"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
											"    let submittedCondition = graphConditionList.filter(condition => condition._id === `conditions/${newElement.condId}`);\r",
											"\r",
											"    // First we check that the submitted condition matches the database version\r",
											"\r",
											"    pm.test(`Only two conditions for account [${targetAccountId}] exists in the database`, function () {\r",
											"        pm.expect(graphConditionList.length).to.eql(2);\r",
											"    });\r",
											"\r",
											"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
											"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
											"            pm.expect(submittedCondition[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
											"        });\r",
											"    }\r",
											"\r",
											"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
											"        pm.expect(submittedCondition[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
											"        pm.expect(submittedCondition[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
											"    });\r",
											"\r",
											"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
											"        pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
											"            pm.expect(submittedCondition[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
											"        });\r",
											"    } else {    // if not, one must have been defaulted\r",
											"        pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
											"            pm.expect(submittedCondition[0].incptnDtTm).to.exist.and.not.be.empty;\r",
											"        });\r",
											"    }\r",
											"\r",
											"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
											"        pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
											"            pm.expect(submittedCondition[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
											"        });\r",
											"    } else {    // if not, one must not have been defaulted\r",
											"        pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
											"            pm.expect(submittedCondition[0].xprtnDtTm).to.not.exist;\r",
											"        });\r",
											"    }\r",
											"\r",
											"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
											"        pm.expect(submittedCondition[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database condition.acct.id matches submitted condition\", function () {\r",
											"        pm.expect(submittedCondition[0].acct.id).to.be.eql(targetConditionResult.acct.id);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database condition.acct.schmeNm.prtry matches submitted condition\", function () {\r",
											"        pm.expect(submittedCondition[0].acct.schmeNm.prtry).to.be.eql(targetConditionResult.acct.schmeNm.prtry);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database condition.acct.agt.finInstnId.clrSysMmbId.mmbId matches submitted condition\", function () {\r",
											"        pm.expect(submittedCondition[0].acct.agt.finInstnId.clrSysMmbId.mmbId).to.be.eql(targetConditionResult.acct.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
											"        pm.expect(submittedCondition[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
											"        pm.expect(submittedCondition[0].usr).to.be.eql(targetConditionResult.usr);\r",
											"    });\r",
											"\r",
											"    let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, submittedCondition[0]._key);\r",
											"\r",
											"    pm.test(`Database \"governed_as_debtor_account_by\" edge exists`, function () {\r",
											"        pm.expect(edgeList).to.include.members([\"governed_as_debtor_account_by\"]);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database 'governed_as_creditor_account_by' edge exists\", function () {\r",
											"        pm.expect(edgeList).to.include.members([\"governed_as_creditor_account_by\"]);\r",
											"    });\r",
											"\r",
											"    pm.test(`Database \"governed_as_debtor_by\" edge does not exist`, function () {\r",
											"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_by\"]);\r",
											"    });\r",
											"\r",
											"    pm.test(`Database \"governed_as_creditor_by\" edge does not exist`, function () {\r",
											"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_by\"]);\r",
											"    });\r",
											"\r",
											"    // Then we check the previous conditions in the response one-by-one against the database version\r",
											"    let previousConditionsFromResponse = graphConditionList.filter(condition => condition._id != `conditions/${newElement.condId}`);\r",
											"    let previousResponseConditionIds = previousConditionsFromResponse.map(({ condId }) => condId);\r",
											"    let previousConditionsFromDatabase = graphConditionList.filter(condition => condition._id != `conditions/${newElement.condId}`);\r",
											"    let previousDatabaseConditionIds = previousConditionsFromDatabase.map(({ condId }) => condId);\r",
											"\r",
											"    pm.test(`List of previous conditions in response match list of conditions from database`, function () {\r",
											"        pm.expect(previousResponseConditionIds).to.have.members(previousDatabaseConditionIds);\r",
											"    });\r",
											"\r",
											"    pm.test(`Only one previous condition for account [${targetAccountId}] exists in the reponse`, function () {\r",
											"        pm.expect(previousConditionsFromResponse.length).to.eql(1);\r",
											"    });\r",
											"\r",
											"    pm.test(`Only one previous condition for account [${targetAccountId}] exists in the database`, function () {\r",
											"        pm.expect(previousConditionsFromDatabase.length).to.eql(1);\r",
											"    });\r",
											"\r",
											"    for (let j = 0; j < previousConditionsFromResponse.length; j++) {\r",
											"\r",
											"        let justOneConditionFromResponse = previousConditionsFromResponse.filter(condition => condition._id === `conditions/${conditionResult[j].condId}`);\r",
											"        let sameConditionFromDatabase = previousConditionsFromDatabase.filter(condition => condition._id === `conditions/${conditionResult[j].condId}`);\r",
											"\r",
											"        for (let i = 0; i < sameConditionFromDatabase[0].evtTp.length; i++) {\r",
											"            pm.test(`Database condition.evtTp contains ${sameConditionFromDatabase[0].evtTp[i]}`, function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].evtTp).to.include.members([sameConditionFromDatabase[0].evtTp[i]]);\r",
											"            });\r",
											"        }\r",
											"\r",
											"        pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].condTp).to.be.eql(sameConditionFromDatabase[0].condTp);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].prsptv).to.be.eql(sameConditionFromDatabase[0].prsptv);\r",
											"        });\r",
											"\r",
											"        if (sameConditionFromDatabase[0].incptnDtTm) { // was an inception date specified?\r",
											"            pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].incptnDtTm).to.be.eql(sameConditionFromDatabase[0].incptnDtTm);\r",
											"            });\r",
											"        } else {    // if not, one must have been defaulted\r",
											"            pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].incptnDtTm).to.exist.and.not.be.empty;\r",
											"            });\r",
											"        }\r",
											"\r",
											"        if (sameConditionFromDatabase[0].xprtnDtTm) { // was an expiration date specified?\r",
											"            pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].xprtnDtTm).to.be.eql(sameConditionFromDatabase[0].xprtnDtTm);\r",
											"            });\r",
											"        } else {    // if not, one must not have been defaulted\r",
											"            pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].xprtnDtTm).to.not.exist;\r",
											"            });\r",
											"        }\r",
											"\r",
											"        pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].condRsn).to.be.eql(sameConditionFromDatabase[0].condRsn);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.acct.id matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].acct.id).to.be.eql(sameConditionFromDatabase[0].acct.id);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.acct.schmeNm.prtry matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].acct.schmeNm.prtry).to.be.eql(sameConditionFromDatabase[0].acct.schmeNm.prtry);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.acct.agt.finInstnId.clrSysMmbId.mmbId matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].acct.agt.finInstnId.clrSysMmbId.mmbId).to.be.eql(sameConditionFromDatabase[0].acct.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].forceCret).to.be.eql(sameConditionFromDatabase[0].forceCret);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].usr).to.be.eql(sameConditionFromDatabase[0].usr);\r",
											"        });\r",
											"\r",
											"        let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, justOneConditionFromResponse[0]._key);\r",
											"\r",
											"        pm.test(`Database \"governed_as_debtor_account_by\" edge exists`, function () {\r",
											"            pm.expect(edgeList).to.include.members([\"governed_as_debtor_account_by\"]);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database 'governed_as_creditor_account_by' edge exists\", function () {\r",
											"            pm.expect(edgeList).to.include.members([\"governed_as_creditor_account_by\"]);\r",
											"        });\r",
											"\r",
											"        pm.test(`Database \"governed_as_debtor_by\" edge does not exist`, function () {\r",
											"            pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_by\"]);\r",
											"        });\r",
											"\r",
											"        pm.test(`Database \"governed_as_creditor_by\" edge does not exist`, function () {\r",
											"            pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_by\"]);\r",
											"        });\r",
											"    }\r",
											"\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, JSON.parse(pm.globals.get(\"pacs008\")));\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const tenantId = submittedPacs008Message.TenantId;\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"tenantId\", tenantId);\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = utils.getCreateAccountConditionBody(\r",
											"    /* Event Types */ null,             // null defaults ['pain.001.001.13', 'pain.013.001.09', 'pacs.008.01.10', 'pacs.002.01.11']\r",
											"    /* Condition Type */ 'override',    // null defaults 'non-overridable-block'\r",
											"    /* Perspetive */ null,              // null defaults 'both'\r",
											"    /* Inception Date */ null,          // null defaults now()\r",
											"    /* Expiration Date */ null,         // null defaults now() + 24 hours\r",
											"    /* Condition Reason */ null,        // null defaults 'Default Test Condition'\r",
											"    /* Account */ dbtrAcctId,            // null defaults new unknown account\r",
											"    /* Force Create */ false,           // null defaults true\r",
											"    /* User ID */ null                  // null defaults 'POSTMAN'\r",
											");\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', messageBody);\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-account-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-account-condition}}"
									]
								}
							},
							"response": [
								{
									"name": "Create Another New Account Condition - Existing debtor account",
									"originalRequest": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-account-condition}}",
											"host": [
												"{{tazamaAdminUrl}}{{path-admin-api-version}}"
											],
											"path": [
												"{{path-account-condition}}"
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "json",
									"header": [
										{
											"key": "access-control-allow-origin",
											"value": "*"
										},
										{
											"key": "content-type",
											"value": "application/json; charset=utf-8"
										},
										{
											"key": "content-length",
											"value": "1439"
										},
										{
											"key": "Date",
											"value": "Thu, 01 May 2025 05:42:00 GMT"
										},
										{
											"key": "Connection",
											"value": "keep-alive"
										},
										{
											"key": "Keep-Alive",
											"value": "timeout=72"
										}
									],
									"cookie": [],
									"body": "{\n    \"message\": \"1 conditions already exist for the account\",\n    \"result\": {\n        \"conditions\": [\n            {\n                \"condId\": \"cb83a030-f77b-422b-ac0f-cfa327c24fd2\",\n                \"condTp\": \"non-overridable-block\",\n                \"incptnDtTm\": \"2025-05-01T05:41:55.944Z\",\n                \"condRsn\": \"Default Test Condition\",\n                \"usr\": \"POSTMAN\",\n                \"creDtTm\": \"2025-05-01T05:41:55.944Z\",\n                \"prsptvs\": [\n                    {\n                        \"prsptv\": \"governed_as_creditor_account_by\",\n                        \"evtTp\": [\n                            \"pain.001.001.11\",\n                            \"pain.013.001.09\",\n                            \"pacs.008.001.10\",\n                            \"pacs.002.001.12\"\n                        ],\n                        \"incptnDtTm\": \"2025-05-01T05:41:55.944Z\"\n                    },\n                    {\n                        \"prsptv\": \"governed_as_debtor_account_by\",\n                        \"evtTp\": [\n                            \"pain.001.001.11\",\n                            \"pain.013.001.09\",\n                            \"pacs.008.001.10\",\n                            \"pacs.002.001.12\"\n                        ],\n                        \"incptnDtTm\": \"2025-05-01T05:41:55.944Z\"\n                    }\n                ]\n            },\n            {\n                \"condId\": \"a6761801-7f53-4ad2-9249-21a47b08e937\",\n                \"condTp\": \"override\",\n                \"incptnDtTm\": \"2025-05-01T05:42:00.507Z\",\n                \"xprtnDtTm\": \"2025-05-02T05:42:00.840Z\",\n                \"condRsn\": \"Default Test Condition\",\n                \"usr\": \"POSTMAN\",\n                \"creDtTm\": \"2025-05-01T05:42:00.507Z\",\n                \"prsptvs\": [\n                    {\n                        \"prsptv\": \"governed_as_creditor_account_by\",\n                        \"evtTp\": [\n                            \"pain.001.001.11\",\n                            \"pain.013.001.09\",\n                            \"pacs.008.001.10\",\n                            \"pacs.002.001.12\"\n                        ],\n                        \"incptnDtTm\": \"2025-05-01T05:42:00.507Z\",\n                        \"xprtnDtTm\": \"2025-05-02T05:42:00.840Z\"\n                    },\n                    {\n                        \"prsptv\": \"governed_as_debtor_account_by\",\n                        \"evtTp\": [\n                            \"pain.001.001.11\",\n                            \"pain.013.001.09\",\n                            \"pacs.008.001.10\",\n                            \"pacs.002.001.12\"\n                        ],\n                        \"incptnDtTm\": \"2025-05-01T05:42:00.507Z\",\n                        \"xprtnDtTm\": \"2025-05-02T05:42:00.840Z\"\n                    }\n                ]\n            }\n        ],\n        \"acct\": {\n            \"id\": \"dbtrAcct_a524004bc6204c279fccabd3380881e8\",\n            \"schmeNm\": {\n                \"prtry\": \"MSISDN\"\n            },\n            \"agt\": {\n                \"finInstnId\": {\n                    \"clrSysMmbId\": {\n                        \"mmbId\": \"fsp001\"\n                    }\n                }\n            }\n        }\n    }\n}"
								}
							]
						},
						{
							"name": "Fetch Account Conditions - Existing debtor account - default scope",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"let conditionResult = responseJSON.conditions;\r",
											"pm.globals.set(\"conditions\", undefined); // obliterate current stashed conditions\r",
											"pm.globals.set(\"conditions\", JSON.stringify(conditionResult)); // stash response for future retrieval\r",
											"let conditionAccount = responseJSON.acct;\r",
											"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
											"let tenantId = pm.globals.get(\"tenantId\");\r",
											"let acctId = pm.globals.get(\"dbtrAcctId\");\r",
											"let acctIdSchme = pm.globals.get(\"dbtrAcctIdSchmeNm\");\r",
											"let acctAgt = pm.globals.get(\"dbtrAgt\");\r",
											"let targetAccountId = acctId + acctIdSchme + acctAgt;\r",
											"\r",
											"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
											"\r",
											"pm.test(\"Status code is 200\", function () {\r",
											"    pm.response.to.have.status(200);\r",
											"});\r",
											"\r",
											"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
											"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
											"});\r",
											"\r",
											"pm.test(\"Result conditions array contains two conditions\", function () {\r",
											"    pm.expect(conditionResult.length).to.be.eql(2);\r",
											"});\r",
											"\r",
											"// We want to test that the data in the database matches the response data\r",
											"\r",
											"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetAccountId, false);\r",
											"\r",
											"await pm.sendRequest(postRequest, (error, response) => {\r",
											"    if (utils.getLogLevel() === 'DEBUG') {\r",
											"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
											"    }\r",
											"    databaseConditionResult = response.json().data;\r",
											"\r",
											"    if (utils.getLogLevel() === 'DEBUG') {\r",
											"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
											"    }\r",
											"\r",
											"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
											"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
											"\r",
											"    // Check the previous conditions in the response one-by-one against the database version\r",
											"    let previousConditionsFromResponse = graphConditionList;\r",
											"    let previousResponseConditionIds = previousConditionsFromResponse.map(({ condId }) => condId);\r",
											"    let previousConditionsFromDatabase = graphConditionList;\r",
											"    let previousDatabaseConditionIds = previousConditionsFromDatabase.map(({ condId }) => condId);\r",
											"\r",
											"    pm.test(`List of previous conditions in response match list of conditions from database`, function () {\r",
											"        pm.expect(previousResponseConditionIds).to.have.members(previousDatabaseConditionIds);\r",
											"    });\r",
											"\r",
											"    pm.test(`Two conditions for account [${targetAccountId}] exist in the reponse`, function () {\r",
											"        pm.expect(previousConditionsFromResponse.length).to.eql(2);\r",
											"    });\r",
											"\r",
											"    pm.test(`Two conditions for account [${targetAccountId}] exist in the database`, function () {\r",
											"        pm.expect(previousConditionsFromDatabase.length).to.eql(2);\r",
											"    });\r",
											"\r",
											"    for (let j = 0; j < previousConditionsFromResponse.length; j++) {\r",
											"\r",
											"        let justOneConditionFromResponse = previousConditionsFromResponse.filter(condition => condition._id === `conditions/${conditionResult[j].condId}`);\r",
											"        let sameConditionFromDatabase = previousConditionsFromDatabase.filter(condition => condition._id === `conditions/${conditionResult[j].condId}`);\r",
											"\r",
											"        for (let i = 0; i < sameConditionFromDatabase[0].evtTp.length; i++) {\r",
											"            pm.test(`Database condition.evtTp contains ${sameConditionFromDatabase[0].evtTp[i]}`, function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].evtTp).to.include.members([sameConditionFromDatabase[0].evtTp[i]]);\r",
											"            });\r",
											"        }\r",
											"\r",
											"        pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].condTp).to.be.eql(sameConditionFromDatabase[0].condTp);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].prsptv).to.be.eql(sameConditionFromDatabase[0].prsptv);\r",
											"        });\r",
											"\r",
											"        if (sameConditionFromDatabase[0].incptnDtTm) { // was an inception date specified?\r",
											"            pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].incptnDtTm).to.be.eql(sameConditionFromDatabase[0].incptnDtTm);\r",
											"            });\r",
											"        } else {    // if not, one must have been defaulted\r",
											"            pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].incptnDtTm).to.exist.and.not.be.empty;\r",
											"            });\r",
											"        }\r",
											"\r",
											"        if (sameConditionFromDatabase[0].xprtnDtTm) { // was an expiration date specified?\r",
											"            pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].xprtnDtTm).to.be.eql(sameConditionFromDatabase[0].xprtnDtTm);\r",
											"            });\r",
											"        } else {    // if not, one must not have been defaulted\r",
											"            pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].xprtnDtTm).to.not.exist;\r",
											"            });\r",
											"        }\r",
											"\r",
											"        pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].condRsn).to.be.eql(sameConditionFromDatabase[0].condRsn);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.acct.id matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].acct.id).to.be.eql(sameConditionFromDatabase[0].acct.id);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.acct.schmeNm.prtry matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].acct.schmeNm.prtry).to.be.eql(sameConditionFromDatabase[0].acct.schmeNm.prtry);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.acct.agt.finInstnId.clrSysMmbId.mmbId matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].acct.agt.finInstnId.clrSysMmbId.mmbId).to.be.eql(sameConditionFromDatabase[0].acct.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].forceCret).to.be.eql(sameConditionFromDatabase[0].forceCret);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].usr).to.be.eql(sameConditionFromDatabase[0].usr);\r",
											"        });\r",
											"\r",
											"        let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, justOneConditionFromResponse[0]._key);\r",
											"\r",
											"        pm.test(`Database \"governed_as_debtor_account_by\" edge exists`, function () {\r",
											"            pm.expect(edgeList).to.include.members([\"governed_as_debtor_account_by\"]);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database 'governed_as_creditor_account_by' edge exists\", function () {\r",
											"            pm.expect(edgeList).to.include.members([\"governed_as_creditor_account_by\"]);\r",
											"        });\r",
											"\r",
											"        pm.test(`Database \"governed_as_debtor_by\" edge does not exist`, function () {\r",
											"            pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_by\"]);\r",
											"        });\r",
											"\r",
											"        pm.test(`Database \"governed_as_creditor_by\" edge does not exist`, function () {\r",
											"            pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_by\"]);\r",
											"        });\r",
											"    }\r",
											"\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the pacs008 global variable\r",
											"pm.globals.unset(\"dbtrNttyId\");\r",
											"pm.globals.unset(\"dbtrNttyIdSchmeNm\");\r",
											"pm.globals.unset(\"dbtrAcctId\");\r",
											"pm.globals.unset(\"dbtrAcctIdSchmeNm\");\r",
											"pm.globals.unset(\"dbtrAgt\");\r",
											"pm.globals.unset(\"cdtrNttyId\");\r",
											"pm.globals.unset(\"cdtrNttyIdSchmeNm\");\r",
											"pm.globals.unset(\"cdtrAcctId\");\r",
											"pm.globals.unset(\"cdtrAcctIdSchmeNm\");\r",
											"pm.globals.unset(\"cdtrAgt\");\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, JSON.parse(pm.globals.get(\"pacs008\")));\r",
											"\r",
											"// Create identifier variables from the pacs.008 message\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const tenantId = submittedPacs008Message.TenantId;\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"tenantId\", tenantId);\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"pm.globals.set(\"synccache\", \"no\");"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"protocolProfileBehavior": {
								"disableBodyPruning": true
							},
							"request": {
								"method": "GET",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/admin/event-flow-control/account?id={{dbtrAcctId}}&schmenm={{dbtrAcctIdSchmeNm}}&agt={{dbtrAgt}}&synccache={{synccache}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"admin",
										"event-flow-control",
										"account"
									],
									"query": [
										{
											"key": "id",
											"value": "{{dbtrAcctId}}"
										},
										{
											"key": "schmenm",
											"value": "{{dbtrAcctIdSchmeNm}}"
										},
										{
											"key": "agt",
											"value": "{{dbtrAgt}}"
										},
										{
											"key": "synccache",
											"value": "{{synccache}}"
										}
									]
								}
							},
							"response": [
								{
									"name": "Fetch Account Conditions - Existing debtor account",
									"originalRequest": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/admin/event-flow-control/account?id={{dbtrAcctId}}&schmenm={{dbtrAcctIdSchmeNm}}&agt={{dbtrAgt}}&synccache={{synccache}}",
											"host": [
												"{{tazamaAdminUrl}}{{path-admin-api-version}}"
											],
											"path": [
												"admin",
												"event-flow-control",
												"account"
											],
											"query": [
												{
													"key": "id",
													"value": "{{dbtrAcctId}}"
												},
												{
													"key": "schmenm",
													"value": "{{dbtrAcctIdSchmeNm}}"
												},
												{
													"key": "agt",
													"value": "{{dbtrAgt}}"
												},
												{
													"key": "synccache",
													"value": "{{synccache}}"
												}
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "json",
									"header": [
										{
											"key": "access-control-allow-origin",
											"value": "*"
										},
										{
											"key": "content-type",
											"value": "application/json; charset=utf-8"
										},
										{
											"key": "content-length",
											"value": "1373"
										},
										{
											"key": "Date",
											"value": "Thu, 01 May 2025 05:42:24 GMT"
										},
										{
											"key": "Connection",
											"value": "keep-alive"
										},
										{
											"key": "Keep-Alive",
											"value": "timeout=72"
										}
									],
									"cookie": [],
									"body": "{\n    \"conditions\": [\n        {\n            \"condId\": \"cb83a030-f77b-422b-ac0f-cfa327c24fd2\",\n            \"condTp\": \"non-overridable-block\",\n            \"incptnDtTm\": \"2025-05-01T05:41:55.944Z\",\n            \"condRsn\": \"Default Test Condition\",\n            \"usr\": \"POSTMAN\",\n            \"creDtTm\": \"2025-05-01T05:41:55.944Z\",\n            \"prsptvs\": [\n                {\n                    \"prsptv\": \"governed_as_creditor_account_by\",\n                    \"evtTp\": [\n                        \"pain.001.001.11\",\n                        \"pain.013.001.09\",\n                        \"pacs.008.001.10\",\n                        \"pacs.002.001.12\"\n                    ],\n                    \"incptnDtTm\": \"2025-05-01T05:41:55.944Z\"\n                },\n                {\n                    \"prsptv\": \"governed_as_debtor_account_by\",\n                    \"evtTp\": [\n                        \"pain.001.001.11\",\n                        \"pain.013.001.09\",\n                        \"pacs.008.001.10\",\n                        \"pacs.002.001.12\"\n                    ],\n                    \"incptnDtTm\": \"2025-05-01T05:41:55.944Z\"\n                }\n            ]\n        },\n        {\n            \"condId\": \"a6761801-7f53-4ad2-9249-21a47b08e937\",\n            \"condTp\": \"override\",\n            \"incptnDtTm\": \"2025-05-01T05:42:00.507Z\",\n            \"xprtnDtTm\": \"2025-05-02T05:42:00.840Z\",\n            \"condRsn\": \"Default Test Condition\",\n            \"usr\": \"POSTMAN\",\n            \"creDtTm\": \"2025-05-01T05:42:00.507Z\",\n            \"prsptvs\": [\n                {\n                    \"prsptv\": \"governed_as_creditor_account_by\",\n                    \"evtTp\": [\n                        \"pain.001.001.11\",\n                        \"pain.013.001.09\",\n                        \"pacs.008.001.10\",\n                        \"pacs.002.001.12\"\n                    ],\n                    \"incptnDtTm\": \"2025-05-01T05:42:00.507Z\",\n                    \"xprtnDtTm\": \"2025-05-02T05:42:00.840Z\"\n                },\n                {\n                    \"prsptv\": \"governed_as_debtor_account_by\",\n                    \"evtTp\": [\n                        \"pain.001.001.11\",\n                        \"pain.013.001.09\",\n                        \"pacs.008.001.10\",\n                        \"pacs.002.001.12\"\n                    ],\n                    \"incptnDtTm\": \"2025-05-01T05:42:00.507Z\",\n                    \"xprtnDtTm\": \"2025-05-02T05:42:00.840Z\"\n                }\n            ]\n        }\n    ],\n    \"acct\": {\n        \"id\": \"dbtrAcct_a524004bc6204c279fccabd3380881e8\",\n        \"schmeNm\": {\n            \"prtry\": \"MSISDN\"\n        },\n        \"agt\": {\n            \"finInstnId\": {\n                \"clrSysMmbId\": {\n                    \"mmbId\": \"fsp001\"\n                }\n            }\n        }\n    }\n}"
								}
							]
						},
						{
							"name": "Fetch Account Conditions - Existing debtor account - activeonly scope",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"let conditionResult = responseJSON.conditions;\r",
											"pm.globals.set(\"conditions\", undefined); // obliterate current stashed conditions\r",
											"pm.globals.set(\"conditions\", JSON.stringify(conditionResult)); // stash response for future retrieval\r",
											"let conditionAccount = responseJSON.acct;\r",
											"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
											"let tenantId = pm.globals.get(\"tenantId\");\r",
											"let acctId = pm.globals.get(\"dbtrAcctId\");\r",
											"let acctIdSchme = pm.globals.get(\"dbtrAcctIdSchmeNm\");\r",
											"let acctAgt = pm.globals.get(\"dbtrAgt\");\r",
											"let targetAccountId = acctId + acctIdSchme + acctAgt;\r",
											"\r",
											"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
											"\r",
											"pm.test(\"Status code is 200\", function () {\r",
											"    pm.response.to.have.status(200);\r",
											"});\r",
											"\r",
											"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
											"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
											"});\r",
											"\r",
											"pm.test(\"Result conditions array contains two conditions\", function () {\r",
											"    pm.expect(conditionResult.length).to.be.eql(2);\r",
											"});\r",
											"\r",
											"// We want to test that the data in the database matches the response data\r",
											"\r",
											"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetAccountId, false);\r",
											"\r",
											"await pm.sendRequest(postRequest, (error, response) => {\r",
											"    if (utils.getLogLevel() === 'DEBUG') {\r",
											"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
											"    }\r",
											"    databaseConditionResult = response.json().data;\r",
											"\r",
											"    if (utils.getLogLevel() === 'DEBUG') {\r",
											"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
											"    }\r",
											"\r",
											"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
											"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
											"\r",
											"    // Check the previous conditions in the response one-by-one against the database version\r",
											"    let previousConditionsFromResponse = graphConditionList;\r",
											"    let previousResponseConditionIds = previousConditionsFromResponse.map(({ condId }) => condId);\r",
											"    let previousConditionsFromDatabase = graphConditionList;\r",
											"    let previousDatabaseConditionIds = previousConditionsFromDatabase.map(({ condId }) => condId);\r",
											"\r",
											"    pm.test(`List of previous conditions in response match list of conditions from database`, function () {\r",
											"        pm.expect(previousResponseConditionIds).to.have.members(previousDatabaseConditionIds);\r",
											"    });\r",
											"\r",
											"    pm.test(`Two conditions for account [${targetAccountId}] exist in the reponse`, function () {\r",
											"        pm.expect(previousConditionsFromResponse.length).to.eql(2);\r",
											"    });\r",
											"\r",
											"    pm.test(`Two conditions for account [${targetAccountId}] exist in the database`, function () {\r",
											"        pm.expect(previousConditionsFromDatabase.length).to.eql(2);\r",
											"    });\r",
											"\r",
											"    for (let j = 0; j < previousConditionsFromResponse.length; j++) {\r",
											"\r",
											"        let justOneConditionFromResponse = previousConditionsFromResponse.filter(condition => condition._id === `conditions/${conditionResult[j].condId}`);\r",
											"        let sameConditionFromDatabase = previousConditionsFromDatabase.filter(condition => condition._id === `conditions/${conditionResult[j].condId}`);\r",
											"\r",
											"        console.log(previousConditionsFromResponse);\r",
											"        for (let i = 0; i < sameConditionFromDatabase[0].evtTp.length; i++) {\r",
											"            pm.test(`Database condition.evtTp contains ${sameConditionFromDatabase[0].evtTp[i]}`, function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].evtTp).to.include.members([sameConditionFromDatabase[0].evtTp[i]]);\r",
											"            });\r",
											"        }\r",
											"\r",
											"        pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].condTp).to.be.eql(sameConditionFromDatabase[0].condTp);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].prsptv).to.be.eql(sameConditionFromDatabase[0].prsptv);\r",
											"        });\r",
											"\r",
											"        if (sameConditionFromDatabase[0].incptnDtTm) { // was an inception date specified?\r",
											"            pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].incptnDtTm).to.be.eql(sameConditionFromDatabase[0].incptnDtTm);\r",
											"            });\r",
											"        } else {    // if not, one must have been defaulted\r",
											"            pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].incptnDtTm).to.exist.and.not.be.empty;\r",
											"            });\r",
											"        }\r",
											"\r",
											"        if (sameConditionFromDatabase[0].xprtnDtTm) { // was an expiration date specified?\r",
											"            pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].xprtnDtTm).to.be.eql(sameConditionFromDatabase[0].xprtnDtTm);\r",
											"            });\r",
											"        } else {    // if not, one must not have been defaulted\r",
											"            pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].xprtnDtTm).to.not.exist;\r",
											"            });\r",
											"        }\r",
											"\r",
											"        pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].condRsn).to.be.eql(sameConditionFromDatabase[0].condRsn);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.acct.id matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].acct.id).to.be.eql(sameConditionFromDatabase[0].acct.id);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.acct.schmeNm.prtry matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].acct.schmeNm.prtry).to.be.eql(sameConditionFromDatabase[0].acct.schmeNm.prtry);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.acct.agt.finInstnId.clrSysMmbId.mmbId matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].acct.agt.finInstnId.clrSysMmbId.mmbId).to.be.eql(sameConditionFromDatabase[0].acct.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].forceCret).to.be.eql(sameConditionFromDatabase[0].forceCret);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].usr).to.be.eql(sameConditionFromDatabase[0].usr);\r",
											"        });\r",
											"\r",
											"        let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, justOneConditionFromResponse[0]._key);\r",
											"\r",
											"        pm.test(`Database \"governed_as_debtor_account_by\" edge exists`, function () {\r",
											"            pm.expect(edgeList).to.include.members([\"governed_as_debtor_account_by\"]);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database 'governed_as_creditor_account_by' edge exists\", function () {\r",
											"            pm.expect(edgeList).to.include.members([\"governed_as_creditor_account_by\"]);\r",
											"        });\r",
											"\r",
											"        pm.test(`Database \"governed_as_debtor_by\" edge does not exist`, function () {\r",
											"            pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_by\"]);\r",
											"        });\r",
											"\r",
											"        pm.test(`Database \"governed_as_creditor_by\" edge does not exist`, function () {\r",
											"            pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_by\"]);\r",
											"        });\r",
											"    }\r",
											"\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the pacs008 global variable\r",
											"pm.globals.unset(\"dbtrNttyId\");\r",
											"pm.globals.unset(\"dbtrNttyIdSchmeNm\");\r",
											"pm.globals.unset(\"dbtrAcctId\");\r",
											"pm.globals.unset(\"dbtrAcctIdSchmeNm\");\r",
											"pm.globals.unset(\"dbtrAgt\");\r",
											"pm.globals.unset(\"cdtrNttyId\");\r",
											"pm.globals.unset(\"cdtrNttyIdSchmeNm\");\r",
											"pm.globals.unset(\"cdtrAcctId\");\r",
											"pm.globals.unset(\"cdtrAcctIdSchmeNm\");\r",
											"pm.globals.unset(\"cdtrAgt\");\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, JSON.parse(pm.globals.get(\"pacs008\")));\r",
											"\r",
											"// Create identifier variables from the pacs.008 message\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const tenantId = submittedPacs008Message.TenantId;\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"tenantId\", tenantId);\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"pm.globals.set(\"synccache\", \"no\");"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"protocolProfileBehavior": {
								"disableBodyPruning": true
							},
							"request": {
								"method": "GET",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/admin/event-flow-control/account?id={{dbtrAcctId}}&schmenm={{dbtrAcctIdSchmeNm}}&agt={{dbtrAgt}}&synccache={{synccache}}&activeonly=yes",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"admin",
										"event-flow-control",
										"account"
									],
									"query": [
										{
											"key": "id",
											"value": "{{dbtrAcctId}}"
										},
										{
											"key": "schmenm",
											"value": "{{dbtrAcctIdSchmeNm}}"
										},
										{
											"key": "agt",
											"value": "{{dbtrAgt}}"
										},
										{
											"key": "synccache",
											"value": "{{synccache}}"
										},
										{
											"key": "activeonly",
											"value": "yes"
										}
									]
								}
							},
							"response": [
								{
									"name": "Fetch Account Conditions - Existing debtor account",
									"originalRequest": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/admin/event-flow-control/account?id={{dbtrAcctId}}&schmenm={{dbtrAcctIdSchmeNm}}&agt={{dbtrAgt}}&synccache={{synccache}}",
											"host": [
												"{{tazamaAdminUrl}}{{path-admin-api-version}}"
											],
											"path": [
												"admin",
												"event-flow-control",
												"account"
											],
											"query": [
												{
													"key": "id",
													"value": "{{dbtrAcctId}}"
												},
												{
													"key": "schmenm",
													"value": "{{dbtrAcctIdSchmeNm}}"
												},
												{
													"key": "agt",
													"value": "{{dbtrAgt}}"
												},
												{
													"key": "synccache",
													"value": "{{synccache}}"
												}
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "json",
									"header": [
										{
											"key": "access-control-allow-origin",
											"value": "*"
										},
										{
											"key": "content-type",
											"value": "application/json; charset=utf-8"
										},
										{
											"key": "content-length",
											"value": "1373"
										},
										{
											"key": "Date",
											"value": "Thu, 01 May 2025 05:42:24 GMT"
										},
										{
											"key": "Connection",
											"value": "keep-alive"
										},
										{
											"key": "Keep-Alive",
											"value": "timeout=72"
										}
									],
									"cookie": [],
									"body": "{\n    \"conditions\": [\n        {\n            \"condId\": \"cb83a030-f77b-422b-ac0f-cfa327c24fd2\",\n            \"condTp\": \"non-overridable-block\",\n            \"incptnDtTm\": \"2025-05-01T05:41:55.944Z\",\n            \"condRsn\": \"Default Test Condition\",\n            \"usr\": \"POSTMAN\",\n            \"creDtTm\": \"2025-05-01T05:41:55.944Z\",\n            \"prsptvs\": [\n                {\n                    \"prsptv\": \"governed_as_creditor_account_by\",\n                    \"evtTp\": [\n                        \"pain.001.001.11\",\n                        \"pain.013.001.09\",\n                        \"pacs.008.001.10\",\n                        \"pacs.002.001.12\"\n                    ],\n                    \"incptnDtTm\": \"2025-05-01T05:41:55.944Z\"\n                },\n                {\n                    \"prsptv\": \"governed_as_debtor_account_by\",\n                    \"evtTp\": [\n                        \"pain.001.001.11\",\n                        \"pain.013.001.09\",\n                        \"pacs.008.001.10\",\n                        \"pacs.002.001.12\"\n                    ],\n                    \"incptnDtTm\": \"2025-05-01T05:41:55.944Z\"\n                }\n            ]\n        },\n        {\n            \"condId\": \"a6761801-7f53-4ad2-9249-21a47b08e937\",\n            \"condTp\": \"override\",\n            \"incptnDtTm\": \"2025-05-01T05:42:00.507Z\",\n            \"xprtnDtTm\": \"2025-05-02T05:42:00.840Z\",\n            \"condRsn\": \"Default Test Condition\",\n            \"usr\": \"POSTMAN\",\n            \"creDtTm\": \"2025-05-01T05:42:00.507Z\",\n            \"prsptvs\": [\n                {\n                    \"prsptv\": \"governed_as_creditor_account_by\",\n                    \"evtTp\": [\n                        \"pain.001.001.11\",\n                        \"pain.013.001.09\",\n                        \"pacs.008.001.10\",\n                        \"pacs.002.001.12\"\n                    ],\n                    \"incptnDtTm\": \"2025-05-01T05:42:00.507Z\",\n                    \"xprtnDtTm\": \"2025-05-02T05:42:00.840Z\"\n                },\n                {\n                    \"prsptv\": \"governed_as_debtor_account_by\",\n                    \"evtTp\": [\n                        \"pain.001.001.11\",\n                        \"pain.013.001.09\",\n                        \"pacs.008.001.10\",\n                        \"pacs.002.001.12\"\n                    ],\n                    \"incptnDtTm\": \"2025-05-01T05:42:00.507Z\",\n                    \"xprtnDtTm\": \"2025-05-02T05:42:00.840Z\"\n                }\n            ]\n        }\n    ],\n    \"acct\": {\n        \"id\": \"dbtrAcct_a524004bc6204c279fccabd3380881e8\",\n        \"schmeNm\": {\n            \"prtry\": \"MSISDN\"\n        },\n        \"agt\": {\n            \"finInstnId\": {\n                \"clrSysMmbId\": {\n                    \"mmbId\": \"fsp001\"\n                }\n            }\n        }\n    }\n}"
								}
							]
						},
						{
							"name": "Fetch Account Conditions - Existing debtor account - all scope",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"let conditionResult = responseJSON.conditions;\r",
											"pm.globals.set(\"conditions\", undefined); // obliterate current stashed conditions\r",
											"pm.globals.set(\"conditions\", JSON.stringify(conditionResult)); // stash response for future retrieval\r",
											"let conditionAccount = responseJSON.acct;\r",
											"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
											"let tenantId = pm.globals.get(\"tenantId\");\r",
											"let acctId = pm.globals.get(\"dbtrAcctId\");\r",
											"let acctIdSchme = pm.globals.get(\"dbtrAcctIdSchmeNm\");\r",
											"let acctAgt = pm.globals.get(\"dbtrAgt\");\r",
											"let targetAccountId = acctId + acctIdSchme + acctAgt;\r",
											"\r",
											"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
											"\r",
											"pm.test(\"Status code is 200\", function () {\r",
											"    pm.response.to.have.status(200);\r",
											"});\r",
											"\r",
											"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
											"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
											"});\r",
											"\r",
											"pm.test(\"Result conditions array contains two conditions\", function () {\r",
											"    pm.expect(conditionResult.length).to.be.eql(2);\r",
											"});\r",
											"\r",
											"// We want to test that the data in the database matches the response data\r",
											"\r",
											"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetAccountId, false);\r",
											"\r",
											"await pm.sendRequest(postRequest, (error, response) => {\r",
											"    if (utils.getLogLevel() === 'DEBUG') {\r",
											"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
											"    }\r",
											"    databaseConditionResult = response.json().data;\r",
											"\r",
											"    if (utils.getLogLevel() === 'DEBUG') {\r",
											"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
											"    }\r",
											"\r",
											"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
											"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
											"\r",
											"    // Check the previous conditions in the response one-by-one against the database version\r",
											"    let previousConditionsFromResponse = graphConditionList;\r",
											"    let previousResponseConditionIds = previousConditionsFromResponse.map(({ condId }) => condId);\r",
											"    let previousConditionsFromDatabase = graphConditionList;\r",
											"    let previousDatabaseConditionIds = previousConditionsFromDatabase.map(({ condId }) => condId);\r",
											"\r",
											"    pm.test(`List of previous conditions in response match list of conditions from database`, function () {\r",
											"        pm.expect(previousResponseConditionIds).to.have.members(previousDatabaseConditionIds);\r",
											"    });\r",
											"\r",
											"    pm.test(`Only one previous condition for account [${targetAccountId}] exists in the reponse`, function () {\r",
											"        pm.expect(previousConditionsFromResponse.length).to.eql(2);\r",
											"    });\r",
											"\r",
											"    pm.test(`Only one previous condition for account [${targetAccountId}] exists in the database`, function () {\r",
											"        pm.expect(previousConditionsFromDatabase.length).to.eql(2);\r",
											"    });\r",
											"\r",
											"    for (let j = 0; j < previousConditionsFromResponse.length; j++) {\r",
											"\r",
											"        let justOneConditionFromResponse = previousConditionsFromResponse.filter(condition => condition._id === `conditions/${conditionResult[j].condId}`);\r",
											"        let sameConditionFromDatabase = previousConditionsFromDatabase.filter(condition => condition._id === `conditions/${conditionResult[j].condId}`);\r",
											"\r",
											"        for (let i = 0; i < sameConditionFromDatabase[0].evtTp.length; i++) {\r",
											"            pm.test(`Database condition.evtTp contains ${sameConditionFromDatabase[0].evtTp[i]}`, function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].evtTp).to.include.members([sameConditionFromDatabase[0].evtTp[i]]);\r",
											"            });\r",
											"        }\r",
											"\r",
											"        pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].condTp).to.be.eql(sameConditionFromDatabase[0].condTp);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].prsptv).to.be.eql(sameConditionFromDatabase[0].prsptv);\r",
											"        });\r",
											"\r",
											"        if (sameConditionFromDatabase[0].incptnDtTm) { // was an inception date specified?\r",
											"            pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].incptnDtTm).to.be.eql(sameConditionFromDatabase[0].incptnDtTm);\r",
											"            });\r",
											"        } else {    // if not, one must have been defaulted\r",
											"            pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].incptnDtTm).to.exist.and.not.be.empty;\r",
											"            });\r",
											"        }\r",
											"\r",
											"        if (sameConditionFromDatabase[0].xprtnDtTm) { // was an expiration date specified?\r",
											"            pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].xprtnDtTm).to.be.eql(sameConditionFromDatabase[0].xprtnDtTm);\r",
											"            });\r",
											"        } else {    // if not, one must not have been defaulted\r",
											"            pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].xprtnDtTm).to.not.exist;\r",
											"            });\r",
											"        }\r",
											"\r",
											"        pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].condRsn).to.be.eql(sameConditionFromDatabase[0].condRsn);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.acct.id matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].acct.id).to.be.eql(sameConditionFromDatabase[0].acct.id);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.acct.schmeNm.prtry matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].acct.schmeNm.prtry).to.be.eql(sameConditionFromDatabase[0].acct.schmeNm.prtry);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.acct.agt.finInstnId.clrSysMmbId.mmbId matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].acct.agt.finInstnId.clrSysMmbId.mmbId).to.be.eql(sameConditionFromDatabase[0].acct.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].forceCret).to.be.eql(sameConditionFromDatabase[0].forceCret);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].usr).to.be.eql(sameConditionFromDatabase[0].usr);\r",
											"        });\r",
											"\r",
											"        let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, justOneConditionFromResponse[0]._key);\r",
											"\r",
											"        pm.test(`Database \"governed_as_debtor_account_by\" edge exists`, function () {\r",
											"            pm.expect(edgeList).to.include.members([\"governed_as_debtor_account_by\"]);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database 'governed_as_creditor_account_by' edge exists\", function () {\r",
											"            pm.expect(edgeList).to.include.members([\"governed_as_creditor_account_by\"]);\r",
											"        });\r",
											"\r",
											"        pm.test(`Database \"governed_as_debtor_by\" edge does not exist`, function () {\r",
											"            pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_by\"]);\r",
											"        });\r",
											"\r",
											"        pm.test(`Database \"governed_as_creditor_by\" edge does not exist`, function () {\r",
											"            pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_by\"]);\r",
											"        });\r",
											"    }\r",
											"\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the pacs008 global variable\r",
											"pm.globals.unset(\"dbtrNttyId\");\r",
											"pm.globals.unset(\"dbtrNttyIdSchmeNm\");\r",
											"pm.globals.unset(\"dbtrAcctId\");\r",
											"pm.globals.unset(\"dbtrAcctIdSchmeNm\");\r",
											"pm.globals.unset(\"dbtrAgt\");\r",
											"pm.globals.unset(\"cdtrNttyId\");\r",
											"pm.globals.unset(\"cdtrNttyIdSchmeNm\");\r",
											"pm.globals.unset(\"cdtrAcctId\");\r",
											"pm.globals.unset(\"cdtrAcctIdSchmeNm\");\r",
											"pm.globals.unset(\"cdtrAgt\");\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, JSON.parse(pm.globals.get(\"pacs008\")));\r",
											"\r",
											"// Create identifier variables from the pacs.008 message\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const tenantId = submittedPacs008Message.TenantId;\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"tenantId\", tenantId);\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"pm.globals.set(\"synccache\", \"no\");"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"protocolProfileBehavior": {
								"disableBodyPruning": true
							},
							"request": {
								"method": "GET",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/admin/event-flow-control/account?id={{dbtrAcctId}}&schmenm={{dbtrAcctIdSchmeNm}}&agt={{dbtrAgt}}&synccache={{synccache}}&activeonly=no",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"admin",
										"event-flow-control",
										"account"
									],
									"query": [
										{
											"key": "id",
											"value": "{{dbtrAcctId}}"
										},
										{
											"key": "schmenm",
											"value": "{{dbtrAcctIdSchmeNm}}"
										},
										{
											"key": "agt",
											"value": "{{dbtrAgt}}"
										},
										{
											"key": "synccache",
											"value": "{{synccache}}"
										},
										{
											"key": "activeonly",
											"value": "no"
										}
									]
								}
							},
							"response": [
								{
									"name": "Fetch Account Conditions - Existing debtor account",
									"originalRequest": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/admin/event-flow-control/account?id={{dbtrAcctId}}&schmenm={{dbtrAcctIdSchmeNm}}&agt={{dbtrAgt}}&synccache={{synccache}}",
											"host": [
												"{{tazamaAdminUrl}}{{path-admin-api-version}}"
											],
											"path": [
												"admin",
												"event-flow-control",
												"account"
											],
											"query": [
												{
													"key": "id",
													"value": "{{dbtrAcctId}}"
												},
												{
													"key": "schmenm",
													"value": "{{dbtrAcctIdSchmeNm}}"
												},
												{
													"key": "agt",
													"value": "{{dbtrAgt}}"
												},
												{
													"key": "synccache",
													"value": "{{synccache}}"
												}
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "json",
									"header": [
										{
											"key": "access-control-allow-origin",
											"value": "*"
										},
										{
											"key": "content-type",
											"value": "application/json; charset=utf-8"
										},
										{
											"key": "content-length",
											"value": "1373"
										},
										{
											"key": "Date",
											"value": "Thu, 01 May 2025 05:42:24 GMT"
										},
										{
											"key": "Connection",
											"value": "keep-alive"
										},
										{
											"key": "Keep-Alive",
											"value": "timeout=72"
										}
									],
									"cookie": [],
									"body": "{\n    \"conditions\": [\n        {\n            \"condId\": \"cb83a030-f77b-422b-ac0f-cfa327c24fd2\",\n            \"condTp\": \"non-overridable-block\",\n            \"incptnDtTm\": \"2025-05-01T05:41:55.944Z\",\n            \"condRsn\": \"Default Test Condition\",\n            \"usr\": \"POSTMAN\",\n            \"creDtTm\": \"2025-05-01T05:41:55.944Z\",\n            \"prsptvs\": [\n                {\n                    \"prsptv\": \"governed_as_creditor_account_by\",\n                    \"evtTp\": [\n                        \"pain.001.001.11\",\n                        \"pain.013.001.09\",\n                        \"pacs.008.001.10\",\n                        \"pacs.002.001.12\"\n                    ],\n                    \"incptnDtTm\": \"2025-05-01T05:41:55.944Z\"\n                },\n                {\n                    \"prsptv\": \"governed_as_debtor_account_by\",\n                    \"evtTp\": [\n                        \"pain.001.001.11\",\n                        \"pain.013.001.09\",\n                        \"pacs.008.001.10\",\n                        \"pacs.002.001.12\"\n                    ],\n                    \"incptnDtTm\": \"2025-05-01T05:41:55.944Z\"\n                }\n            ]\n        },\n        {\n            \"condId\": \"a6761801-7f53-4ad2-9249-21a47b08e937\",\n            \"condTp\": \"override\",\n            \"incptnDtTm\": \"2025-05-01T05:42:00.507Z\",\n            \"xprtnDtTm\": \"2025-05-02T05:42:00.840Z\",\n            \"condRsn\": \"Default Test Condition\",\n            \"usr\": \"POSTMAN\",\n            \"creDtTm\": \"2025-05-01T05:42:00.507Z\",\n            \"prsptvs\": [\n                {\n                    \"prsptv\": \"governed_as_creditor_account_by\",\n                    \"evtTp\": [\n                        \"pain.001.001.11\",\n                        \"pain.013.001.09\",\n                        \"pacs.008.001.10\",\n                        \"pacs.002.001.12\"\n                    ],\n                    \"incptnDtTm\": \"2025-05-01T05:42:00.507Z\",\n                    \"xprtnDtTm\": \"2025-05-02T05:42:00.840Z\"\n                },\n                {\n                    \"prsptv\": \"governed_as_debtor_account_by\",\n                    \"evtTp\": [\n                        \"pain.001.001.11\",\n                        \"pain.013.001.09\",\n                        \"pacs.008.001.10\",\n                        \"pacs.002.001.12\"\n                    ],\n                    \"incptnDtTm\": \"2025-05-01T05:42:00.507Z\",\n                    \"xprtnDtTm\": \"2025-05-02T05:42:00.840Z\"\n                }\n            ]\n        }\n    ],\n    \"acct\": {\n        \"id\": \"dbtrAcct_a524004bc6204c279fccabd3380881e8\",\n        \"schmeNm\": {\n            \"prtry\": \"MSISDN\"\n        },\n        \"agt\": {\n            \"finInstnId\": {\n                \"clrSysMmbId\": {\n                    \"mmbId\": \"fsp001\"\n                }\n            }\n        }\n    }\n}"
								}
							]
						},
						{
							"name": "Update Account Condition - Existing condition",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"let tenantId = pm.globals.get(\"tenantId\");\r",
											"let acctId = pm.globals.get(\"dbtrAcctId\");\r",
											"let acctIdSchme = pm.globals.get(\"dbtrAcctIdSchmeNm\");\r",
											"let acctAgt = pm.globals.get(\"dbtrAgt\");\r",
											"let targetAccountId = acctId + acctIdSchme + acctAgt;\r",
											"let targetConditionId = pm.globals.get(\"condId\");\r",
											"let targetXprtnDtTm = JSON.parse(pm.globals.get(\"messageBody\")).xprtnDtTm;\r",
											"let targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
											"\r",
											"pm.test(\"Status code is 200\", function () {\r",
											"    pm.response.to.have.status(200);\r",
											"});\r",
											"\r",
											"// We want to test that the condition in the database is updated\r",
											"\r",
											"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetAccountId, false);\r",
											"\r",
											"await pm.sendRequest(postRequest, (error, response) => {\r",
											"    if (utils.getLogLevel() === 'DEBUG') {\r",
											"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
											"    }\r",
											"    databaseConditionResult = response.json().data;\r",
											"\r",
											"    if (utils.getLogLevel() === 'DEBUG') {\r",
											"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
											"    }\r",
											"\r",
											"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
											"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
											"\r",
											"    let updatedCondition = graphConditionList.filter(condition => condition._id === `conditions/${targetConditionId}`);\r",
											"    let nonUpdatedConditions = graphConditionList.filter(condition => condition._id != `conditions/${targetConditionId}`);\r",
											"\r",
											"    pm.test(`The xprntDtTm in condId ${targetConditionId} has been updated to ${targetXprtnDtTm}`, function () {\r",
											"        pm.expect(utils.normalizeUTC(updatedCondition[0].xprtnDtTm)).to.eql(targetXprtnDtTm);\r",
											"    });\r",
											"\r",
											"    pm.test(`No other condition xprtnDtTm is updated`, function () {\r",
											"        pm.expect(nonUpdatedConditions.filter(cond => cond.xprtnDtTm === targetXprtnDtTm).length).to.eql(0);\r",
											"    });\r",
											"\r",
											"    let perspectives = utils.getConditionPerspectivesFromGraph(conditionGraph, updatedCondition[0]._key, \"all\");\r",
											"\r",
											"    // Check that the edges are updated\r",
											"    for (let i = 0; i < perspectives.length; i++) {\r",
											"        pm.test(`The xprntDtTm in condId ${targetConditionId} for perspective ${perspectives[i]._id} has been updated to ${targetXprtnDtTm}`, function () {\r",
											"            pm.expect(utils.normalizeUTC(perspectives[i].xprtnDtTm)).to.eql(targetXprtnDtTm);\r",
											"        });\r",
											"    }\r",
											"\r",
											"    // Check that none of the other edges have been updated\r",
											"    for (let i = 0; i < nonUpdatedConditions.length; i++) {\r",
											"\r",
											"        perspectives = utils.getConditionPerspectivesFromGraph(conditionGraph, nonUpdatedConditions[i]._key, \"all\");\r",
											"\r",
											"        // Check that the other edges are not updated\r",
											"        for (let j = 0; j < perspectives.length; j++) {\r",
											"            pm.test(`The xprntDtTm in condId ${nonUpdatedConditions[i]._key} for perspective ${perspectives[j]._id} has not been updated to ${targetXprtnDtTm}`, function () {\r",
											"                pm.expect(perspectives.xprtnDtTm).to.not.eql(targetXprtnDtTm);\r",
											"            });\r",
											"        }\r",
											"    }\r",
											"\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the pacs008 global variable\r",
											"pm.globals.unset(\"dbtrNttyId\");\r",
											"pm.globals.unset(\"dbtrNttyIdSchmeNm\");\r",
											"pm.globals.unset(\"dbtrAcctId\");\r",
											"pm.globals.unset(\"dbtrAcctIdSchmeNm\");\r",
											"pm.globals.unset(\"dbtrAgt\");\r",
											"pm.globals.unset(\"cdtrNttyId\");\r",
											"pm.globals.unset(\"cdtrNttyIdSchmeNm\");\r",
											"pm.globals.unset(\"cdtrAcctId\");\r",
											"pm.globals.unset(\"cdtrAcctIdSchmeNm\");\r",
											"pm.globals.unset(\"cdtrAgt\");\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, JSON.parse(pm.globals.get(\"pacs008\")));\r",
											"// Create identifier variables from the pacs.008 message\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const tenantId = submittedPacs008Message.TenantId;\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"tenantId\", tenantId);\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Fetch stashed conditions\r",
											"const conditions = JSON.parse(pm.globals.get(\"conditions\"));\r",
											"\r",
											"// Select and stash a condition ID\r",
											"pm.globals.set(\"condId\", conditions[0].condId);\r",
											"\r",
											"// Specify the expiration date (yyyy-mm-ddThh:mm:ss.sssZ)\r",
											"var rightNow = new Date();\r",
											"console.log(rightNow);\r",
											"rightNow.setSeconds(rightNow.getSeconds() + 1);\r",
											"// rightNow.setHours(rightNow.getHours() + 1);\r",
											"xprtnDtTm = rightNow.toISOString();\r",
											"const messageBody = { \"xprtnDtTm\": xprtnDtTm }\r",
											"// pm.globals.set(\"xprtnDtTm\", undefined);\r",
											"// pm.globals.set(\"xprtnDtTm\", utils.getTimestampNow());\r",
											"// pm.globals.set(\"xprtnDtTm\", \"2024-09-20T12:00:00.000Z\");\r",
											"\r",
											"pm.globals.set(\"messageBody\", JSON.stringify(messageBody));"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "PUT",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/admin/event-flow-control/account?tenantid={{tenantId}}&id={{dbtrAcctId}}&schmenm={{dbtrAcctIdSchmeNm}}&agt={{dbtrAgt}}&condid={{condId}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"admin",
										"event-flow-control",
										"account"
									],
									"query": [
										{
											"key": "tenantid",
											"value": "{{tenantId}}"
										},
										{
											"key": "id",
											"value": "{{dbtrAcctId}}"
										},
										{
											"key": "schmenm",
											"value": "{{dbtrAcctIdSchmeNm}}"
										},
										{
											"key": "agt",
											"value": "{{dbtrAgt}}"
										},
										{
											"key": "condid",
											"value": "{{condId}}"
										}
									]
								}
							},
							"response": [
								{
									"name": "Update Account Condition - Existing condition",
									"originalRequest": {
										"method": "PUT",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/admin/event-flow-control/account?id={{dbtrAcctId}}&schmenm={{dbtrAcctIdSchmeNm}}&agt={{dbtrAgt}}&condid={{condId}}",
											"host": [
												"{{tazamaAdminUrl}}{{path-admin-api-version}}"
											],
											"path": [
												"admin",
												"event-flow-control",
												"account"
											],
											"query": [
												{
													"key": "id",
													"value": "{{dbtrAcctId}}"
												},
												{
													"key": "schmenm",
													"value": "{{dbtrAcctIdSchmeNm}}"
												},
												{
													"key": "agt",
													"value": "{{dbtrAgt}}"
												},
												{
													"key": "condid",
													"value": "{{condId}}"
												}
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "plain",
									"header": [
										{
											"key": "access-control-allow-origin",
											"value": "*"
										},
										{
											"key": "content-type",
											"value": "text/plain; charset=utf-8"
										},
										{
											"key": "content-length",
											"value": "0"
										},
										{
											"key": "Date",
											"value": "Thu, 01 May 2025 05:42:29 GMT"
										},
										{
											"key": "Connection",
											"value": "keep-alive"
										},
										{
											"key": "Keep-Alive",
											"value": "timeout=72"
										}
									],
									"cookie": [],
									"body": ""
								}
							]
						},
						{
							"name": "Fetch Account Conditions - Existing debtor account - after update - default scope",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"let conditionResult = responseJSON.conditions;\r",
											"pm.globals.set(\"conditions\", undefined); // obliterate current stashed conditions\r",
											"pm.globals.set(\"conditions\", JSON.stringify(conditionResult)); // stash response for future retrieval\r",
											"let conditionAccount = responseJSON.acct;\r",
											"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
											"let tenantId = pm.globals.get(\"tenantId\");\r",
											"let acctId = pm.globals.get(\"dbtrAcctId\");\r",
											"let acctIdSchme = pm.globals.get(\"dbtrAcctIdSchmeNm\");\r",
											"let acctAgt = pm.globals.get(\"dbtrAgt\");\r",
											"let targetAccountId = acctId + acctIdSchme + acctAgt;\r",
											"\r",
											"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
											"\r",
											"pm.test(\"Status code is 200\", function () {\r",
											"    pm.response.to.have.status(200);\r",
											"});\r",
											"\r",
											"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
											"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
											"});\r",
											"\r",
											"pm.test(\"Result conditions array contains two conditions\", function () {\r",
											"    pm.expect(conditionResult.length).to.be.eql(2);\r",
											"});\r",
											"\r",
											"// We want to test that the data in the database matches the response data\r",
											"\r",
											"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetAccountId, false);\r",
											"\r",
											"await pm.sendRequest(postRequest, (error, response) => {\r",
											"    if (utils.getLogLevel() === 'DEBUG') {\r",
											"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
											"    }\r",
											"    databaseConditionResult = response.json().data;\r",
											"\r",
											"    if (utils.getLogLevel() === 'DEBUG') {\r",
											"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
											"    }\r",
											"\r",
											"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
											"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
											"\r",
											"    // Check the previous conditions in the response one-by-one against the database version\r",
											"    let previousConditionsFromResponse = graphConditionList;\r",
											"    let previousResponseConditionIds = previousConditionsFromResponse.map(({ condId }) => condId);\r",
											"    let previousConditionsFromDatabase = graphConditionList;\r",
											"    let previousDatabaseConditionIds = previousConditionsFromDatabase.map(({ condId }) => condId);\r",
											"\r",
											"    pm.test(`List of previous conditions in response match list of conditions from database`, function () {\r",
											"        pm.expect(previousResponseConditionIds).to.have.members(previousDatabaseConditionIds);\r",
											"    });\r",
											"\r",
											"    pm.test(`Two conditions for account [${targetAccountId}] exist in the reponse`, function () {\r",
											"        pm.expect(previousConditionsFromResponse.length).to.eql(2);\r",
											"    });\r",
											"\r",
											"    pm.test(`Two conditions for account [${targetAccountId}] exist in the database`, function () {\r",
											"        pm.expect(previousConditionsFromDatabase.length).to.eql(2);\r",
											"    });\r",
											"\r",
											"    for (let j = 0; j < previousConditionsFromResponse.length; j++) {\r",
											"\r",
											"        let justOneConditionFromResponse = previousConditionsFromResponse.filter(condition => condition._id === `conditions/${conditionResult[j].condId}`);\r",
											"        let sameConditionFromDatabase = previousConditionsFromDatabase.filter(condition => condition._id === `conditions/${conditionResult[j].condId}`);\r",
											"\r",
											"        for (let i = 0; i < sameConditionFromDatabase[0].evtTp.length; i++) {\r",
											"            pm.test(`Database condition.evtTp contains ${sameConditionFromDatabase[0].evtTp[i]}`, function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].evtTp).to.include.members([sameConditionFromDatabase[0].evtTp[i]]);\r",
											"            });\r",
											"        }\r",
											"\r",
											"        pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].condTp).to.be.eql(sameConditionFromDatabase[0].condTp);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].prsptv).to.be.eql(sameConditionFromDatabase[0].prsptv);\r",
											"        });\r",
											"\r",
											"        if (sameConditionFromDatabase[0].incptnDtTm) { // was an inception date specified?\r",
											"            pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].incptnDtTm).to.be.eql(sameConditionFromDatabase[0].incptnDtTm);\r",
											"            });\r",
											"        } else {    // if not, one must have been defaulted\r",
											"            pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].incptnDtTm).to.exist.and.not.be.empty;\r",
											"            });\r",
											"        }\r",
											"\r",
											"        if (sameConditionFromDatabase[0].xprtnDtTm) { // was an expiration date specified?\r",
											"            pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].xprtnDtTm).to.be.eql(sameConditionFromDatabase[0].xprtnDtTm);\r",
											"            });\r",
											"        } else {    // if not, one must not have been defaulted\r",
											"            pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].xprtnDtTm).to.not.exist;\r",
											"            });\r",
											"        }\r",
											"\r",
											"        pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].condRsn).to.be.eql(sameConditionFromDatabase[0].condRsn);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.acct.id matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].acct.id).to.be.eql(sameConditionFromDatabase[0].acct.id);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.acct.schmeNm.prtry matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].acct.schmeNm.prtry).to.be.eql(sameConditionFromDatabase[0].acct.schmeNm.prtry);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.acct.agt.finInstnId.clrSysMmbId.mmbId matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].acct.agt.finInstnId.clrSysMmbId.mmbId).to.be.eql(sameConditionFromDatabase[0].acct.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].forceCret).to.be.eql(sameConditionFromDatabase[0].forceCret);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].usr).to.be.eql(sameConditionFromDatabase[0].usr);\r",
											"        });\r",
											"\r",
											"        let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, justOneConditionFromResponse[0]._key);\r",
											"\r",
											"        pm.test(`Database \"governed_as_debtor_account_by\" edge exists`, function () {\r",
											"            pm.expect(edgeList).to.include.members([\"governed_as_debtor_account_by\"]);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database 'governed_as_creditor_account_by' edge exists\", function () {\r",
											"            pm.expect(edgeList).to.include.members([\"governed_as_creditor_account_by\"]);\r",
											"        });\r",
											"\r",
											"        pm.test(`Database \"governed_as_debtor_by\" edge does not exist`, function () {\r",
											"            pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_by\"]);\r",
											"        });\r",
											"\r",
											"        pm.test(`Database \"governed_as_creditor_by\" edge does not exist`, function () {\r",
											"            pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_by\"]);\r",
											"        });\r",
											"    }\r",
											"\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the pacs008 global variable\r",
											"pm.globals.unset(\"dbtrNttyId\");\r",
											"pm.globals.unset(\"dbtrNttyIdSchmeNm\");\r",
											"pm.globals.unset(\"dbtrAcctId\");\r",
											"pm.globals.unset(\"dbtrAcctIdSchmeNm\");\r",
											"pm.globals.unset(\"dbtrAgt\");\r",
											"pm.globals.unset(\"cdtrNttyId\");\r",
											"pm.globals.unset(\"cdtrNttyIdSchmeNm\");\r",
											"pm.globals.unset(\"cdtrAcctId\");\r",
											"pm.globals.unset(\"cdtrAcctIdSchmeNm\");\r",
											"pm.globals.unset(\"cdtrAgt\");\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, JSON.parse(pm.globals.get(\"pacs008\")));\r",
											"\r",
											"// Create identifier variables from the pacs.008 message\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const tenantId = submittedPacs008Message.TenantId;\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"tenantId\", tenantId);\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"pm.globals.set(\"synccache\", \"no\");"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"protocolProfileBehavior": {
								"disableBodyPruning": true
							},
							"request": {
								"method": "GET",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/admin/event-flow-control/account?id={{dbtrAcctId}}&schmenm={{dbtrAcctIdSchmeNm}}&agt={{dbtrAgt}}&synccache={{synccache}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"admin",
										"event-flow-control",
										"account"
									],
									"query": [
										{
											"key": "id",
											"value": "{{dbtrAcctId}}"
										},
										{
											"key": "schmenm",
											"value": "{{dbtrAcctIdSchmeNm}}"
										},
										{
											"key": "agt",
											"value": "{{dbtrAgt}}"
										},
										{
											"key": "synccache",
											"value": "{{synccache}}"
										}
									]
								}
							},
							"response": [
								{
									"name": "Fetch Account Conditions - Existing debtor account",
									"originalRequest": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/admin/event-flow-control/account?id={{dbtrAcctId}}&schmenm={{dbtrAcctIdSchmeNm}}&agt={{dbtrAgt}}&synccache={{synccache}}",
											"host": [
												"{{tazamaAdminUrl}}{{path-admin-api-version}}"
											],
											"path": [
												"admin",
												"event-flow-control",
												"account"
											],
											"query": [
												{
													"key": "id",
													"value": "{{dbtrAcctId}}"
												},
												{
													"key": "schmenm",
													"value": "{{dbtrAcctIdSchmeNm}}"
												},
												{
													"key": "agt",
													"value": "{{dbtrAgt}}"
												},
												{
													"key": "synccache",
													"value": "{{synccache}}"
												}
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "json",
									"header": [
										{
											"key": "access-control-allow-origin",
											"value": "*"
										},
										{
											"key": "content-type",
											"value": "application/json; charset=utf-8"
										},
										{
											"key": "content-length",
											"value": "1373"
										},
										{
											"key": "Date",
											"value": "Thu, 01 May 2025 05:42:24 GMT"
										},
										{
											"key": "Connection",
											"value": "keep-alive"
										},
										{
											"key": "Keep-Alive",
											"value": "timeout=72"
										}
									],
									"cookie": [],
									"body": "{\n    \"conditions\": [\n        {\n            \"condId\": \"cb83a030-f77b-422b-ac0f-cfa327c24fd2\",\n            \"condTp\": \"non-overridable-block\",\n            \"incptnDtTm\": \"2025-05-01T05:41:55.944Z\",\n            \"condRsn\": \"Default Test Condition\",\n            \"usr\": \"POSTMAN\",\n            \"creDtTm\": \"2025-05-01T05:41:55.944Z\",\n            \"prsptvs\": [\n                {\n                    \"prsptv\": \"governed_as_creditor_account_by\",\n                    \"evtTp\": [\n                        \"pain.001.001.11\",\n                        \"pain.013.001.09\",\n                        \"pacs.008.001.10\",\n                        \"pacs.002.001.12\"\n                    ],\n                    \"incptnDtTm\": \"2025-05-01T05:41:55.944Z\"\n                },\n                {\n                    \"prsptv\": \"governed_as_debtor_account_by\",\n                    \"evtTp\": [\n                        \"pain.001.001.11\",\n                        \"pain.013.001.09\",\n                        \"pacs.008.001.10\",\n                        \"pacs.002.001.12\"\n                    ],\n                    \"incptnDtTm\": \"2025-05-01T05:41:55.944Z\"\n                }\n            ]\n        },\n        {\n            \"condId\": \"a6761801-7f53-4ad2-9249-21a47b08e937\",\n            \"condTp\": \"override\",\n            \"incptnDtTm\": \"2025-05-01T05:42:00.507Z\",\n            \"xprtnDtTm\": \"2025-05-02T05:42:00.840Z\",\n            \"condRsn\": \"Default Test Condition\",\n            \"usr\": \"POSTMAN\",\n            \"creDtTm\": \"2025-05-01T05:42:00.507Z\",\n            \"prsptvs\": [\n                {\n                    \"prsptv\": \"governed_as_creditor_account_by\",\n                    \"evtTp\": [\n                        \"pain.001.001.11\",\n                        \"pain.013.001.09\",\n                        \"pacs.008.001.10\",\n                        \"pacs.002.001.12\"\n                    ],\n                    \"incptnDtTm\": \"2025-05-01T05:42:00.507Z\",\n                    \"xprtnDtTm\": \"2025-05-02T05:42:00.840Z\"\n                },\n                {\n                    \"prsptv\": \"governed_as_debtor_account_by\",\n                    \"evtTp\": [\n                        \"pain.001.001.11\",\n                        \"pain.013.001.09\",\n                        \"pacs.008.001.10\",\n                        \"pacs.002.001.12\"\n                    ],\n                    \"incptnDtTm\": \"2025-05-01T05:42:00.507Z\",\n                    \"xprtnDtTm\": \"2025-05-02T05:42:00.840Z\"\n                }\n            ]\n        }\n    ],\n    \"acct\": {\n        \"id\": \"dbtrAcct_a524004bc6204c279fccabd3380881e8\",\n        \"schmeNm\": {\n            \"prtry\": \"MSISDN\"\n        },\n        \"agt\": {\n            \"finInstnId\": {\n                \"clrSysMmbId\": {\n                    \"mmbId\": \"fsp001\"\n                }\n            }\n        }\n    }\n}"
								}
							]
						},
						{
							"name": "Fetch Account Conditions - Existing debtor account - after update - activeonly scope",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"let conditionResult = responseJSON.conditions;\r",
											"pm.globals.set(\"conditions\", undefined); // obliterate current stashed conditions\r",
											"pm.globals.set(\"conditions\", JSON.stringify(conditionResult)); // stash response for future retrieval\r",
											"let conditionAccount = responseJSON.acct;\r",
											"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
											"let tenantId = pm.globals.get(\"tenantId\");\r",
											"let acctId = pm.globals.get(\"dbtrAcctId\");\r",
											"let acctIdSchme = pm.globals.get(\"dbtrAcctIdSchmeNm\");\r",
											"let acctAgt = pm.globals.get(\"dbtrAgt\");\r",
											"let targetAccountId = acctId + acctIdSchme + acctAgt;\r",
											"\r",
											"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
											"\r",
											"pm.test(\"Status code is 200\", function () {\r",
											"    pm.response.to.have.status(200);\r",
											"});\r",
											"\r",
											"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
											"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
											"});\r",
											"\r",
											"pm.test(\"Result conditions array contains one condition\", function () {\r",
											"    pm.expect(conditionResult.length).to.be.eql(1);\r",
											"});\r",
											"\r",
											"// We want to test that the data in the database matches the response data\r",
											"\r",
											"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetAccountId, true);\r",
											"\r",
											"await pm.sendRequest(postRequest, (error, response) => {\r",
											"    if (utils.getLogLevel() === 'DEBUG') {\r",
											"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
											"    }\r",
											"    databaseConditionResult = response.json().data;\r",
											"\r",
											"    if (utils.getLogLevel() === 'DEBUG') {\r",
											"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
											"    }\r",
											"\r",
											"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
											"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
											"\r",
											"    // Check the previous conditions in the response one-by-one against the database version\r",
											"    let previousConditionsFromResponse = graphConditionList;\r",
											"    let previousResponseConditionIds = previousConditionsFromResponse.map(({ condId }) => condId);\r",
											"    let previousConditionsFromDatabase = graphConditionList;\r",
											"    let previousDatabaseConditionIds = previousConditionsFromDatabase.map(({ condId }) => condId);\r",
											"\r",
											"    pm.test(`List of previous conditions in response match list of conditions from database`, function () {\r",
											"        pm.expect(previousResponseConditionIds).to.have.members(previousDatabaseConditionIds);\r",
											"    });\r",
											"\r",
											"    pm.test(`Only one active condition for account [${targetAccountId}] exists in the reponse`, function () {\r",
											"        pm.expect(previousConditionsFromResponse.length).to.eql(1);\r",
											"    });\r",
											"\r",
											"    pm.test(`Only one active condition for account [${targetAccountId}] exists in the database`, function () {\r",
											"        pm.expect(previousConditionsFromDatabase.length).to.eql(1);\r",
											"    });\r",
											"\r",
											"    for (let j = 0; j < previousConditionsFromResponse.length; j++) {\r",
											"\r",
											"        let justOneConditionFromResponse = previousConditionsFromResponse.filter(condition => condition._id === `conditions/${conditionResult[j].condId}`);\r",
											"        let sameConditionFromDatabase = previousConditionsFromDatabase.filter(condition => condition._id === `conditions/${conditionResult[j].condId}`);\r",
											"\r",
											"        for (let i = 0; i < sameConditionFromDatabase[0].evtTp.length; i++) {\r",
											"            pm.test(`Database condition.evtTp contains ${sameConditionFromDatabase[0].evtTp[i]}`, function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].evtTp).to.include.members([sameConditionFromDatabase[0].evtTp[i]]);\r",
											"            });\r",
											"        }\r",
											"\r",
											"        pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].condTp).to.be.eql(sameConditionFromDatabase[0].condTp);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].prsptv).to.be.eql(sameConditionFromDatabase[0].prsptv);\r",
											"        });\r",
											"\r",
											"        if (sameConditionFromDatabase[0].incptnDtTm) { // was an inception date specified?\r",
											"            pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].incptnDtTm).to.be.eql(sameConditionFromDatabase[0].incptnDtTm);\r",
											"            });\r",
											"        } else {    // if not, one must have been defaulted\r",
											"            pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].incptnDtTm).to.exist.and.not.be.empty;\r",
											"            });\r",
											"        }\r",
											"\r",
											"        if (sameConditionFromDatabase[0].xprtnDtTm) { // was an expiration date specified?\r",
											"            pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].xprtnDtTm).to.be.eql(sameConditionFromDatabase[0].xprtnDtTm);\r",
											"            });\r",
											"        } else {    // if not, one must not have been defaulted\r",
											"            pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].xprtnDtTm).to.not.exist;\r",
											"            });\r",
											"        }\r",
											"\r",
											"        pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].condRsn).to.be.eql(sameConditionFromDatabase[0].condRsn);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.acct.id matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].acct.id).to.be.eql(sameConditionFromDatabase[0].acct.id);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.acct.schmeNm.prtry matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].acct.schmeNm.prtry).to.be.eql(sameConditionFromDatabase[0].acct.schmeNm.prtry);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.acct.agt.finInstnId.clrSysMmbId.mmbId matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].acct.agt.finInstnId.clrSysMmbId.mmbId).to.be.eql(sameConditionFromDatabase[0].acct.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].forceCret).to.be.eql(sameConditionFromDatabase[0].forceCret);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].usr).to.be.eql(sameConditionFromDatabase[0].usr);\r",
											"        });\r",
											"\r",
											"        let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, justOneConditionFromResponse[0]._key);\r",
											"\r",
											"        pm.test(`Database \"governed_as_debtor_account_by\" edge exists`, function () {\r",
											"            pm.expect(edgeList).to.include.members([\"governed_as_debtor_account_by\"]);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database 'governed_as_creditor_account_by' edge exists\", function () {\r",
											"            pm.expect(edgeList).to.include.members([\"governed_as_creditor_account_by\"]);\r",
											"        });\r",
											"\r",
											"        pm.test(`Database \"governed_as_debtor_by\" edge does not exist`, function () {\r",
											"            pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_by\"]);\r",
											"        });\r",
											"\r",
											"        pm.test(`Database \"governed_as_creditor_by\" edge does not exist`, function () {\r",
											"            pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_by\"]);\r",
											"        });\r",
											"    }\r",
											"\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the pacs008 global variable\r",
											"pm.globals.unset(\"dbtrNttyId\");\r",
											"pm.globals.unset(\"dbtrNttyIdSchmeNm\");\r",
											"pm.globals.unset(\"dbtrAcctId\");\r",
											"pm.globals.unset(\"dbtrAcctIdSchmeNm\");\r",
											"pm.globals.unset(\"dbtrAgt\");\r",
											"pm.globals.unset(\"cdtrNttyId\");\r",
											"pm.globals.unset(\"cdtrNttyIdSchmeNm\");\r",
											"pm.globals.unset(\"cdtrAcctId\");\r",
											"pm.globals.unset(\"cdtrAcctIdSchmeNm\");\r",
											"pm.globals.unset(\"cdtrAgt\");\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, JSON.parse(pm.globals.get(\"pacs008\")));\r",
											"\r",
											"// Create identifier variables from the pacs.008 message\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const tenantId = submittedPacs008Message.TenantId;\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"tenantId\", tenantId);\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"pm.globals.set(\"synccache\", \"no\");"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"protocolProfileBehavior": {
								"disableBodyPruning": true
							},
							"request": {
								"method": "GET",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/admin/event-flow-control/account?id={{dbtrAcctId}}&schmenm={{dbtrAcctIdSchmeNm}}&agt={{dbtrAgt}}&synccache={{synccache}}&activeonly=yes",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"admin",
										"event-flow-control",
										"account"
									],
									"query": [
										{
											"key": "id",
											"value": "{{dbtrAcctId}}"
										},
										{
											"key": "schmenm",
											"value": "{{dbtrAcctIdSchmeNm}}"
										},
										{
											"key": "agt",
											"value": "{{dbtrAgt}}"
										},
										{
											"key": "synccache",
											"value": "{{synccache}}"
										},
										{
											"key": "activeonly",
											"value": "yes"
										}
									]
								}
							},
							"response": [
								{
									"name": "Fetch Account Conditions - Existing debtor account",
									"originalRequest": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/admin/event-flow-control/account?id={{dbtrAcctId}}&schmenm={{dbtrAcctIdSchmeNm}}&agt={{dbtrAgt}}&synccache={{synccache}}",
											"host": [
												"{{tazamaAdminUrl}}{{path-admin-api-version}}"
											],
											"path": [
												"admin",
												"event-flow-control",
												"account"
											],
											"query": [
												{
													"key": "id",
													"value": "{{dbtrAcctId}}"
												},
												{
													"key": "schmenm",
													"value": "{{dbtrAcctIdSchmeNm}}"
												},
												{
													"key": "agt",
													"value": "{{dbtrAgt}}"
												},
												{
													"key": "synccache",
													"value": "{{synccache}}"
												}
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "json",
									"header": [
										{
											"key": "access-control-allow-origin",
											"value": "*"
										},
										{
											"key": "content-type",
											"value": "application/json; charset=utf-8"
										},
										{
											"key": "content-length",
											"value": "1373"
										},
										{
											"key": "Date",
											"value": "Thu, 01 May 2025 05:42:24 GMT"
										},
										{
											"key": "Connection",
											"value": "keep-alive"
										},
										{
											"key": "Keep-Alive",
											"value": "timeout=72"
										}
									],
									"cookie": [],
									"body": "{\n    \"conditions\": [\n        {\n            \"condId\": \"cb83a030-f77b-422b-ac0f-cfa327c24fd2\",\n            \"condTp\": \"non-overridable-block\",\n            \"incptnDtTm\": \"2025-05-01T05:41:55.944Z\",\n            \"condRsn\": \"Default Test Condition\",\n            \"usr\": \"POSTMAN\",\n            \"creDtTm\": \"2025-05-01T05:41:55.944Z\",\n            \"prsptvs\": [\n                {\n                    \"prsptv\": \"governed_as_creditor_account_by\",\n                    \"evtTp\": [\n                        \"pain.001.001.11\",\n                        \"pain.013.001.09\",\n                        \"pacs.008.001.10\",\n                        \"pacs.002.001.12\"\n                    ],\n                    \"incptnDtTm\": \"2025-05-01T05:41:55.944Z\"\n                },\n                {\n                    \"prsptv\": \"governed_as_debtor_account_by\",\n                    \"evtTp\": [\n                        \"pain.001.001.11\",\n                        \"pain.013.001.09\",\n                        \"pacs.008.001.10\",\n                        \"pacs.002.001.12\"\n                    ],\n                    \"incptnDtTm\": \"2025-05-01T05:41:55.944Z\"\n                }\n            ]\n        },\n        {\n            \"condId\": \"a6761801-7f53-4ad2-9249-21a47b08e937\",\n            \"condTp\": \"override\",\n            \"incptnDtTm\": \"2025-05-01T05:42:00.507Z\",\n            \"xprtnDtTm\": \"2025-05-02T05:42:00.840Z\",\n            \"condRsn\": \"Default Test Condition\",\n            \"usr\": \"POSTMAN\",\n            \"creDtTm\": \"2025-05-01T05:42:00.507Z\",\n            \"prsptvs\": [\n                {\n                    \"prsptv\": \"governed_as_creditor_account_by\",\n                    \"evtTp\": [\n                        \"pain.001.001.11\",\n                        \"pain.013.001.09\",\n                        \"pacs.008.001.10\",\n                        \"pacs.002.001.12\"\n                    ],\n                    \"incptnDtTm\": \"2025-05-01T05:42:00.507Z\",\n                    \"xprtnDtTm\": \"2025-05-02T05:42:00.840Z\"\n                },\n                {\n                    \"prsptv\": \"governed_as_debtor_account_by\",\n                    \"evtTp\": [\n                        \"pain.001.001.11\",\n                        \"pain.013.001.09\",\n                        \"pacs.008.001.10\",\n                        \"pacs.002.001.12\"\n                    ],\n                    \"incptnDtTm\": \"2025-05-01T05:42:00.507Z\",\n                    \"xprtnDtTm\": \"2025-05-02T05:42:00.840Z\"\n                }\n            ]\n        }\n    ],\n    \"acct\": {\n        \"id\": \"dbtrAcct_a524004bc6204c279fccabd3380881e8\",\n        \"schmeNm\": {\n            \"prtry\": \"MSISDN\"\n        },\n        \"agt\": {\n            \"finInstnId\": {\n                \"clrSysMmbId\": {\n                    \"mmbId\": \"fsp001\"\n                }\n            }\n        }\n    }\n}"
								}
							]
						},
						{
							"name": "Fetch Account Conditions - Existing debtor account - after update - all scope",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"let conditionResult = responseJSON.conditions;\r",
											"pm.globals.set(\"conditions\", undefined); // obliterate current stashed conditions\r",
											"pm.globals.set(\"conditions\", JSON.stringify(conditionResult)); // stash response for future retrieval\r",
											"let conditionAccount = responseJSON.acct;\r",
											"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
											"let tenantId = pm.globals.get(\"tenantId\");\r",
											"let acctId = pm.globals.get(\"dbtrAcctId\");\r",
											"let acctIdSchme = pm.globals.get(\"dbtrAcctIdSchmeNm\");\r",
											"let acctAgt = pm.globals.get(\"dbtrAgt\");\r",
											"let targetAccountId = acctId + acctIdSchme + acctAgt;\r",
											"\r",
											"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
											"\r",
											"pm.test(\"Status code is 200\", function () {\r",
											"    pm.response.to.have.status(200);\r",
											"});\r",
											"\r",
											"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
											"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
											"});\r",
											"\r",
											"pm.test(\"Result conditions array contains two conditions\", function () {\r",
											"    pm.expect(conditionResult.length).to.be.eql(2);\r",
											"});\r",
											"\r",
											"// We want to test that the data in the database matches the response data\r",
											"\r",
											"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetAccountId, false);\r",
											"\r",
											"await pm.sendRequest(postRequest, (error, response) => {\r",
											"    if (utils.getLogLevel() === 'DEBUG') {\r",
											"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
											"    }\r",
											"    databaseConditionResult = response.json().data;\r",
											"\r",
											"    if (utils.getLogLevel() === 'DEBUG') {\r",
											"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
											"    }\r",
											"\r",
											"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
											"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
											"\r",
											"    // Check the previous conditions in the response one-by-one against the database version\r",
											"    let previousConditionsFromResponse = graphConditionList;\r",
											"    let previousResponseConditionIds = previousConditionsFromResponse.map(({ condId }) => condId);\r",
											"    let previousConditionsFromDatabase = graphConditionList;\r",
											"    let previousDatabaseConditionIds = previousConditionsFromDatabase.map(({ condId }) => condId);\r",
											"\r",
											"    pm.test(`List of previous conditions in response match list of conditions from database`, function () {\r",
											"        pm.expect(previousResponseConditionIds).to.have.members(previousDatabaseConditionIds);\r",
											"    });\r",
											"\r",
											"    pm.test(`Two conditions for account [${targetAccountId}] exist in the reponse`, function () {\r",
											"        pm.expect(previousConditionsFromResponse.length).to.eql(2);\r",
											"    });\r",
											"\r",
											"    pm.test(`Two conditions for account [${targetAccountId}] exist in the database`, function () {\r",
											"        pm.expect(previousConditionsFromDatabase.length).to.eql(2);\r",
											"    });\r",
											"\r",
											"    for (let j = 0; j < previousConditionsFromResponse.length; j++) {\r",
											"\r",
											"        let justOneConditionFromResponse = previousConditionsFromResponse.filter(condition => condition._id === `conditions/${conditionResult[j].condId}`);\r",
											"        let sameConditionFromDatabase = previousConditionsFromDatabase.filter(condition => condition._id === `conditions/${conditionResult[j].condId}`);\r",
											"\r",
											"        for (let i = 0; i < sameConditionFromDatabase[0].evtTp.length; i++) {\r",
											"            pm.test(`Database condition.evtTp contains ${sameConditionFromDatabase[0].evtTp[i]}`, function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].evtTp).to.include.members([sameConditionFromDatabase[0].evtTp[i]]);\r",
											"            });\r",
											"        }\r",
											"\r",
											"        pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].condTp).to.be.eql(sameConditionFromDatabase[0].condTp);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].prsptv).to.be.eql(sameConditionFromDatabase[0].prsptv);\r",
											"        });\r",
											"\r",
											"        if (sameConditionFromDatabase[0].incptnDtTm) { // was an inception date specified?\r",
											"            pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].incptnDtTm).to.be.eql(sameConditionFromDatabase[0].incptnDtTm);\r",
											"            });\r",
											"        } else {    // if not, one must have been defaulted\r",
											"            pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].incptnDtTm).to.exist.and.not.be.empty;\r",
											"            });\r",
											"        }\r",
											"\r",
											"        if (sameConditionFromDatabase[0].xprtnDtTm) { // was an expiration date specified?\r",
											"            pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].xprtnDtTm).to.be.eql(sameConditionFromDatabase[0].xprtnDtTm);\r",
											"            });\r",
											"        } else {    // if not, one must not have been defaulted\r",
											"            pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].xprtnDtTm).to.not.exist;\r",
											"            });\r",
											"        }\r",
											"\r",
											"        pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].condRsn).to.be.eql(sameConditionFromDatabase[0].condRsn);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.acct.id matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].acct.id).to.be.eql(sameConditionFromDatabase[0].acct.id);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.acct.schmeNm.prtry matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].acct.schmeNm.prtry).to.be.eql(sameConditionFromDatabase[0].acct.schmeNm.prtry);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.acct.agt.finInstnId.clrSysMmbId.mmbId matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].acct.agt.finInstnId.clrSysMmbId.mmbId).to.be.eql(sameConditionFromDatabase[0].acct.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].forceCret).to.be.eql(sameConditionFromDatabase[0].forceCret);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].usr).to.be.eql(sameConditionFromDatabase[0].usr);\r",
											"        });\r",
											"\r",
											"        let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, justOneConditionFromResponse[0]._key);\r",
											"\r",
											"        pm.test(`Database \"governed_as_debtor_account_by\" edge exists`, function () {\r",
											"            pm.expect(edgeList).to.include.members([\"governed_as_debtor_account_by\"]);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database 'governed_as_creditor_account_by' edge exists\", function () {\r",
											"            pm.expect(edgeList).to.include.members([\"governed_as_creditor_account_by\"]);\r",
											"        });\r",
											"\r",
											"        pm.test(`Database \"governed_as_debtor_by\" edge does not exist`, function () {\r",
											"            pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_by\"]);\r",
											"        });\r",
											"\r",
											"        pm.test(`Database \"governed_as_creditor_by\" edge does not exist`, function () {\r",
											"            pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_by\"]);\r",
											"        });\r",
											"    }\r",
											"\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the pacs008 global variable\r",
											"pm.globals.unset(\"dbtrNttyId\");\r",
											"pm.globals.unset(\"dbtrNttyIdSchmeNm\");\r",
											"pm.globals.unset(\"dbtrAcctId\");\r",
											"pm.globals.unset(\"dbtrAcctIdSchmeNm\");\r",
											"pm.globals.unset(\"dbtrAgt\");\r",
											"pm.globals.unset(\"cdtrNttyId\");\r",
											"pm.globals.unset(\"cdtrNttyIdSchmeNm\");\r",
											"pm.globals.unset(\"cdtrAcctId\");\r",
											"pm.globals.unset(\"cdtrAcctIdSchmeNm\");\r",
											"pm.globals.unset(\"cdtrAgt\");\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, JSON.parse(pm.globals.get(\"pacs008\")));\r",
											"\r",
											"// Create identifier variables from the pacs.008 message\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const tenantId = submittedPacs008Message.TenantId;\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"tenantId\", tenantId);\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"pm.globals.set(\"synccache\", \"no\");"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"protocolProfileBehavior": {
								"disableBodyPruning": true
							},
							"request": {
								"method": "GET",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/admin/event-flow-control/account?id={{dbtrAcctId}}&schmenm={{dbtrAcctIdSchmeNm}}&agt={{dbtrAgt}}&synccache={{synccache}}&activeonly=no",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"admin",
										"event-flow-control",
										"account"
									],
									"query": [
										{
											"key": "id",
											"value": "{{dbtrAcctId}}"
										},
										{
											"key": "schmenm",
											"value": "{{dbtrAcctIdSchmeNm}}"
										},
										{
											"key": "agt",
											"value": "{{dbtrAgt}}"
										},
										{
											"key": "synccache",
											"value": "{{synccache}}"
										},
										{
											"key": "activeonly",
											"value": "no"
										}
									]
								}
							},
							"response": [
								{
									"name": "Fetch Account Conditions - Existing debtor account",
									"originalRequest": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/admin/event-flow-control/account?id={{dbtrAcctId}}&schmenm={{dbtrAcctIdSchmeNm}}&agt={{dbtrAgt}}&synccache={{synccache}}",
											"host": [
												"{{tazamaAdminUrl}}{{path-admin-api-version}}"
											],
											"path": [
												"admin",
												"event-flow-control",
												"account"
											],
											"query": [
												{
													"key": "id",
													"value": "{{dbtrAcctId}}"
												},
												{
													"key": "schmenm",
													"value": "{{dbtrAcctIdSchmeNm}}"
												},
												{
													"key": "agt",
													"value": "{{dbtrAgt}}"
												},
												{
													"key": "synccache",
													"value": "{{synccache}}"
												}
											]
										}
									},
									"status": "OK",
									"code": 200,
									"_postman_previewlanguage": "json",
									"header": [
										{
											"key": "access-control-allow-origin",
											"value": "*"
										},
										{
											"key": "content-type",
											"value": "application/json; charset=utf-8"
										},
										{
											"key": "content-length",
											"value": "1373"
										},
										{
											"key": "Date",
											"value": "Thu, 01 May 2025 05:42:24 GMT"
										},
										{
											"key": "Connection",
											"value": "keep-alive"
										},
										{
											"key": "Keep-Alive",
											"value": "timeout=72"
										}
									],
									"cookie": [],
									"body": "{\n    \"conditions\": [\n        {\n            \"condId\": \"cb83a030-f77b-422b-ac0f-cfa327c24fd2\",\n            \"condTp\": \"non-overridable-block\",\n            \"incptnDtTm\": \"2025-05-01T05:41:55.944Z\",\n            \"condRsn\": \"Default Test Condition\",\n            \"usr\": \"POSTMAN\",\n            \"creDtTm\": \"2025-05-01T05:41:55.944Z\",\n            \"prsptvs\": [\n                {\n                    \"prsptv\": \"governed_as_creditor_account_by\",\n                    \"evtTp\": [\n                        \"pain.001.001.11\",\n                        \"pain.013.001.09\",\n                        \"pacs.008.001.10\",\n                        \"pacs.002.001.12\"\n                    ],\n                    \"incptnDtTm\": \"2025-05-01T05:41:55.944Z\"\n                },\n                {\n                    \"prsptv\": \"governed_as_debtor_account_by\",\n                    \"evtTp\": [\n                        \"pain.001.001.11\",\n                        \"pain.013.001.09\",\n                        \"pacs.008.001.10\",\n                        \"pacs.002.001.12\"\n                    ],\n                    \"incptnDtTm\": \"2025-05-01T05:41:55.944Z\"\n                }\n            ]\n        },\n        {\n            \"condId\": \"a6761801-7f53-4ad2-9249-21a47b08e937\",\n            \"condTp\": \"override\",\n            \"incptnDtTm\": \"2025-05-01T05:42:00.507Z\",\n            \"xprtnDtTm\": \"2025-05-02T05:42:00.840Z\",\n            \"condRsn\": \"Default Test Condition\",\n            \"usr\": \"POSTMAN\",\n            \"creDtTm\": \"2025-05-01T05:42:00.507Z\",\n            \"prsptvs\": [\n                {\n                    \"prsptv\": \"governed_as_creditor_account_by\",\n                    \"evtTp\": [\n                        \"pain.001.001.11\",\n                        \"pain.013.001.09\",\n                        \"pacs.008.001.10\",\n                        \"pacs.002.001.12\"\n                    ],\n                    \"incptnDtTm\": \"2025-05-01T05:42:00.507Z\",\n                    \"xprtnDtTm\": \"2025-05-02T05:42:00.840Z\"\n                },\n                {\n                    \"prsptv\": \"governed_as_debtor_account_by\",\n                    \"evtTp\": [\n                        \"pain.001.001.11\",\n                        \"pain.013.001.09\",\n                        \"pacs.008.001.10\",\n                        \"pacs.002.001.12\"\n                    ],\n                    \"incptnDtTm\": \"2025-05-01T05:42:00.507Z\",\n                    \"xprtnDtTm\": \"2025-05-02T05:42:00.840Z\"\n                }\n            ]\n        }\n    ],\n    \"acct\": {\n        \"id\": \"dbtrAcct_a524004bc6204c279fccabd3380881e8\",\n        \"schmeNm\": {\n            \"prtry\": \"MSISDN\"\n        },\n        \"agt\": {\n            \"finInstnId\": {\n                \"clrSysMmbId\": {\n                    \"mmbId\": \"fsp001\"\n                }\n            }\n        }\n    }\n}"
								}
							]
						}
					]
				}
			]
		},
		{
			"name": "Entity Conditions",
			"item": [
				{
					"name": "Negative testing",
					"item": [
						{
							"name": "Create New Entity Condition Manually - Unknown debtor entity - missing evtTp",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 400,\r",
											"    \"code\": \"FST_ERR_VALIDATION\",\r",
											"    \"error\": \"Bad Request\",\r",
											"    \"message\": \"body must have required property 'evtTp'\"\r",
											"};\r",
											"\r",
											"pm.test(\"Status code is 400\", function () {\r",
											"    pm.response.to.have.status(400);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message code matches target result message code - ${targetConditionResult.code}`, function () {\r",
											"    pm.expect(responseJSON.code).to.be.eql(targetConditionResult.code);\r",
											"});\r",
											"\r",
											"pm.test(`Result message matches target result message - ${targetConditionResult.message}`, function () {\r",
											"    pm.expect(responseJSON.message).to.be.eql(targetConditionResult.message);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = {\r",
											" // \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09\",\"pacs.008.001.10\",\"pacs.002.001.12\"],\r",
											"  \"condTp\":\"non-overridable-block\",\r",
											"  \"prsptv\":\"both\",\r",
											"  \"condRsn\":\"Default Test Condition\",\r",
											"  \"ntty\":\r",
											"  {\r",
											"    \"id\": `${dbtrNttyId.id}`,\r",
											"    \"schmeNm\":\r",
											"    {\r",
											"      \"prtry\":\"TAZAMA_EID\"\r",
											"    }\r",
											"  },\r",
											"  \"forceCret\":true,\r",
											"  \"usr\":\"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-entity-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Entity Condition Manually - Unknown debtor entity - invalid evtTp 0",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 400,\r",
											"    \"code\": \"FST_ERR_VALIDATION\",\r",
											"    \"error\": \"Bad Request\",\r",
											"    \"message\": \"body/evtTp/0 must be equal to one of the allowed values\"\r",
											"};\r",
											"\r",
											"pm.test(\"Status code is 400\", function () {\r",
											"    pm.response.to.have.status(400);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message code matches target result message code - ${targetConditionResult.code}`, function () {\r",
											"    pm.expect(responseJSON.code).to.be.eql(targetConditionResult.code);\r",
											"});\r",
											"\r",
											"pm.test(`Result message matches target result message - ${targetConditionResult.message}`, function () {\r",
											"    pm.expect(responseJSON.message).to.be.eql(targetConditionResult.message);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = {\r",
											"  \"evtTp\":[\"pain.001.001.11c\",\"pain.013.001.09\",\"pacs.008.001.10\",\"pacs.002.001.12\"],\r",
											"  \"condTp\":\"non-overridable-block\",\r",
											"  \"prsptv\":\"both\",\r",
											"  \"condRsn\":\"Default Test Condition\",\r",
											"  \"ntty\":\r",
											"  {\r",
											"    \"id\": `${dbtrNttyId.id}`,\r",
											"    \"schmeNm\":\r",
											"    {\r",
											"      \"prtry\":\"TAZAMA_EID\"\r",
											"    }\r",
											" },\r",
											"  \"forceCret\":true,\r",
											"  \"usr\":\"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-entity-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Entity Condition Manually - Unknown debtor entity - invalid evtTp 1",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 400,\r",
											"    \"code\": \"FST_ERR_VALIDATION\",\r",
											"    \"error\": \"Bad Request\",\r",
											"    \"message\": \"body/evtTp/1 must be equal to one of the allowed values\"\r",
											"};\r",
											"\r",
											"pm.test(\"Status code is 400\", function () {\r",
											"    pm.response.to.have.status(400);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message code matches target result message code - ${targetConditionResult.code}`, function () {\r",
											"    pm.expect(responseJSON.code).to.be.eql(targetConditionResult.code);\r",
											"});\r",
											"\r",
											"pm.test(`Result message matches target result message - ${targetConditionResult.message}`, function () {\r",
											"    pm.expect(responseJSON.message).to.be.eql(targetConditionResult.message);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = {\r",
											"  \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09vv\",\"pacs.008.001.10\",\"pacs.002.001.12\"],\r",
											"  \"condTp\":\"non-overridable-block\",\r",
											"  \"prsptv\":\"both\",\r",
											"  \"condRsn\":\"Default Test Condition\",\r",
											"  \"ntty\":\r",
											"  {\r",
											"    \"id\": `${dbtrNttyId.id}`,\r",
											"    \"schmeNm\":\r",
											"    {\r",
											"      \"prtry\":\"TAZAMA_EID\"\r",
											"    }\r",
											" },\r",
											"  \"forceCret\":true,\r",
											"  \"usr\":\"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-entity-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Entity Condition Manually - Unknown debtor entity - invalid evtTp 2",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 400,\r",
											"    \"code\": \"FST_ERR_VALIDATION\",\r",
											"    \"error\": \"Bad Request\",\r",
											"    \"message\": \"body/evtTp/2 must be equal to one of the allowed values\"\r",
											"};\r",
											"\r",
											"pm.test(\"Status code is 400\", function () {\r",
											"    pm.response.to.have.status(400);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message code matches target result message code - ${targetConditionResult.code}`, function () {\r",
											"    pm.expect(responseJSON.code).to.be.eql(targetConditionResult.code);\r",
											"});\r",
											"\r",
											"pm.test(`Result message matches target result message - ${targetConditionResult.message}`, function () {\r",
											"    pm.expect(responseJSON.message).to.be.eql(targetConditionResult.message);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = {\r",
											"  \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09\",\"pacs.008.001.10vv\",\"pacs.002.001.12\"],\r",
											"  \"condTp\":\"non-overridable-block\",\r",
											"  \"prsptv\":\"both\",\r",
											"  \"condRsn\":\"Default Test Condition\",\r",
											"  \"ntty\":\r",
											"  {\r",
											"    \"id\": `${dbtrNttyId.id}`,\r",
											"    \"schmeNm\":\r",
											"    {\r",
											"      \"prtry\":\"TAZAMA_EID\"\r",
											"    }\r",
											" },\r",
											"  \"forceCret\":true,\r",
											"  \"usr\":\"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-entity-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Entity Condition Manually - Unknown debtor entity - invalid evtTp 3",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 400,\r",
											"    \"code\": \"FST_ERR_VALIDATION\",\r",
											"    \"error\": \"Bad Request\",\r",
											"    \"message\": \"body/evtTp/3 must be equal to one of the allowed values\"\r",
											"};\r",
											"\r",
											"pm.test(\"Status code is 400\", function () {\r",
											"    pm.response.to.have.status(400);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message code matches target result message code - ${targetConditionResult.code}`, function () {\r",
											"    pm.expect(responseJSON.code).to.be.eql(targetConditionResult.code);\r",
											"});\r",
											"\r",
											"pm.test(`Result message matches target result message - ${targetConditionResult.message}`, function () {\r",
											"    pm.expect(responseJSON.message).to.be.eql(targetConditionResult.message);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = {\r",
											"  \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09\",\"pacs.008.001.10\",\"pacs.002.001.12vv\"],\r",
											"  \"condTp\":\"non-overridable-block\",\r",
											"  \"prsptv\":\"both\",\r",
											"  \"condRsn\":\"Default Test Condition\",\r",
											"  \"ntty\":\r",
											"  {\r",
											"    \"id\": `${dbtrNttyId.id}`,\r",
											"    \"schmeNm\":\r",
											"    {\r",
											"      \"prtry\":\"TAZAMA_EID\"\r",
											"    }\r",
											" },\r",
											"  \"forceCret\":true,\r",
											"  \"usr\":\"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-entity-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Entity Condition Manually - Unknown debtor entity - invalid evtTp duplicates",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 400,\r",
											"    \"code\": \"FST_ERR_VALIDATION\",\r",
											"    \"error\": \"Bad Request\",\r",
											"    \"message\": \"body/evtTp must NOT have duplicate items (items ## 2 and 0 are identical)\"\r",
											"}\r",
											"targetRequestMessage = \"New condition was saved successfully.\"\r",
											"\r",
											"pm.test(\"Status code is 400\", function () {\r",
											"    pm.response.to.have.status(400);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message code matches target result message code - ${targetConditionResult.code}`, function () {\r",
											"    pm.expect(responseJSON.code).to.be.eql(targetConditionResult.code);\r",
											"});\r",
											"\r",
											"pm.test(`Result message includes \"duplicate\"`, function () {\r",
											"   pm.expect(responseJSON.message).to.include(\"duplicate\");\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = {\r",
											"  \"evtTp\":[\"pain.013.001.09\",\"pain.013.001.09\",\"pain.013.001.09\"],\r",
											"  \"condTp\":\"non-overridable-block\",\r",
											"  \"prsptv\":\"both\",\r",
											"  \"condRsn\":\"Default Test Condition\",\r",
											"  \"ntty\":\r",
											"  {\r",
											"    \"id\": `${dbtrNttyId.id}`,\r",
											"    \"schmeNm\":\r",
											"    {\r",
											"      \"prtry\":\"TAZAMA_EID\"\r",
											"    }\r",
											" },\r",
											"  \"forceCret\":true,\r",
											"  \"usr\":\"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-entity-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Entity Condition Manually - Unknown debtor entity - missing condTp",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 400,\r",
											"    \"code\": \"FST_ERR_VALIDATION\",\r",
											"    \"error\": \"Bad Request\",\r",
											"    \"message\": \"body must have required property 'condTp'\"\r",
											"};\r",
											"\r",
											"pm.test(\"Status code is 400\", function () {\r",
											"    pm.response.to.have.status(400);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message code matches target result message code - ${targetConditionResult.code}`, function () {\r",
											"    pm.expect(responseJSON.code).to.be.eql(targetConditionResult.code);\r",
											"});\r",
											"\r",
											"pm.test(`Result message matches target result message - ${targetConditionResult.message}`, function () {\r",
											"    pm.expect(responseJSON.message).to.be.eql(targetConditionResult.message);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = {\r",
											"  \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09\",\"pacs.008.001.10\",\"pacs.002.001.12\"],\r",
											" // \"condTp\":\"non-overridable-block\",\r",
											"  \"prsptv\":\"both\",\r",
											"  \"condRsn\":\"Default Test Condition\",\r",
											"  \"ntty\":\r",
											"  {\r",
											"    \"id\": `${dbtrNttyId.id}`,\r",
											"    \"schmeNm\":\r",
											"    {\r",
											"      \"prtry\":\"TAZAMA_EID\"\r",
											"    }\r",
											"  },\r",
											"  \"forceCret\":true,\r",
											"  \"usr\":\"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-entity-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Entity Condition Manually - Unknown debtor entity - invalid condTp",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 400,\r",
											"    \"code\": \"FST_ERR_VALIDATION\",\r",
											"    \"error\": \"Bad Request\",\r",
											"    \"message\": \"body/condTp must be equal to one of the allowed values\"\r",
											"};\r",
											"\r",
											"pm.test(\"Status code is 400\", function () {\r",
											"    pm.response.to.have.status(400);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message code matches target result message code - ${targetConditionResult.code}`, function () {\r",
											"    pm.expect(responseJSON.code).to.be.eql(targetConditionResult.code);\r",
											"});\r",
											"\r",
											"pm.test(`Result message matches target result message - ${targetConditionResult.message}`, function () {\r",
											"    pm.expect(responseJSON.message).to.be.eql(targetConditionResult.message);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = {\r",
											"  \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09\",\"pacs.008.001.10\",\"pacs.002.001.12\"],\r",
											"  \"condTp\":\"non-overridable-bloccvcv\",\r",
											"  \"prsptv\":\"both\",\r",
											"  \"condRsn\":\"Default Test Condition\",\r",
											"  \"ntty\":\r",
											"  {\r",
											"    \"id\": `${dbtrNttyId.id}`,\r",
											"    \"schmeNm\":\r",
											"    {\r",
											"      \"prtry\":\"TAZAMA_EID\"\r",
											"    }\r",
											" },\r",
											"  \"forceCret\":true,\r",
											"  \"usr\":\"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-entity-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Entity Condition Manually - Unknown debtor entity - missing prsptv",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 400,\r",
											"    \"code\": \"FST_ERR_VALIDATION\",\r",
											"    \"error\": \"Bad Request\",\r",
											"    \"message\": \"body must have required property 'prsptv'\"\r",
											"};\r",
											"\r",
											"pm.test(\"Status code is 400\", function () {\r",
											"    pm.response.to.have.status(400);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message code matches target result message code - ${targetConditionResult.code}`, function () {\r",
											"    pm.expect(responseJSON.code).to.be.eql(targetConditionResult.code);\r",
											"});\r",
											"\r",
											"pm.test(`Result message matches target result message - ${targetConditionResult.message}`, function () {\r",
											"    pm.expect(responseJSON.message).to.be.eql(targetConditionResult.message);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = {\r",
											"  \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09\",\"pacs.008.001.10\",\"pacs.002.001.12\"],\r",
											"  \"condTp\":\"non-overridable-block\",\r",
											" // \"prsptv\":\"both\",\r",
											"  \"condRsn\":\"Default Test Condition\",\r",
											"  \"ntty\":\r",
											"  {\r",
											"    \"id\": `${dbtrNttyId.id}`,\r",
											"    \"schmeNm\":\r",
											"    {\r",
											"      \"prtry\":\"TAZAMA_EID\"\r",
											"    }\r",
											"  },\r",
											"  \"forceCret\":true,\r",
											"  \"usr\":\"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-entity-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Entity Condition Manually - Unknown debtor entity - invalid prsptv",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 400,\r",
											"    \"code\": \"FST_ERR_VALIDATION\",\r",
											"    \"error\": \"Bad Request\",\r",
											"    \"message\": \"body/prsptv must be equal to one of the allowed values\"\r",
											"};\r",
											"\r",
											"pm.test(\"Status code is 400\", function () {\r",
											"    pm.response.to.have.status(400);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message code matches target result message code - ${targetConditionResult.code}`, function () {\r",
											"    pm.expect(responseJSON.code).to.be.eql(targetConditionResult.code);\r",
											"});\r",
											"\r",
											"pm.test(`Result message matches target result message - ${targetConditionResult.message}`, function () {\r",
											"    pm.expect(responseJSON.message).to.be.eql(targetConditionResult.message);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = {\r",
											"  \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09\",\"pacs.008.001.10\",\"pacs.002.001.12\"],\r",
											"  \"condTp\":\"overridable-block\",\r",
											"  \"prsptv\":\"xcxcxc\",\r",
											"  \"condRsn\":\"Default Test Condition\",\r",
											"  \"ntty\":\r",
											"  {\r",
											"    \"id\": `${dbtrNttyId.id}`,\r",
											"    \"schmeNm\":\r",
											"    {\r",
											"      \"prtry\":\"TAZAMA_EID\"\r",
											"    }\r",
											" },\r",
											"  \"forceCret\":true,\r",
											"  \"usr\":\"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-entity-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Entity Condition Manually - Unknown debtor entity - missing condRsn",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 400,\r",
											"    \"code\": \"FST_ERR_VALIDATION\",\r",
											"    \"error\": \"Bad Request\",\r",
											"    \"message\": \"body must have required property 'condRsn'\"\r",
											"};\r",
											"\r",
											"pm.test(\"Status code is 400\", function () {\r",
											"    pm.response.to.have.status(400);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message code matches target result message code - ${targetConditionResult.code}`, function () {\r",
											"    pm.expect(responseJSON.code).to.be.eql(targetConditionResult.code);\r",
											"});\r",
											"\r",
											"pm.test(`Result message matches target result message - ${targetConditionResult.message}`, function () {\r",
											"    pm.expect(responseJSON.message).to.be.eql(targetConditionResult.message);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = {\r",
											"  \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09\",\"pacs.008.001.10\",\"pacs.002.001.12\"],\r",
											"  \"condTp\":\"non-overridable-block\",\r",
											"  \"prsptv\":\"both\",\r",
											" // \"condRsn\":\"Default Test Condition\",\r",
											"  \"ntty\":\r",
											"  {\r",
											"    \"id\": `${dbtrNttyId.id}`,\r",
											"    \"schmeNm\":\r",
											"    {\r",
											"      \"prtry\":\"TAZAMA_EID\"\r",
											"    }\r",
											"  },\r",
											"  \"forceCret\":true,\r",
											"  \"usr\":\"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-entity-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Entity Condition Manually - Unknown debtor entity - missing ntty",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 400,\r",
											"    \"code\": \"FST_ERR_VALIDATION\",\r",
											"    \"error\": \"Bad Request\",\r",
											"    \"message\": \"body must have required property 'ntty'\"\r",
											"};\r",
											"\r",
											"pm.test(\"Status code is 400\", function () {\r",
											"    pm.response.to.have.status(400);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message code matches target result message code - ${targetConditionResult.code}`, function () {\r",
											"    pm.expect(responseJSON.code).to.be.eql(targetConditionResult.code);\r",
											"});\r",
											"\r",
											"pm.test(`Result message matches target result message - ${targetConditionResult.message}`, function () {\r",
											"    pm.expect(responseJSON.message).to.be.eql(targetConditionResult.message);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = {\r",
											"  \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09\",\"pacs.008.001.10\",\"pacs.002.001.12\"],\r",
											"  \"condTp\":\"non-overridable-block\",\r",
											"  \"prsptv\":\"both\",\r",
											"  \"condRsn\":\"Default Test Condition\",\r",
											"//  \"ntty\":\r",
											"//  {\r",
											"//    \"id\": `${dbtrNttyId.id}`,\r",
											"//    \"schmeNm\":\r",
											"//    {\r",
											"//      \"prtry\":\"TAZAMA_EID\"\r",
											"//    }\r",
											"//  },\r",
											"  \"forceCret\":true,\r",
											"  \"usr\":\"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-entity-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Entity Condition Manually - Unknown debtor entity - missing ntty.id",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 400,\r",
											"    \"code\": \"FST_ERR_VALIDATION\",\r",
											"    \"error\": \"Bad Request\",\r",
											"    \"message\": \"body/ntty must have required property 'id'\"\r",
											"};\r",
											"\r",
											"pm.test(\"Status code is 400\", function () {\r",
											"    pm.response.to.have.status(400);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message code matches target result message code - ${targetConditionResult.code}`, function () {\r",
											"    pm.expect(responseJSON.code).to.be.eql(targetConditionResult.code);\r",
											"});\r",
											"\r",
											"pm.test(`Result message matches target result message - ${targetConditionResult.message}`, function () {\r",
											"    pm.expect(responseJSON.message).to.be.eql(targetConditionResult.message);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = {\r",
											"  \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09\",\"pacs.008.001.10\",\"pacs.002.001.12\"],\r",
											"  \"condTp\":\"non-overridable-block\",\r",
											"  \"prsptv\":\"both\",\r",
											"  \"condRsn\":\"Default Test Condition\",\r",
											"  \"ntty\":\r",
											"  {\r",
											"//    \"id\": `${dbtrNttyId.id}`,\r",
											"    \"schmeNm\":\r",
											"    {\r",
											"      \"prtry\":\"TAZAMA_EID\"\r",
											"    }\r",
											"  },\r",
											"  \"forceCret\":true,\r",
											"  \"usr\":\"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-entity-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Entity Condition Manually - Unknown debtor entity - missing ntty.schmeNm.prtry",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 400,\r",
											"    \"code\": \"FST_ERR_VALIDATION\",\r",
											"    \"error\": \"Bad Request\",\r",
											"    \"message\": \"body/ntty/schmeNm must have required property 'prtry'\"\r",
											"};\r",
											"\r",
											"pm.test(\"Status code is 400\", function () {\r",
											"    pm.response.to.have.status(400);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message code matches target result message code - ${targetConditionResult.code}`, function () {\r",
											"    pm.expect(responseJSON.code).to.be.eql(targetConditionResult.code);\r",
											"});\r",
											"\r",
											"pm.test(`Result message matches target result message - ${targetConditionResult.message}`, function () {\r",
											"    pm.expect(responseJSON.message).to.be.eql(targetConditionResult.message);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = {\r",
											"  \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09\",\"pacs.008.001.10\",\"pacs.002.001.12\"],\r",
											"  \"condTp\":\"non-overridable-block\",\r",
											"  \"prsptv\":\"both\",\r",
											"  \"condRsn\":\"Default Test Condition\",\r",
											"  \"ntty\":\r",
											"  {\r",
											"    \"id\": `${dbtrNttyId.id}`,\r",
											"    \"schmeNm\":\r",
											"    {\r",
											"//      \"prtry\":\"TAZAMA_EID\"\r",
											"    }\r",
											"  },\r",
											"  \"forceCret\":true,\r",
											"  \"usr\":\"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-entity-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Entity Condition Manually - Unknown debtor entity - missing ntty.schmeNm",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 400,\r",
											"    \"code\": \"FST_ERR_VALIDATION\",\r",
											"    \"error\": \"Bad Request\",\r",
											"    \"message\": \"body/ntty must have required property 'schmeNm'\"\r",
											"};\r",
											"\r",
											"pm.test(\"Status code is 400\", function () {\r",
											"    pm.response.to.have.status(400);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message code matches target result message code - ${targetConditionResult.code}`, function () {\r",
											"    pm.expect(responseJSON.code).to.be.eql(targetConditionResult.code);\r",
											"});\r",
											"\r",
											"pm.test(`Result message matches target result message - ${targetConditionResult.message}`, function () {\r",
											"    pm.expect(responseJSON.message).to.be.eql(targetConditionResult.message);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = {\r",
											"  \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09\",\"pacs.008.001.10\",\"pacs.002.001.12\"],\r",
											"  \"condTp\":\"non-overridable-block\",\r",
											"  \"prsptv\":\"both\",\r",
											"  \"condRsn\":\"Default Test Condition\",\r",
											"  \"ntty\":\r",
											"  {\r",
											"    \"id\": `${dbtrNttyId.id}`,\r",
											"//    \"schmeNm\":\r",
											"//    {\r",
											"//      \"prtry\":\"TAZAMA_EID\"\r",
											"//    }\r",
											"  },\r",
											"  \"forceCret\":true,\r",
											"  \"usr\":\"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-entity-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Entity Condition Manually - Unknown debtor entity - missing forceCret",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 400,\r",
											"    \"code\": \"FST_ERR_VALIDATION\",\r",
											"    \"error\": \"Bad Request\",\r",
											"    \"message\": \"body must have required property 'forceCret'\"\r",
											"};\r",
											"\r",
											"pm.test(\"Status code is 400\", function () {\r",
											"    pm.response.to.have.status(400);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message code matches target result message code - ${targetConditionResult.code}`, function () {\r",
											"    pm.expect(responseJSON.code).to.be.eql(targetConditionResult.code);\r",
											"});\r",
											"\r",
											"pm.test(`Result message matches target result message - ${targetConditionResult.message}`, function () {\r",
											"    pm.expect(responseJSON.message).to.be.eql(targetConditionResult.message);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = {\r",
											"  \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09\",\"pacs.008.001.10\",\"pacs.002.001.12\"],\r",
											"  \"condTp\":\"non-overridable-block\",\r",
											"  \"prsptv\":\"both\",\r",
											"  \"condRsn\":\"Default Test Condition\",\r",
											"  \"ntty\":\r",
											"  {\r",
											"    \"id\": `${dbtrNttyId.id}`,\r",
											"    \"schmeNm\":\r",
											"    {\r",
											"      \"prtry\":\"TAZAMA_EID\"\r",
											"    }\r",
											" },\r",
											"//  \"forceCret\":true,\r",
											"  \"usr\":\"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-entity-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Entity Condition Manually - Unknown debtor entity - invalid forceCret",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 400,\r",
											"    \"code\": \"FST_ERR_VALIDATION\",\r",
											"    \"error\": \"Bad Request\",\r",
											"    \"message\": \"body/forceCret must be boolean\"\r",
											"};\r",
											"\r",
											"pm.test(\"Status code is 400\", function () {\r",
											"    pm.response.to.have.status(400);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message code matches target result message code - ${targetConditionResult.code}`, function () {\r",
											"    pm.expect(responseJSON.code).to.be.eql(targetConditionResult.code);\r",
											"});\r",
											"\r",
											"pm.test(`Result message matches target result message - ${targetConditionResult.message}`, function () {\r",
											"    pm.expect(responseJSON.message).to.be.eql(targetConditionResult.message);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = {\r",
											"  \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09\",\"pacs.008.001.10\",\"pacs.002.001.12\"],\r",
											"  \"condTp\":\"non-overridable-block\",\r",
											"  \"prsptv\":\"both\",\r",
											"  \"condRsn\":\"Default Test Condition\",\r",
											"  \"ntty\":\r",
											"  {\r",
											"    \"id\": `${dbtrNttyId.id}`,\r",
											"    \"schmeNm\":\r",
											"    {\r",
											"      \"prtry\":\"TAZAMA_EID\"\r",
											"    }\r",
											" },\r",
											"  \"forceCret\":\"all\",\r",
											"  \"usr\":\"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-entity-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Entity Condition Manually - Unknown debtor entity - missing usr",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 400,\r",
											"    \"code\": \"FST_ERR_VALIDATION\",\r",
											"    \"error\": \"Bad Request\",\r",
											"    \"message\": \"body must have required property 'usr'\"\r",
											"};\r",
											"\r",
											"pm.test(\"Status code is 400\", function () {\r",
											"    pm.response.to.have.status(400);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message code matches target result message code - ${targetConditionResult.code}`, function () {\r",
											"    pm.expect(responseJSON.code).to.be.eql(targetConditionResult.code);\r",
											"});\r",
											"\r",
											"pm.test(`Result message matches target result message - ${targetConditionResult.message}`, function () {\r",
											"    pm.expect(responseJSON.message).to.be.eql(targetConditionResult.message);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = {\r",
											"  \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09\",\"pacs.008.001.10\",\"pacs.002.001.12\"],\r",
											"  \"condTp\":\"non-overridable-block\",\r",
											"  \"prsptv\":\"both\",\r",
											"  \"condRsn\":\"Default Test Condition\",\r",
											"  \"ntty\":\r",
											"  {\r",
											"    \"id\": `${dbtrNttyId.id}`,\r",
											"    \"schmeNm\":\r",
											"    {\r",
											"      \"prtry\":\"TAZAMA_EID\"\r",
											"    }\r",
											" },\r",
											"  \"forceCret\":true,\r",
											"//  \"usr\":123\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-entity-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Entity Condition Manually - Unknown debtor entity - override missing expiration",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 500,\r",
											"    \"error\": \"Internal Server Error\",\r",
											"    \"message\": \"Error: Expiration date needs to be provided for override conditions.\"\r",
											"};\r",
											"\r",
											"pm.test(\"Status code is 500\", function () {\r",
											"    pm.response.to.have.status(500);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message matches target result message - ${targetConditionResult.message}`, function () {\r",
											"    pm.expect(responseJSON.message).to.be.eql(targetConditionResult.message);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = {\r",
											"    \"evtTp\": [\"pain.001.001.11\", \"pain.013.001.09\", \"pacs.008.001.10\", \"pacs.002.001.12\"],\r",
											"    \"condTp\": \"override\",\r",
											"    \"prsptv\": \"both\",\r",
											"    \"condRsn\": \"Default Test Condition\",\r",
											"    \"ntty\":\r",
											"    {\r",
											"        \"id\": `${dbtrNttyId.id}`,\r",
											"        \"schmeNm\":\r",
											"        {\r",
											"            \"prtry\": \"TAZAMA_EID\"\r",
											"        }\r",
											"    },\r",
											"    \"forceCret\": true,\r",
											"    \"usr\": \"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-entity-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Entity Condition Manually - Unknown debtor entity - expiration before now",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 500,\r",
											"    \"error\": \"Internal Server Error\",\r",
											"    \"message\": \"Error: Expiration date must be after inception date.\"\r",
											"};\r",
											"\r",
											"pm.test(\"Status code is 500\", function () {\r",
											"    pm.response.to.have.status(500);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message matches target result message - ${targetConditionResult.message}`, function () {\r",
											"    pm.expect(responseJSON.message).to.be.eql(targetConditionResult.message);\r",
											"});\r",
											"\r",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"// override condition with no inception date (should default to now) and expiration date before current date\r",
											"\r",
											"messageBody = {\r",
											"    \"evtTp\": [\"pain.001.001.11\", \"pain.013.001.09\", \"pacs.008.001.10\", \"pacs.002.001.12\"],\r",
											"    \"condTp\": \"override\",\r",
											"    \"prsptv\": \"both\",\r",
											"    \"condRsn\": \"Default Test Condition\",\r",
											"    \"xprtnDtTm\": \"2021-03-03T22:00:00.999Z\",\r",
											"    \"ntty\":\r",
											"    {\r",
											"        \"id\": `${dbtrNttyId.id}`,\r",
											"        \"schmeNm\":\r",
											"        {\r",
											"            \"prtry\": \"TAZAMA_EID\"\r",
											"        }\r",
											"    },\r",
											"    \"forceCret\": true,\r",
											"    \"usr\": \"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-entity-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Entity Condition Manually - Unknown debtor entity - expiration invalid",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 500,\r",
											"    \"error\": \"Internal Server Error\",\r",
											"    \"message\": \"Error: the provided xprtnDtTm: '2025-03-03T24:00:00.999Z' is invalid\"\r",
											"};\r",
											"\r",
											"pm.test(\"Status code is 500\", function () {\r",
											"    pm.response.to.have.status(500);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message matches target result message - ${targetConditionResult.message}`, function () {\r",
											"    pm.expect(responseJSON.message).to.be.eql(targetConditionResult.message);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"// override condition with no inception date (should default to now) and expiration date invalid\r",
											"\r",
											"messageBody = {\r",
											"    \"evtTp\": [\"pain.001.001.11\", \"pain.013.001.09\", \"pacs.008.001.10\", \"pacs.002.001.12\"],\r",
											"    \"condTp\": \"override\",\r",
											"    \"prsptv\": \"both\",\r",
											"    \"condRsn\": \"Default Test Condition\",\r",
											"    \"xprtnDtTm\": \"2025-03-03T24:00:00.999Z\",\r",
											"    \"ntty\":\r",
											"    {\r",
											"        \"id\": `${dbtrNttyId.id}`,\r",
											"        \"schmeNm\":\r",
											"        {\r",
											"            \"prtry\": \"TAZAMA_EID\"\r",
											"        }\r",
											"    },\r",
											"    \"forceCret\": true,\r",
											"    \"usr\": \"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-entity-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Entity Condition Manually - Unknown debtor entity - inception invalid",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 500,\r",
											"    \"error\": \"Internal Server Error\",\r",
											"    \"message\": \"Error: the provided incptnDtTm: '2025-10-01T25:00:00.999Z' is invalid\"\r",
											"};\r",
											"\r",
											"pm.test(\"Status code is 500\", function () {\r",
											"    pm.response.to.have.status(500);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message matches target result message - ${targetConditionResult.message}`, function () {\r",
											"    pm.expect(responseJSON.message).to.be.eql(targetConditionResult.message);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"// override condition with no inception date (should default to now) and expiration date invalid\r",
											"\r",
											"messageBody = {\r",
											"    \"evtTp\": [\"pain.001.001.11\", \"pain.013.001.09\", \"pacs.008.001.10\", \"pacs.002.001.12\"],\r",
											"    \"condTp\": \"override\",\r",
											"    \"prsptv\": \"both\",\r",
											"    \"condRsn\": \"Default Test Condition\",\r",
											"    \"incptnDtTm\": \"2025-10-01T25:00:00.999Z\",\r",
											"    \"xprtnDtTm\": \"2026-03-03T22:00:00.999Z\",\r",
											"    \"ntty\":\r",
											"    {\r",
											"        \"id\": `${dbtrNttyId.id}`,\r",
											"        \"schmeNm\":\r",
											"        {\r",
											"            \"prtry\": \"TAZAMA_EID\"\r",
											"        }\r",
											"    },\r",
											"    \"forceCret\": true,\r",
											"    \"usr\": \"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-entity-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Entity Condition Manually - Unknown debtor entity - expiration  before inception",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 500,\r",
											"    \"error\": \"Internal Server Error\",\r",
											"    \"message\": \"Error: Expiration date must be after inception date.\"\r",
											"};\r",
											"\r",
											"pm.test(\"Status code is 500\", function () {\r",
											"    pm.response.to.have.status(500);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message matches target result message - ${targetConditionResult.message}`, function () {\r",
											"    pm.expect(responseJSON.message).to.be.eql(targetConditionResult.message);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"// override condition with inception date in the future and expiration date before inception date\r",
											"\r",
											"messageBody = {\r",
											"    \"evtTp\": [\"pain.001.001.11\", \"pain.013.001.09\", \"pacs.008.001.10\", \"pacs.002.001.12\"],\r",
											"    \"condTp\": \"override\",\r",
											"    \"prsptv\": \"both\",\r",
											"    \"condRsn\": \"Default Test Condition\",\r",
											"    \"incptnDtTm\": \"2025-10-10T23:00:00.999Z\",\r",
											"    \"xprtnDtTm\": \"2022-03-03T23:00:00.999Z\",\r",
											"    \"ntty\":\r",
											"    {\r",
											"        \"id\": `${dbtrNttyId.id}`,\r",
											"        \"schmeNm\":\r",
											"        {\r",
											"            \"prtry\": \"TAZAMA_EID\"\r",
											"        }\r",
											"    },\r",
											"    \"forceCret\": true,\r",
											"    \"usr\": \"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-entity-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Entity Condition Manually - Unknown debtor entity - inception before now",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"\r",
											"targetConditionResult = {\r",
											"    \"statusCode\": 500,\r",
											"    \"error\": \"Internal Server Error\",\r",
											"    \"message\": \"Error: Inception date cannot be before current date/time\"\r",
											"};\r",
											"\r",
											"pm.test(\"Status code is 500\", function () {\r",
											"    pm.response.to.have.status(500);\r",
											"});\r",
											"\r",
											"pm.test(`Result message status code matches target result status code ${targetConditionResult.statusCode}`, function () {\r",
											"    pm.expect(responseJSON.statusCode).to.be.eql(targetConditionResult.statusCode);\r",
											"});\r",
											"\r",
											"pm.test(`Result message matches target result message - ${targetConditionResult.message}`, function () {\r",
											"    pm.expect(responseJSON.message).to.be.eql(targetConditionResult.message);\r",
											"});\r",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"// override condition with inception date in the past(before current date)\r",
											"\r",
											"messageBody = {\r",
											"    \"evtTp\": [\"pain.001.001.11\", \"pain.013.001.09\", \"pacs.008.001.10\", \"pacs.002.001.12\"],\r",
											"    \"condTp\": \"override\",\r",
											"    \"prsptv\": \"both\",\r",
											"    \"condRsn\": \"Default Test Condition\",\r",
											"    \"incptnDtTm\": \"2023-10-01T06:41:00.289Z\",\r",
											"    \"xprtnDtTm\": \"2027-10-11T06:41:00.289Z\",\r",
											"    \"ntty\":\r",
											"    {\r",
											"        \"id\": `${dbtrNttyId.id}`,\r",
											"        \"schmeNm\":\r",
											"        {\r",
											"            \"prtry\": \"TAZAMA_EID\"\r",
											"        }\r",
											"    },\r",
											"    \"forceCret\": true,\r",
											"    \"usr\": \"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-entity-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Entity Condition Manually - Unknown debtor entity - inception default now",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"let inceptionDate = responseJSON.result.conditions[0].incptnDtTm;\r",
											"\r",
											"var now = new Date();\r",
											"pm.globals.set(\"currentDateTime\", now.toISOString());\r",
											"// Retrieve the variable from the environment to use in the script\r",
											"var currentDateTime = pm.globals.get(\"currentDateTime\");\r",
											"\r",
											"var inceptionDt = inceptionDate.substring(0, 10);\r",
											"var currentDt = currentDateTime.substring(0, 10);\r",
											"\r",
											"pm.test(\"Status code is 200\", function () {\r",
											"    pm.response.to.have.status(200);\r",
											"});\r",
											"\r",
											"pm.test(`Inception date  ${inceptionDate} equals current date  ${currentDt} `, function () {\r",
											"    pm.expect(inceptionDt).to.be.eql(currentDt);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"// override condition with inception date in the future (before current date)\r",
											"\r",
											"messageBody = {\r",
											"    \"evtTp\": [\"pain.001.001.11\", \"pain.013.001.09\", \"pacs.008.001.10\", \"pacs.002.001.12\"],\r",
											"    \"condTp\": \"non-overridable-block\",\r",
											"    \"prsptv\": \"both\",\r",
											"    \"condRsn\": \"Default Test Condition\",\r",
											"    \"ntty\":\r",
											"    {\r",
											"        \"id\": `${dbtrNttyId.id}`,\r",
											"        \"schmeNm\":\r",
											"        {\r",
											"            \"prtry\": \"TAZAMA_EID\"\r",
											"        }\r",
											"    },\r",
											"    \"forceCret\": true,\r",
											"    \"usr\": \"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-entity-condition}}"
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "Basic Functionality",
					"item": [
						{
							"name": "Fetch Entity Conditions - non-existent debtor entity",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.text();\r",
											"let nttyId = pm.globals.get(\"dbtrNttyId\");\r",
											"let nttyIdSchme = pm.globals.get(\"dbtrNttyIdSchmeNm\");\r",
											"let tenantId = pm.globals.get(\"tenantId\");\r",
											"let targetEntityId = nttyId + nttyIdSchme;\r",
											"\r",
											"pm.test(\"Status code is 404 Not Found\", function () {\r",
											"    pm.response.to.have.status(404);\r",
											"});\r",
											"\r",
											"pm.test(\"Response is 'Entity does not exist in the database'\", function () {\r",
											"    pm.expect(responseJSON).to.be.equal(\"Entity does not exist in the database\");\r",
											"});\r",
											"\r",
											"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetEntityId, false);\r",
											"\r",
											"await pm.sendRequest(postRequest, (error, response) => {\r",
											"    if (utils.getLogLevel() === 'DEBUG') {\r",
											"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
											"    }\r",
											"    const conditionResult = response.json().data;\r",
											"\r",
											"    pm.test(`No governed_as_debtor_by conditions for account [${targetEntityId}] exists in the database`, function () {\r",
											"        pm.expect(conditionResult.governed_as_debtor_by).to.be.empty;\r",
											"    });\r",
											"\r",
											"    pm.test(`No governed_as_creditor_by conditions for account [${targetEntityId}] exists in the database`, function () {\r",
											"        pm.expect(conditionResult.governed_as_creditor_by).to.be.empty;\r",
											"    });\r",
											"\r",
											"});\r",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"// Create identifier variables from the pacs.008 message\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const tenantId = submittedPacs008Message.TenantId;\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"tenantId\", tenantId);\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"pm.globals.set(\"syncCache\", \"no\");"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"protocolProfileBehavior": {
								"disableBodyPruning": true
							},
							"request": {
								"method": "GET",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/admin/event-flow-control/entity?tenantid={{tenantId}}&id={{dbtrNttyId}}&schmenm={{dbtrNttyIdSchmeNm}}&synccache={{syncCache}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"admin",
										"event-flow-control",
										"entity"
									],
									"query": [
										{
											"key": "tenantid",
											"value": "{{tenantId}}"
										},
										{
											"key": "id",
											"value": "{{dbtrNttyId}}"
										},
										{
											"key": "schmenm",
											"value": "{{dbtrNttyIdSchmeNm}}"
										},
										{
											"key": "synccache",
											"value": "{{syncCache}}"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Fetch Entity Conditions - new debtor entity",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.text();\r",
											"let nttyId = pm.globals.get(\"dbtrNttyId\");\r",
											"let nttyIdSchme = pm.globals.get(\"dbtrNttyIdSchmeNm\");\r",
											"let tenantId = pm.globals.get(\"tenantId\");\r",
											"let targetEntityId = nttyId + nttyIdSchme;\r",
											"\r",
											"pm.test(\"Status code is 204\", function () {\r",
											"    pm.response.to.have.status(204);\r",
											"});\r",
											"\r",
											"pm.test(\"Result is an empty response\", function () {\r",
											"    pm.expect(responseJSON).to.be.equal( \"\" );\r",
											"});\r",
											"\r",
											"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetEntityId, false);\r",
											"\r",
											"await pm.sendRequest(postRequest, (error, response) => {\r",
											"    if (utils.getLogLevel() === 'DEBUG') {\r",
											"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
											"    }\r",
											"    const conditionResult = response.json().data;\r",
											"\r",
											"    pm.test(`No governed_as_debtor_by conditions for account [${targetEntityId}] exists in the database`, function () {\r",
											"        pm.expect(conditionResult.governed_as_debtor_by).to.be.empty;\r",
											"    });\r",
											"\r",
											"    pm.test(`No governed_as_creditor_by conditions for account [${targetEntityId}] exists in the database`, function () {\r",
											"        pm.expect(conditionResult.governed_as_creditor_by).to.be.empty;\r",
											"    });\r",
											"\r",
											"});\r",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSets = await utils.createTransactionSetsInDatabase();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSets[0].pacs008);\r",
											"\r",
											"// Create identifier variables from the pacs.008 message\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const tenantId = submittedPacs008Message.TenantId;\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"tenantId\", tenantId);\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"pm.globals.set(\"syncCache\", \"no\");"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"protocolProfileBehavior": {
								"disableBodyPruning": true
							},
							"request": {
								"method": "GET",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/admin/event-flow-control/entity?id={{dbtrNttyId}}&schmenm={{dbtrNttyIdSchmeNm}}&synccache={{syncCache}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"admin",
										"event-flow-control",
										"entity"
									],
									"query": [
										{
											"key": "id",
											"value": "{{dbtrNttyId}}"
										},
										{
											"key": "schmenm",
											"value": "{{dbtrNttyIdSchmeNm}}"
										},
										{
											"key": "synccache",
											"value": "{{syncCache}}"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Entity Condition - Unknown debtor entity",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"let conditionResult = responseJSON.result.conditions;\r",
											"let conditionEntity = responseJSON.result.ntty;\r",
											"let requestMessage = responseJSON.message;\r",
											"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
											"let nttyId = pm.globals.get(\"dbtrNttyId\");\r",
											"let nttyIdSchme = pm.globals.get(\"dbtrNttyIdSchmeNm\");\r",
											"let tenantId = pm.globals.get(\"tenantId\");\r",
											"let targetEntityId = nttyId + nttyIdSchme;\r",
											"\r",
											"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
											"targetRequestMessage = \"New condition was saved successfully.\"\r",
											"\r",
											"pm.test(\"Status code is 200\", function () {\r",
											"    pm.response.to.have.status(200);\r",
											"});\r",
											"\r",
											"pm.test(\"Result message matches target result message\", function () {\r",
											"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
											"});\r",
											"\r",
											"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
											"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
											"});\r",
											"\r",
											"pm.test(\"Result conditions array only contains a single condition\", function () {\r",
											"    pm.expect(conditionResult.length).to.be.eql(1);\r",
											"});\r",
											"\r",
											"let firstElement = conditionResult[0];\r",
											"\r",
											"pm.test(\"Result condition has a non-empty condId\", function () {\r",
											"    pm.expect(firstElement.condId).to.exist.and.not.be.empty;\r",
											"});\r",
											"\r",
											"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
											"    pm.expect(firstElement.condTp).to.be.eql(targetConditionResult.condTp);\r",
											"});\r",
											"\r",
											"if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
											"    pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
											"        pm.expect(firstElement.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
											"    });\r",
											"} else {    // if not, one must have been defaulted\r",
											"    pm.test(\"Result condition has a non-empty incptnDtTm\", function () {\r",
											"        pm.expect(firstElement.incptnDtTm).to.exist.and.not.be.empty;\r",
											"    });\r",
											"}\r",
											"\r",
											"if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
											"    pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
											"        pm.expect(firstElement.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
											"    });\r",
											"} else {    // if not, one must not have been defaulted\r",
											"    pm.test(\"Result condition does not have an xprtnDtTm\", function () {\r",
											"        pm.expect(firstElement.xprtnDtTm).to.not.exist;\r",
											"    });\r",
											"}\r",
											"\r",
											"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
											"    pm.expect(firstElement.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
											"});\r",
											"\r",
											"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
											"    pm.expect(firstElement.usr).to.be.eql(targetConditionResult.usr);\r",
											"});\r",
											"\r",
											"pm.test(\"Result condition has a non-empty creDtTm\", function () {\r",
											"    pm.expect(firstElement.creDtTm).to.exist.and.not.be.empty;\r",
											"});\r",
											"\r",
											"// create an array that only includes the perspective descriptions so that we can evaluate them easily\r",
											"let perspectives = firstElement.prsptvs.map(({ prsptv }) => prsptv);\r",
											"\r",
											"if (targetConditionResult.prsptv === \"both\") {\r",
											"    pm.test(\"Result prsptv array contains only 2 perspectives\", function () {\r",
											"        pm.expect(firstElement.prsptvs.length).to.be.eql(2);\r",
											"    });\r",
											"\r",
											"    let targetPerspectives = [\"governed_as_creditor_by\", \"governed_as_debtor_by\"];\r",
											"\r",
											"    pm.test(`Result prsptv array contains both ${JSON.stringify(targetPerspectives)} perspectives`, function () {\r",
											"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
											"    });\r",
											"\r",
											"} else if (targetConditionResult.prsptv === \"debtor\") {\r",
											"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
											"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
											"    });\r",
											"\r",
											"    let targetPerspectives = [\"governed_as_debtor_by\"];\r",
											"\r",
											"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
											"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
											"    });\r",
											"\r",
											"} else if (targetConditionResult.prsptv === \"creditor\") {\r",
											"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
											"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
											"    });\r",
											"\r",
											"    let targetPerspectives = [\"governed_as_creditor_by\"];\r",
											"\r",
											"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
											"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
											"    });\r",
											"\r",
											"};\r",
											"\r",
											"for (let i = 0; i < firstElement.prsptvs.length; i++) {   // for each perspective\r",
											"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} contains a non-empty evtTp array`, function () {\r",
											"        pm.expect(firstElement.prsptvs[i].evtTp).to.be.an('array').and.not.be.empty;\r",
											"    });\r",
											"\r",
											"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} evtTp array matches submitted condition`, function () {\r",
											"        pm.expect(firstElement.prsptvs[i].evtTp).to.include.members(targetConditionResult.evtTp);\r",
											"    });\r",
											"\r",
											"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
											"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches submitted condition`, function () {\r",
											"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
											"        });\r",
											"    } else {    // if not, one must have been defaulted\r",
											"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches created condition incptDtTm`, function () {\r",
											"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.eql(firstElement.incptnDtTm);\r",
											"        });\r",
											"    }\r",
											"\r",
											"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
											"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} xprtnDtTm matches submitted condition`, function () {\r",
											"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
											"        });\r",
											"    } else {    // if not, one must not have been defaulted\r",
											"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} does not have an xprtnDtTm`, function () {\r",
											"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.not.exist;\r",
											"        });\r",
											"    }\r",
											"\r",
											"}\r",
											"\r",
											"pm.test(\"Result condition ntty.id matches submitted condition\", function () {\r",
											"    pm.expect(conditionEntity.id).to.be.eql(targetConditionResult.ntty.id);\r",
											"});\r",
											"\r",
											"pm.test(\"Result condition ntty.schmeNm.prtry matches submitted condition\", function () {\r",
											"    pm.expect(conditionEntity.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
											"});\r",
											"\r",
											"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetEntityId, false);;\r",
											"\r",
											"await pm.sendRequest(postRequest, (error, response) => {\r",
											"    if (utils.getLogLevel() === 'DEBUG') {\r",
											"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
											"    }\r",
											"    databaseConditionResult = response.json().data;\r",
											"\r",
											"    if (utils.getLogLevel() === 'DEBUG') {\r",
											"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
											"    }\r",
											"\r",
											"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
											"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
											"\r",
											"    pm.test(`Only one condition for entity [${targetEntityId}] exists in the database`, function () {\r",
											"        pm.expect(graphConditionList.length).to.eql(1);\r",
											"    });\r",
											"\r",
											"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
											"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
											"            pm.expect(conditionGraph.v[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
											"        });\r",
											"    }\r",
											"\r",
											"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
											"        pm.expect(conditionGraph.v[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
											"        pm.expect(conditionGraph.v[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
											"    });\r",
											"\r",
											"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
											"        pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
											"            pm.expect(conditionGraph.v[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
											"        });\r",
											"    } else {    // if not, one must have been defaulted\r",
											"        pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
											"            pm.expect(conditionGraph.v[0].incptnDtTm).to.exist.and.not.be.empty;\r",
											"        });\r",
											"    }\r",
											"\r",
											"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
											"        pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
											"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
											"        });\r",
											"    } else {    // if not, one must not have been defaulted\r",
											"        pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
											"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.not.exist;\r",
											"        });\r",
											"    }\r",
											"\r",
											"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
											"        pm.expect(conditionGraph.v[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
											"        pm.expect(conditionGraph.v[0].ntty.id).to.be.eql(targetConditionResult.ntty.id);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
											"        pm.expect(conditionGraph.v[0].ntty.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
											"        pm.expect(conditionGraph.v[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
											"        pm.expect(conditionGraph.v[0].usr).to.be.eql(targetConditionResult.usr);\r",
											"    });\r",
											"\r",
											"    let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, conditionGraph.v[0]._key);\r",
											"\r",
											"    pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
											"        pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database 'governed_as_creditor_by' edge exists\", function () {\r",
											"        pm.expect(edgeList).to.include.members([\"governed_as_creditor_by\"]);\r",
											"    });\r",
											"\r",
											"    pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
											"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
											"    });\r",
											"\r",
											"    pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
											"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
											"    });\r",
											"\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const tenantId = submittedPacs008Message.TenantId;\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"tenantId\", tenantId);\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = utils.getCreateEntityConditionBody(\r",
											"    /* Event Types */ null,             // null defaults ['pain.001.001.13', 'pain.013.001.09', 'pacs.008.01.10', 'pacs.002.01.11']\r",
											"    /* Condition Type */ null,          // null defaults 'non-overridable-block'\r",
											"    /* Perspetive */ null,              // null defaults 'both'\r",
											"    /* Inception Date */ null,          // null defaults now()\r",
											"    /* Expiration Date */ null,         // null defaults now() + 24 hours\r",
											"    /* Condition Reason */ null,        // null defaults 'Default Test Condition'\r",
											"    /* Entity */ dbtrNttyId,            // null defaults new unknown entity\r",
											"    /* Force Create */ false,           // null defaults true\r",
											"    /* User ID */ null                  // null defaults 'POSTMAN'\r",
											");\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', messageBody);\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-entity-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Entity Condition Manually - Unknown debtor entity",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"let conditionResult = responseJSON.result.conditions;\r",
											"let conditionEntity = responseJSON.result.ntty;\r",
											"let requestMessage = responseJSON.message;\r",
											"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
											"let nttyId = pm.globals.get(\"dbtrNttyId\");\r",
											"let nttyIdSchme = pm.globals.get(\"dbtrNttyIdSchmeNm\");\r",
											"let tenantId = pm.globals.get(\"tenantId\");\r",
											"let targetEntityId = nttyId + nttyIdSchme;\r",
											"\r",
											"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
											"targetRequestMessage = \"New condition was saved successfully.\"\r",
											"\r",
											"pm.test(\"Status code is 200\", function () {\r",
											"    pm.response.to.have.status(200);\r",
											"});\r",
											"\r",
											"pm.test(\"Result message matches target result message\", function () {\r",
											"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
											"});\r",
											"\r",
											"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
											"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
											"});\r",
											"\r",
											"pm.test(\"Result conditions array only contains a single condition\", function () {\r",
											"    pm.expect(conditionResult.length).to.be.eql(1);\r",
											"});\r",
											"\r",
											"let firstElement = conditionResult[0];\r",
											"\r",
											"pm.test(\"Result condition has a non-empty condId\", function () {\r",
											"    pm.expect(firstElement.condId).to.exist.and.not.be.empty;\r",
											"});\r",
											"\r",
											"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
											"    pm.expect(firstElement.condTp).to.be.eql(targetConditionResult.condTp);\r",
											"});\r",
											"\r",
											"if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
											"    pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
											"        pm.expect(firstElement.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
											"    });\r",
											"} else {    // if not, one must have been defaulted\r",
											"    pm.test(\"Result condition has a non-empty incptnDtTm\", function () {\r",
											"        pm.expect(firstElement.incptnDtTm).to.exist.and.not.be.empty;\r",
											"    });\r",
											"}\r",
											"\r",
											"if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
											"    pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
											"        pm.expect(firstElement.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
											"    });\r",
											"} else {    // if not, one must not have been defaulted\r",
											"    pm.test(\"Result condition does not have an xprtnDtTm\", function () {\r",
											"        pm.expect(firstElement.xprtnDtTm).to.not.exist;\r",
											"    });\r",
											"}\r",
											"\r",
											"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
											"    pm.expect(firstElement.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
											"});\r",
											"\r",
											"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
											"    pm.expect(firstElement.usr).to.be.eql(targetConditionResult.usr);\r",
											"});\r",
											"\r",
											"pm.test(\"Result condition has a non-empty creDtTm\", function () {\r",
											"    pm.expect(firstElement.creDtTm).to.exist.and.not.be.empty;\r",
											"});\r",
											"\r",
											"// create an array that only includes the perspective descriptions so that we can evaluate them easily\r",
											"let perspectives = firstElement.prsptvs.map(({ prsptv }) => prsptv);\r",
											"\r",
											"if (targetConditionResult.prsptv === \"both\") {\r",
											"    pm.test(\"Result prsptv array contains only 2 perspectives\", function () {\r",
											"        pm.expect(firstElement.prsptvs.length).to.be.eql(2);\r",
											"    });\r",
											"\r",
											"    let targetPerspectives = [\"governed_as_creditor_by\", \"governed_as_debtor_by\"];\r",
											"\r",
											"    pm.test(`Result prsptv array contains both ${JSON.stringify(targetPerspectives)} perspectives`, function () {\r",
											"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
											"    });\r",
											"\r",
											"} else if (targetConditionResult.prsptv === \"debtor\") {\r",
											"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
											"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
											"    });\r",
											"\r",
											"    let targetPerspectives = [\"governed_as_debtor_by\"];\r",
											"\r",
											"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
											"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
											"    });\r",
											"\r",
											"} else if (targetConditionResult.prsptv === \"creditor\") {\r",
											"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
											"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
											"    });\r",
											"\r",
											"    let targetPerspectives = [\"governed_as_creditor_by\"];\r",
											"\r",
											"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
											"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
											"    });\r",
											"\r",
											"};\r",
											"\r",
											"for (let i = 0; i < firstElement.prsptvs.length; i++) {   // for each perspective\r",
											"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} contains a non-empty evtTp array`, function () {\r",
											"        pm.expect(firstElement.prsptvs[i].evtTp).to.be.an('array').and.not.be.empty;\r",
											"    });\r",
											"\r",
											"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} evtTp array matches submitted condition`, function () {\r",
											"        pm.expect(firstElement.prsptvs[i].evtTp).to.include.members(targetConditionResult.evtTp);\r",
											"    });\r",
											"\r",
											"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
											"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches submitted condition`, function () {\r",
											"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
											"        });\r",
											"    } else {    // if not, one must have been defaulted\r",
											"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches created condition incptDtTm`, function () {\r",
											"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.eql(firstElement.incptnDtTm);\r",
											"        });\r",
											"    }\r",
											"\r",
											"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
											"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} xprtnDtTm matches submitted condition`, function () {\r",
											"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
											"        });\r",
											"    } else {    // if not, one must not have been defaulted\r",
											"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} does not have an xprtnDtTm`, function () {\r",
											"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.not.exist;\r",
											"        });\r",
											"    }\r",
											"\r",
											"}\r",
											"\r",
											"pm.test(\"Result condition ntty.id matches submitted condition\", function () {\r",
											"    pm.expect(conditionEntity.id).to.be.eql(targetConditionResult.ntty.id);\r",
											"});\r",
											"\r",
											"pm.test(\"Result condition ntty.schmeNm.prtry matches submitted condition\", function () {\r",
											"    pm.expect(conditionEntity.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
											"});\r",
											"\r",
											"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetEntityId, false);;\r",
											"\r",
											"await pm.sendRequest(postRequest, (error, response) => {\r",
											"    if (utils.getLogLevel() === 'DEBUG') {\r",
											"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
											"    }\r",
											"    databaseConditionResult = response.json().data;\r",
											"\r",
											"    if (utils.getLogLevel() === 'DEBUG') {\r",
											"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
											"    }\r",
											"\r",
											"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
											"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
											"\r",
											"    pm.test(`Only one condition for entity [${targetEntityId}] exists in the database`, function () {\r",
											"        pm.expect(graphConditionList.length).to.eql(1);\r",
											"    });\r",
											"\r",
											"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
											"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
											"            pm.expect(conditionGraph.v[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
											"        });\r",
											"    }\r",
											"\r",
											"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
											"        pm.expect(conditionGraph.v[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
											"        pm.expect(conditionGraph.v[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
											"    });\r",
											"\r",
											"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
											"        pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
											"            pm.expect(conditionGraph.v[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
											"        });\r",
											"    } else {    // if not, one must have been defaulted\r",
											"        pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
											"            pm.expect(conditionGraph.v[0].incptnDtTm).to.exist.and.not.be.empty;\r",
											"        });\r",
											"    }\r",
											"\r",
											"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
											"        pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
											"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
											"        });\r",
											"    } else {    // if not, one must not have been defaulted\r",
											"        pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
											"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.not.exist;\r",
											"        });\r",
											"    }\r",
											"\r",
											"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
											"        pm.expect(conditionGraph.v[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
											"        pm.expect(conditionGraph.v[0].ntty.id).to.be.eql(targetConditionResult.ntty.id);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
											"        pm.expect(conditionGraph.v[0].ntty.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
											"        pm.expect(conditionGraph.v[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
											"        pm.expect(conditionGraph.v[0].usr).to.be.eql(targetConditionResult.usr);\r",
											"    });\r",
											"\r",
											"    let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, conditionGraph.v[0]._key);\r",
											"\r",
											"    pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
											"        pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database 'governed_as_creditor_by' edge exists\", function () {\r",
											"        pm.expect(edgeList).to.include.members([\"governed_as_creditor_by\"]);\r",
											"    });\r",
											"\r",
											"    pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
											"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
											"    });\r",
											"\r",
											"    pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
											"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
											"    });\r",
											"\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction (in memory)\r",
											"messageSet = utils.createTransactionSetInMemory();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const tenantId = submittedPacs008Message.TenantId;\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"tenantId\", tenantId);\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = {\r",
											"  \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09\",\"pacs.008.001.10\",\"pacs.002.001.12\"],\r",
											"  \"condTp\":\"non-overridable-block\",\r",
											"  \"prsptv\":\"both\",\r",
											"  \"condRsn\":\"Default Test Condition\",\r",
											"  \"ntty\":\r",
											"  {\r",
											"    \"id\": `${dbtrNttyId.id}`,\r",
											"    \"schmeNm\":\r",
											"    {\r",
											"      \"prtry\":\"TAZAMA_EID\"\r",
											"    }\r",
											"  },\r",
											"  \"forceCret\":true,\r",
											"  \"usr\":\"POSTMAN\"\r",
											"}\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-entity-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create New Entity Condition - Existing debtor entity",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"let conditionResult = responseJSON.result.conditions;\r",
											"let conditionEntity = responseJSON.result.ntty;\r",
											"let requestMessage = responseJSON.message;\r",
											"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
											"let nttyId = pm.globals.get(\"dbtrNttyId\");\r",
											"let nttyIdSchme = pm.globals.get(\"dbtrNttyIdSchmeNm\");\r",
											"let tenantId = pm.globals.get(\"tenantId\");\r",
											"let targetEntityId = nttyId + nttyIdSchme;\r",
											"\r",
											"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
											"targetRequestMessage = \"New condition was saved successfully.\"\r",
											"\r",
											"pm.test(\"Status code is 200\", function () {\r",
											"    pm.response.to.have.status(200);\r",
											"});\r",
											"\r",
											"pm.test(\"Result message matches target result message\", function () {\r",
											"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
											"});\r",
											"\r",
											"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
											"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
											"});\r",
											"\r",
											"pm.test(\"Result conditions array only contains a single condition\", function () {\r",
											"    pm.expect(conditionResult.length).to.be.eql(1);\r",
											"});\r",
											"\r",
											"let firstElement = conditionResult[0];\r",
											"\r",
											"pm.test(\"Result condition has a non-empty condId\", function () {\r",
											"    pm.expect(firstElement.condId).to.exist.and.not.be.empty;\r",
											"});\r",
											"\r",
											"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
											"    pm.expect(firstElement.condTp).to.be.eql(targetConditionResult.condTp);\r",
											"});\r",
											"\r",
											"if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
											"    pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
											"        pm.expect(firstElement.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
											"    });\r",
											"} else {    // if not, one must have been defaulted\r",
											"    pm.test(\"Result condition has a non-empty incptnDtTm\", function () {\r",
											"        pm.expect(firstElement.incptnDtTm).to.exist.and.not.be.empty;\r",
											"    });\r",
											"}\r",
											"\r",
											"if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
											"    pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
											"        pm.expect(firstElement.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
											"    });\r",
											"} else {    // if not, one must not have been defaulted\r",
											"    pm.test(\"Result condition does not have an xprtnDtTm\", function () {\r",
											"        pm.expect(firstElement.xprtnDtTm).to.not.exist;\r",
											"    });\r",
											"}\r",
											"\r",
											"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
											"    pm.expect(firstElement.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
											"});\r",
											"\r",
											"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
											"    pm.expect(firstElement.usr).to.be.eql(targetConditionResult.usr);\r",
											"});\r",
											"\r",
											"pm.test(\"Result condition has a non-empty creDtTm\", function () {\r",
											"    pm.expect(firstElement.creDtTm).to.exist.and.not.be.empty;\r",
											"});\r",
											"\r",
											"// create an array that only includes the perspective descriptions so that we can evaluate them easily\r",
											"let perspectives = firstElement.prsptvs.map(({ prsptv }) => prsptv);\r",
											"\r",
											"if (targetConditionResult.prsptv === \"both\") {\r",
											"    pm.test(\"Result prsptv array contains only 2 perspectives\", function () {\r",
											"        pm.expect(firstElement.prsptvs.length).to.be.eql(2);\r",
											"    });\r",
											"\r",
											"    let targetPerspectives = [\"governed_as_creditor_by\", \"governed_as_debtor_by\"];\r",
											"\r",
											"    pm.test(`Result prsptv array contains both ${JSON.stringify(targetPerspectives)} perspectives`, function () {\r",
											"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
											"    });\r",
											"\r",
											"} else if (targetConditionResult.prsptv === \"debtor\") {\r",
											"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
											"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
											"    });\r",
											"\r",
											"    let targetPerspectives = [\"governed_as_debtor_by\"];\r",
											"\r",
											"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
											"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
											"    });\r",
											"\r",
											"} else if (targetConditionResult.prsptv === \"creditor\") {\r",
											"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
											"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
											"    });\r",
											"\r",
											"    let targetPerspectives = [\"governed_as_creditor_by\"];\r",
											"\r",
											"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
											"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
											"    });\r",
											"\r",
											"};\r",
											"\r",
											"for (let i = 0; i < firstElement.prsptvs.length; i++) {   // for each perspective\r",
											"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} contains a non-empty evtTp array`, function () {\r",
											"        pm.expect(firstElement.prsptvs[i].evtTp).to.be.an('array').and.not.be.empty;\r",
											"    });\r",
											"\r",
											"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} evtTp array matches submitted condition`, function () {\r",
											"        pm.expect(firstElement.prsptvs[i].evtTp).to.include.members(targetConditionResult.evtTp);\r",
											"    });\r",
											"\r",
											"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
											"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches submitted condition`, function () {\r",
											"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
											"        });\r",
											"    } else {    // if not, one must have been defaulted\r",
											"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches created condition incptDtTm`, function () {\r",
											"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.eql(firstElement.incptnDtTm);\r",
											"        });\r",
											"    }\r",
											"\r",
											"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
											"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} xprtnDtTm matches submitted condition`, function () {\r",
											"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
											"        });\r",
											"    } else {    // if not, one must not have been defaulted\r",
											"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} does not have an xprtnDtTm`, function () {\r",
											"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.not.exist;\r",
											"        });\r",
											"    }\r",
											"\r",
											"}\r",
											"\r",
											"pm.test(\"Result condition ntty.id matches submitted condition\", function () {\r",
											"    pm.expect(conditionEntity.id).to.be.eql(targetConditionResult.ntty.id);\r",
											"});\r",
											"\r",
											"pm.test(\"Result condition ntty.schmeNm.prtry matches submitted condition\", function () {\r",
											"    pm.expect(conditionEntity.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
											"});\r",
											"\r",
											"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetEntityId, false);;\r",
											"\r",
											"await pm.sendRequest(postRequest, (error, response) => {\r",
											"    if (utils.getLogLevel() === 'DEBUG') {\r",
											"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
											"    }\r",
											"    databaseConditionResult = response.json().data;\r",
											"\r",
											"    if (utils.getLogLevel() === 'DEBUG') {\r",
											"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
											"    }\r",
											"\r",
											"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
											"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
											"\r",
											"    pm.test(`Only one condition for entity [${targetEntityId}] exists in the database`, function () {\r",
											"        pm.expect(graphConditionList.length).to.eql(1);\r",
											"    });\r",
											"\r",
											"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
											"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
											"            pm.expect(conditionGraph.v[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
											"        });\r",
											"    }\r",
											"\r",
											"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
											"        pm.expect(conditionGraph.v[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
											"        pm.expect(conditionGraph.v[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
											"    });\r",
											"\r",
											"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
											"        pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
											"            pm.expect(conditionGraph.v[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
											"        });\r",
											"    } else {    // if not, one must have been defaulted\r",
											"        pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
											"            pm.expect(conditionGraph.v[0].incptnDtTm).to.exist.and.not.be.empty;\r",
											"        });\r",
											"    }\r",
											"\r",
											"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
											"        pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
											"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
											"        });\r",
											"    } else {    // if not, one must not have been defaulted\r",
											"        pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
											"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.not.exist;\r",
											"        });\r",
											"    }\r",
											"\r",
											"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
											"        pm.expect(conditionGraph.v[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
											"        pm.expect(conditionGraph.v[0].ntty.id).to.be.eql(targetConditionResult.ntty.id);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
											"        pm.expect(conditionGraph.v[0].ntty.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
											"        pm.expect(conditionGraph.v[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
											"        pm.expect(conditionGraph.v[0].usr).to.be.eql(targetConditionResult.usr);\r",
											"    });\r",
											"\r",
											"    let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, conditionGraph.v[0]._key);\r",
											"\r",
											"    pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
											"        pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database 'governed_as_creditor_by' edge exists\", function () {\r",
											"        pm.expect(edgeList).to.include.members([\"governed_as_creditor_by\"]);\r",
											"    });\r",
											"\r",
											"    pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
											"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
											"    });\r",
											"\r",
											"    pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
											"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
											"    });\r",
											"\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the global variables\r",
											"pm.globals.clear();\r",
											"\r",
											"// Set up the transaction (in the databases)\r",
											"messageSets = await utils.createTransactionSetsInDatabase();\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, messageSets[0].pacs008);\r",
											"\r",
											"// Stash the created pacs.008 message\r",
											"pm.globals.set(\"pacs008\", JSON.stringify(submittedPacs008Message));\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const tenantId = submittedPacs008Message.TenantId;\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"tenantId\", tenantId);\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = utils.getCreateEntityConditionBody(\r",
											"    /* Event Types */ null,             // null defaults ['pain.001.001.13', 'pain.013.001.09', 'pacs.008.01.10', 'pacs.002.01.11']\r",
											"    /* Condition Type */ null,          // null defaults 'non-overridable-block'\r",
											"    /* Perspetive */ null,              // null defaults 'both'\r",
											"    /* Inception Date */ null,          // null defaults now()\r",
											"    /* Expiration Date */ null,         // null defaults now() + 24 hours\r",
											"    /* Condition Reason */ null,        // null defaults 'Default Test Condition'\r",
											"    /* Entity */ dbtrNttyId,            // null defaults new unknown entity\r",
											"    /* Force Create */ false,           // null defaults true\r",
											"    /* User ID */ null                  // null defaults 'POSTMAN'\r",
											");\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', messageBody);\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-entity-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create Another New Entity Condition - Existing debtor entity",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"let conditionResult = responseJSON.result.conditions;\r",
											"let conditionEntity = responseJSON.result.ntty;\r",
											"let requestMessage = responseJSON.message;\r",
											"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
											"let nttyId = pm.globals.get(\"dbtrNttyId\");\r",
											"let nttyIdSchme = pm.globals.get(\"dbtrNttyIdSchmeNm\");\r",
											"let tenantId = pm.globals.get(\"tenantId\");\r",
											"let targetEntityId = nttyId + nttyIdSchme;\r",
											"\r",
											"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
											"targetRequestMessage = \"1 conditions already exist for the entity\"\r",
											"\r",
											"pm.test(\"Status code is 200\", function () {\r",
											"    pm.response.to.have.status(200);\r",
											"});\r",
											"\r",
											"pm.test(\"Result message matches target result message\", function () {\r",
											"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
											"});\r",
											"\r",
											"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
											"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
											"});\r",
											"\r",
											"pm.test(\"Result conditions array contains two conditions\", function () {\r",
											"    pm.expect(conditionResult.length).to.be.eql(2);\r",
											"});\r",
											"\r",
											"let newElement = conditionResult[conditionResult.length - 1];  // the last element is the newly submitted condition\r",
											"\r",
											"pm.test(\"Result condition has a non-empty condId\", function () {\r",
											"    pm.expect(newElement.condId).to.exist.and.not.be.empty;\r",
											"});\r",
											"\r",
											"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
											"    pm.expect(newElement.condTp).to.be.eql(targetConditionResult.condTp);\r",
											"});\r",
											"\r",
											"if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
											"    pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
											"        pm.expect(newElement.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
											"    });\r",
											"} else {    // if not, one must have been defaulted\r",
											"    pm.test(\"Result condition has a non-empty incptnDtTm\", function () {\r",
											"        pm.expect(newElement.incptnDtTm).to.exist.and.not.be.empty;\r",
											"    });\r",
											"}\r",
											"\r",
											"if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
											"    pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
											"        pm.expect(newElement.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
											"    });\r",
											"} else {    // if not, one must not have been defaulted\r",
											"    pm.test(\"Result condition does not have an xprtnDtTm\", function () {\r",
											"        pm.expect(newElement.xprtnDtTm).to.not.exist;\r",
											"    });\r",
											"}\r",
											"\r",
											"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
											"    pm.expect(newElement.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
											"});\r",
											"\r",
											"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
											"    pm.expect(newElement.usr).to.be.eql(targetConditionResult.usr);\r",
											"});\r",
											"\r",
											"pm.test(\"Result condition has a non-empty creDtTm\", function () {\r",
											"    pm.expect(newElement.creDtTm).to.exist.and.not.be.empty;\r",
											"});\r",
											"\r",
											"// create an array that only includes the perspective descriptions so that we can evaluate them easily\r",
											"let perspectives = newElement.prsptvs.map(({ prsptv }) => prsptv);\r",
											"\r",
											"if (targetConditionResult.prsptv === \"both\") {\r",
											"    pm.test(\"Result prsptv array contains only 2 perspectives\", function () {\r",
											"        pm.expect(newElement.prsptvs.length).to.be.eql(2);\r",
											"    });\r",
											"\r",
											"    let targetPerspectives = [\"governed_as_creditor_by\", \"governed_as_debtor_by\"];\r",
											"\r",
											"    pm.test(`Result prsptv array contains both ${JSON.stringify(targetPerspectives)} perspectives`, function () {\r",
											"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
											"    });\r",
											"\r",
											"} else if (targetConditionResult.prsptv === \"debtor\") {\r",
											"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
											"        pm.expect(newElement.prsptvs.length).to.be.eql(1);\r",
											"    });\r",
											"\r",
											"    let targetPerspectives = [\"governed_as_debtor_by\"];\r",
											"\r",
											"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
											"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
											"    });\r",
											"\r",
											"} else if (targetConditionResult.prsptv === \"creditor\") {\r",
											"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
											"        pm.expect(newElement.prsptvs.length).to.be.eql(1);\r",
											"    });\r",
											"\r",
											"    let targetPerspectives = [\"governed_as_creditor_by\"];\r",
											"\r",
											"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
											"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
											"    });\r",
											"\r",
											"};\r",
											"\r",
											"for (let i = 0; i < newElement.prsptvs.length; i++) {   // for each perspective\r",
											"    pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} contains a non-empty evtTp array`, function () {\r",
											"        pm.expect(newElement.prsptvs[i].evtTp).to.be.an('array').and.not.be.empty;\r",
											"    });\r",
											"\r",
											"    pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} evtTp array matches submitted condition`, function () {\r",
											"        pm.expect(newElement.prsptvs[i].evtTp).to.include.members(targetConditionResult.evtTp);\r",
											"    });\r",
											"\r",
											"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
											"        pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} incptnDtTm matches submitted condition`, function () {\r",
											"            pm.expect(newElement.prsptvs[i].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
											"        });\r",
											"    } else {    // if not, one must have been defaulted\r",
											"        pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} incptnDtTm matches created condition incptDtTm`, function () {\r",
											"            pm.expect(newElement.prsptvs[i].incptnDtTm).to.eql(newElement.incptnDtTm);\r",
											"        });\r",
											"    }\r",
											"\r",
											"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
											"        pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} xprtnDtTm matches submitted condition`, function () {\r",
											"            pm.expect(newElement.prsptvs[i].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
											"        });\r",
											"    } else {    // if not, one must not have been defaulted\r",
											"        pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} does not have an xprtnDtTm`, function () {\r",
											"            pm.expect(newElement.prsptvs[i].xprtnDtTm).to.not.exist;\r",
											"        });\r",
											"    }\r",
											"\r",
											"}\r",
											"\r",
											"pm.test(\"Result condition ntty.id matches submitted condition\", function () {\r",
											"    pm.expect(conditionEntity.id).to.be.eql(targetConditionResult.ntty.id);\r",
											"});\r",
											"\r",
											"pm.test(\"Result condition ntty.schmeNm.prtry matches submitted condition\", function () {\r",
											"    pm.expect(conditionEntity.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
											"});\r",
											"\r",
											"// Now we want to test that the data in the database matches the submitted data AND the response data\r",
											"\r",
											"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetEntityId, false);;\r",
											"\r",
											"await pm.sendRequest(postRequest, (error, response) => {\r",
											"    if (utils.getLogLevel() === 'DEBUG') {\r",
											"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
											"    }\r",
											"    databaseConditionResult = response.json().data;\r",
											"\r",
											"    if (utils.getLogLevel() === 'DEBUG') {\r",
											"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
											"    }\r",
											"\r",
											"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
											"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
											"\r",
											"    let submittedCondition = graphConditionList.filter(condition => condition._id === `conditions/${newElement.condId}`);\r",
											"\r",
											"    // First we check that the submitted condition matches the database version\r",
											"\r",
											"    pm.test(`Only two conditions for entity [${targetEntityId}] exists in the database`, function () {\r",
											"        pm.expect(graphConditionList.length).to.eql(2);\r",
											"    });\r",
											"\r",
											"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
											"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
											"            pm.expect(submittedCondition[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
											"        });\r",
											"    }\r",
											"\r",
											"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
											"        pm.expect(submittedCondition[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
											"        pm.expect(submittedCondition[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
											"    });\r",
											"\r",
											"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
											"        pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
											"            pm.expect(submittedCondition[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
											"        });\r",
											"    } else {    // if not, one must have been defaulted\r",
											"        pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
											"            pm.expect(submittedCondition[0].incptnDtTm).to.exist.and.not.be.empty;\r",
											"        });\r",
											"    }\r",
											"\r",
											"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
											"        pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
											"            pm.expect(submittedCondition[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
											"        });\r",
											"    } else {    // if not, one must not have been defaulted\r",
											"        pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
											"            pm.expect(submittedCondition[0].xprtnDtTm).to.not.exist;\r",
											"        });\r",
											"    }\r",
											"\r",
											"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
											"        pm.expect(submittedCondition[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
											"        pm.expect(submittedCondition[0].ntty.id).to.be.eql(targetConditionResult.ntty.id);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
											"        pm.expect(submittedCondition[0].ntty.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
											"        pm.expect(submittedCondition[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
											"        pm.expect(submittedCondition[0].usr).to.be.eql(targetConditionResult.usr);\r",
											"    });\r",
											"\r",
											"    let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, submittedCondition[0]._key);\r",
											"\r",
											"    pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
											"        pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Database 'governed_as_creditor_by' edge exists\", function () {\r",
											"        pm.expect(edgeList).to.include.members([\"governed_as_creditor_by\"]);\r",
											"    });\r",
											"\r",
											"    pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
											"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
											"    });\r",
											"\r",
											"    pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
											"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
											"    });\r",
											"\r",
											"    // Then we check the previous conditions in the response one-by-one against the database version\r",
											"    let previousConditionsFromResponse = graphConditionList.filter(condition => condition._id != `conditions/${newElement.condId}`);\r",
											"    let previousResponseConditionIds = previousConditionsFromResponse.map(({ condId }) => condId);\r",
											"    let previousConditionsFromDatabase = graphConditionList.filter(condition => condition._id != `conditions/${newElement.condId}`);\r",
											"    let previousDatabaseConditionIds = previousConditionsFromDatabase.map(({ condId }) => condId);\r",
											"\r",
											"    pm.test(`List of previous conditions in response match list of conditions from database`, function () {\r",
											"        pm.expect(previousResponseConditionIds).to.have.members(previousDatabaseConditionIds);\r",
											"    });\r",
											"\r",
											"    pm.test(`Only one previous condition for entity [${targetEntityId}] exists in the reponse`, function () {\r",
											"        pm.expect(previousConditionsFromResponse.length).to.eql(1);\r",
											"    });\r",
											"\r",
											"    pm.test(`Only one previous condition for entity [${targetEntityId}] exists in the database`, function () {\r",
											"        pm.expect(previousConditionsFromDatabase.length).to.eql(1);\r",
											"    });\r",
											"\r",
											"    for (let j = 0; j < previousConditionsFromResponse.length; j++) {\r",
											"\r",
											"        let justOneConditionFromResponse = previousConditionsFromResponse.filter(condition => condition._id === `conditions/${conditionResult[j].condId}`);\r",
											"        let sameConditionFromDatabase = previousConditionsFromDatabase.filter(condition => condition._id === `conditions/${conditionResult[j].condId}`);\r",
											"\r",
											"        for (let i = 0; i < sameConditionFromDatabase[0].evtTp.length; i++) {\r",
											"            pm.test(`Database condition.evtTp contains ${sameConditionFromDatabase[0].evtTp[i]}`, function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].evtTp).to.include.members([sameConditionFromDatabase[0].evtTp[i]]);\r",
											"            });\r",
											"        }\r",
											"\r",
											"        pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].condTp).to.be.eql(sameConditionFromDatabase[0].condTp);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].prsptv).to.be.eql(sameConditionFromDatabase[0].prsptv);\r",
											"        });\r",
											"\r",
											"        if (sameConditionFromDatabase[0].incptnDtTm) { // was an inception date specified?\r",
											"            pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].incptnDtTm).to.be.eql(sameConditionFromDatabase[0].incptnDtTm);\r",
											"            });\r",
											"        } else {    // if not, one must have been defaulted\r",
											"            pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].incptnDtTm).to.exist.and.not.be.empty;\r",
											"            });\r",
											"        }\r",
											"\r",
											"        if (sameConditionFromDatabase[0].xprtnDtTm) { // was an expiration date specified?\r",
											"            pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].xprtnDtTm).to.be.eql(sameConditionFromDatabase[0].xprtnDtTm);\r",
											"            });\r",
											"        } else {    // if not, one must not have been defaulted\r",
											"            pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].xprtnDtTm).to.not.exist;\r",
											"            });\r",
											"        }\r",
											"\r",
											"        pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].condRsn).to.be.eql(sameConditionFromDatabase[0].condRsn);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].ntty.id).to.be.eql(sameConditionFromDatabase[0].ntty.id);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].ntty.schmeNm.prtry).to.be.eql(sameConditionFromDatabase[0].ntty.schmeNm.prtry);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].forceCret).to.be.eql(sameConditionFromDatabase[0].forceCret);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].usr).to.be.eql(sameConditionFromDatabase[0].usr);\r",
											"        });\r",
											"\r",
											"        let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, justOneConditionFromResponse[0]._key);\r",
											"\r",
											"        pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
											"            pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database 'governed_as_creditor_by' edge exists\", function () {\r",
											"            pm.expect(edgeList).to.include.members([\"governed_as_creditor_by\"]);\r",
											"        });\r",
											"\r",
											"        pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
											"            pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
											"        });\r",
											"\r",
											"        pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
											"            pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
											"        });\r",
											"    }\r",
											"\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, JSON.parse(pm.globals.get(\"pacs008\")));\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const tenantId = submittedPacs008Message.TenantId;\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"tenantId\", tenantId);\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"// Set up the condition\r",
											"\r",
											"messageBody = utils.getCreateEntityConditionBody(\r",
											"    /* Event Types */ null,             // null defaults ['pain.001.001.13', 'pain.013.001.09', 'pacs.008.01.10', 'pacs.002.01.11']\r",
											"    /* Condition Type */ 'override',    // null defaults 'non-overridable-block'\r",
											"    /* Perspetive */ null,              // null defaults 'both'\r",
											"    /* Inception Date */ null,          // null defaults now()\r",
											"    /* Expiration Date */ null,         // null defaults now() + 24 hours\r",
											"    /* Condition Reason */ null,        // null defaults 'Default Test Condition'\r",
											"    /* Entity */ dbtrNttyId,            // null defaults new unknown entity\r",
											"    /* Force Create */ false,           // null defaults true\r",
											"    /* User ID */ null                  // null defaults 'POSTMAN'\r",
											");\r",
											"\r",
											"// Set up body variables\r",
											"pm.globals.set('messageBody', messageBody);\r",
											"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"{{path-entity-condition}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Fetch Entity Conditions - Existing entity - default scope",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"let conditionResult = responseJSON.conditions;\r",
											"pm.globals.set(\"conditions\", undefined); // obliterate current stashed conditions\r",
											"pm.globals.set(\"conditions\", JSON.stringify(conditionResult)); // stash response for future retrieval\r",
											"let conditionEntity = responseJSON.ntty;\r",
											"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
											"let nttyId = pm.globals.get(\"dbtrNttyId\");\r",
											"let nttyIdSchme = pm.globals.get(\"dbtrNttyIdSchmeNm\");\r",
											"let tenantId = pm.globals.get(\"tenantId\");\r",
											"let targetEntityId = nttyId + nttyIdSchme;\r",
											"\r",
											"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
											"\r",
											"pm.test(\"Status code is 200\", function () {\r",
											"    pm.response.to.have.status(200);\r",
											"});\r",
											"\r",
											"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
											"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
											"});\r",
											"\r",
											"pm.test(\"Result conditions array contains two conditions\", function () {\r",
											"    pm.expect(conditionResult.length).to.be.eql(2);\r",
											"});\r",
											"\r",
											"// We want to test that the data in the database matches the response data\r",
											"\r",
											"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetEntityId, false);;\r",
											"\r",
											"await pm.sendRequest(postRequest, (error, response) => {\r",
											"    if (utils.getLogLevel() === 'DEBUG') {\r",
											"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
											"    }\r",
											"    databaseConditionResult = response.json().data;\r",
											"\r",
											"    if (utils.getLogLevel() === 'DEBUG') {\r",
											"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
											"    }\r",
											"\r",
											"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
											"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
											"\r",
											"    // Check the previous conditions in the response one-by-one against the database version\r",
											"    let previousConditionsFromResponse = graphConditionList;\r",
											"    let previousResponseConditionIds = previousConditionsFromResponse.map(({ condId }) => condId);\r",
											"    let previousConditionsFromDatabase = graphConditionList;\r",
											"    let previousDatabaseConditionIds = previousConditionsFromDatabase.map(({ condId }) => condId);\r",
											"\r",
											"    pm.test(`List of previous conditions in response match list of conditions from database`, function () {\r",
											"        pm.expect(previousResponseConditionIds).to.have.members(previousDatabaseConditionIds);\r",
											"    });\r",
											"\r",
											"    pm.test(`Two conditions for entity [${targetEntityId}] exist in the reponse`, function () {\r",
											"        pm.expect(previousConditionsFromResponse.length).to.eql(2);\r",
											"    });\r",
											"\r",
											"    pm.test(`Two conditions for entity [${targetEntityId}] exist in the database`, function () {\r",
											"        pm.expect(previousConditionsFromDatabase.length).to.eql(2);\r",
											"    });\r",
											"\r",
											"    for (let j = 0; j < previousConditionsFromResponse.length; j++) {\r",
											"\r",
											"        let justOneConditionFromResponse = previousConditionsFromResponse.filter(condition => condition._id === `conditions/${conditionResult[j].condId}`);\r",
											"        let sameConditionFromDatabase = previousConditionsFromDatabase.filter(condition => condition._id === `conditions/${conditionResult[j].condId}`);\r",
											"\r",
											"        for (let i = 0; i < sameConditionFromDatabase[0].evtTp.length; i++) {\r",
											"            pm.test(`Database condition.evtTp contains ${sameConditionFromDatabase[0].evtTp[i]}`, function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].evtTp).to.include.members([sameConditionFromDatabase[0].evtTp[i]]);\r",
											"            });\r",
											"        }\r",
											"\r",
											"        pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].condTp).to.be.eql(sameConditionFromDatabase[0].condTp);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].prsptv).to.be.eql(sameConditionFromDatabase[0].prsptv);\r",
											"        });\r",
											"\r",
											"        if (sameConditionFromDatabase[0].incptnDtTm) { // was an inception date specified?\r",
											"            pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].incptnDtTm).to.be.eql(sameConditionFromDatabase[0].incptnDtTm);\r",
											"            });\r",
											"        } else {    // if not, one must have been defaulted\r",
											"            pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].incptnDtTm).to.exist.and.not.be.empty;\r",
											"            });\r",
											"        }\r",
											"\r",
											"        if (sameConditionFromDatabase[0].xprtnDtTm) { // was an expiration date specified?\r",
											"            pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].xprtnDtTm).to.be.eql(sameConditionFromDatabase[0].xprtnDtTm);\r",
											"            });\r",
											"        } else {    // if not, one must not have been defaulted\r",
											"            pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].xprtnDtTm).to.not.exist;\r",
											"            });\r",
											"        }\r",
											"\r",
											"        pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].condRsn).to.be.eql(sameConditionFromDatabase[0].condRsn);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].ntty.id).to.be.eql(sameConditionFromDatabase[0].ntty.id);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].ntty.schmeNm.prtry).to.be.eql(sameConditionFromDatabase[0].ntty.schmeNm.prtry);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].forceCret).to.be.eql(sameConditionFromDatabase[0].forceCret);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].usr).to.be.eql(sameConditionFromDatabase[0].usr);\r",
											"        });\r",
											"\r",
											"        let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, justOneConditionFromResponse[0]._key);\r",
											"\r",
											"        pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
											"            pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database 'governed_as_creditor_by' edge exists\", function () {\r",
											"            pm.expect(edgeList).to.include.members([\"governed_as_creditor_by\"]);\r",
											"        });\r",
											"\r",
											"        pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
											"            pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
											"        });\r",
											"\r",
											"        pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
											"            pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
											"        });\r",
											"    }\r",
											"\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, JSON.parse(pm.globals.get(\"pacs008\")));\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const tenantId = submittedPacs008Message.TenantId;\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"tenantId\", tenantId);\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"pm.globals.set(\"synccache\", \"no\");"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"protocolProfileBehavior": {
								"disableBodyPruning": true
							},
							"request": {
								"method": "GET",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/admin/event-flow-control/entity?id={{dbtrNttyId}}&schmenm={{dbtrNttyIdSchmeNm}}&synccache={{synccache}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"admin",
										"event-flow-control",
										"entity"
									],
									"query": [
										{
											"key": "id",
											"value": "{{dbtrNttyId}}"
										},
										{
											"key": "schmenm",
											"value": "{{dbtrNttyIdSchmeNm}}"
										},
										{
											"key": "synccache",
											"value": "{{synccache}}"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Fetch Entity Conditions - Existing entity - active only scope",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"let conditionResult = responseJSON.conditions;\r",
											"pm.globals.set(\"conditions\", undefined); // obliterate current stashed conditions\r",
											"pm.globals.set(\"conditions\", JSON.stringify(conditionResult)); // stash response for future retrieval\r",
											"let conditionEntity = responseJSON.ntty;\r",
											"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
											"let nttyId = pm.globals.get(\"dbtrNttyId\");\r",
											"let nttyIdSchme = pm.globals.get(\"dbtrNttyIdSchmeNm\");\r",
											"let tenantId = pm.globals.get(\"tenantId\");\r",
											"let targetEntityId = nttyId + nttyIdSchme;\r",
											"\r",
											"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
											"\r",
											"pm.test(\"Status code is 200\", function () {\r",
											"    pm.response.to.have.status(200);\r",
											"});\r",
											"\r",
											"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
											"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
											"});\r",
											"\r",
											"pm.test(\"Result conditions array contains two conditions\", function () {\r",
											"    pm.expect(conditionResult.length).to.be.eql(2);\r",
											"});\r",
											"\r",
											"// We want to test that the data in the database matches the response data\r",
											"\r",
											"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetEntityId, false);;\r",
											"\r",
											"await pm.sendRequest(postRequest, (error, response) => {\r",
											"    if (utils.getLogLevel() === 'DEBUG') {\r",
											"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
											"    }\r",
											"    databaseConditionResult = response.json().data;\r",
											"\r",
											"    if (utils.getLogLevel() === 'DEBUG') {\r",
											"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
											"    }\r",
											"\r",
											"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
											"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
											"\r",
											"    // Check the previous conditions in the response one-by-one against the database version\r",
											"    let previousConditionsFromResponse = graphConditionList;\r",
											"    let previousResponseConditionIds = previousConditionsFromResponse.map(({ condId }) => condId);\r",
											"    let previousConditionsFromDatabase = graphConditionList;\r",
											"    let previousDatabaseConditionIds = previousConditionsFromDatabase.map(({ condId }) => condId);\r",
											"\r",
											"    pm.test(`List of previous conditions in response match list of conditions from database`, function () {\r",
											"        pm.expect(previousResponseConditionIds).to.have.members(previousDatabaseConditionIds);\r",
											"    });\r",
											"\r",
											"    pm.test(`Two conditions for entity [${targetEntityId}] exist in the reponse`, function () {\r",
											"        pm.expect(previousConditionsFromResponse.length).to.eql(2);\r",
											"    });\r",
											"\r",
											"    pm.test(`Two conditios for entity [${targetEntityId}] exist in the database`, function () {\r",
											"        pm.expect(previousConditionsFromDatabase.length).to.eql(2);\r",
											"    });\r",
											"\r",
											"    for (let j = 0; j < previousConditionsFromResponse.length; j++) {\r",
											"\r",
											"        let justOneConditionFromResponse = previousConditionsFromResponse.filter(condition => condition._id === `conditions/${conditionResult[j].condId}`);\r",
											"        let sameConditionFromDatabase = previousConditionsFromDatabase.filter(condition => condition._id === `conditions/${conditionResult[j].condId}`);\r",
											"\r",
											"        for (let i = 0; i < sameConditionFromDatabase[0].evtTp.length; i++) {\r",
											"            pm.test(`Database condition.evtTp contains ${sameConditionFromDatabase[0].evtTp[i]}`, function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].evtTp).to.include.members([sameConditionFromDatabase[0].evtTp[i]]);\r",
											"            });\r",
											"        }\r",
											"\r",
											"        pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].condTp).to.be.eql(sameConditionFromDatabase[0].condTp);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].prsptv).to.be.eql(sameConditionFromDatabase[0].prsptv);\r",
											"        });\r",
											"\r",
											"        if (sameConditionFromDatabase[0].incptnDtTm) { // was an inception date specified?\r",
											"            pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].incptnDtTm).to.be.eql(sameConditionFromDatabase[0].incptnDtTm);\r",
											"            });\r",
											"        } else {    // if not, one must have been defaulted\r",
											"            pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].incptnDtTm).to.exist.and.not.be.empty;\r",
											"            });\r",
											"        }\r",
											"\r",
											"        if (sameConditionFromDatabase[0].xprtnDtTm) { // was an expiration date specified?\r",
											"            pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].xprtnDtTm).to.be.eql(sameConditionFromDatabase[0].xprtnDtTm);\r",
											"            });\r",
											"        } else {    // if not, one must not have been defaulted\r",
											"            pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].xprtnDtTm).to.not.exist;\r",
											"            });\r",
											"        }\r",
											"\r",
											"        pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].condRsn).to.be.eql(sameConditionFromDatabase[0].condRsn);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].ntty.id).to.be.eql(sameConditionFromDatabase[0].ntty.id);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].ntty.schmeNm.prtry).to.be.eql(sameConditionFromDatabase[0].ntty.schmeNm.prtry);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].forceCret).to.be.eql(sameConditionFromDatabase[0].forceCret);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].usr).to.be.eql(sameConditionFromDatabase[0].usr);\r",
											"        });\r",
											"\r",
											"        let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, justOneConditionFromResponse[0]._key);\r",
											"\r",
											"        pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
											"            pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database 'governed_as_creditor_by' edge exists\", function () {\r",
											"            pm.expect(edgeList).to.include.members([\"governed_as_creditor_by\"]);\r",
											"        });\r",
											"\r",
											"        pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
											"            pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
											"        });\r",
											"\r",
											"        pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
											"            pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
											"        });\r",
											"    }\r",
											"\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, JSON.parse(pm.globals.get(\"pacs008\")));\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const tenantId = submittedPacs008Message.TenantId;\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"tenantId\", tenantId);\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"pm.globals.set(\"synccache\", \"no\");"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"protocolProfileBehavior": {
								"disableBodyPruning": true
							},
							"request": {
								"method": "GET",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/admin/event-flow-control/entity?id={{dbtrNttyId}}&schmenm={{dbtrNttyIdSchmeNm}}&synccache={{synccache}}&activeonly=yes",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"admin",
										"event-flow-control",
										"entity"
									],
									"query": [
										{
											"key": "id",
											"value": "{{dbtrNttyId}}"
										},
										{
											"key": "schmenm",
											"value": "{{dbtrNttyIdSchmeNm}}"
										},
										{
											"key": "synccache",
											"value": "{{synccache}}"
										},
										{
											"key": "activeonly",
											"value": "yes"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Fetch Entity Conditions - Existing entity - complete scope",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"let conditionResult = responseJSON.conditions;\r",
											"pm.globals.set(\"conditions\", undefined); // obliterate current stashed conditions\r",
											"pm.globals.set(\"conditions\", JSON.stringify(conditionResult)); // stash response for future retrieval\r",
											"let conditionEntity = responseJSON.ntty;\r",
											"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
											"let nttyId = pm.globals.get(\"dbtrNttyId\");\r",
											"let nttyIdSchme = pm.globals.get(\"dbtrNttyIdSchmeNm\");\r",
											"let tenantId = pm.globals.get(\"tenantId\");\r",
											"let targetEntityId = nttyId + nttyIdSchme;\r",
											"\r",
											"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
											"\r",
											"pm.test(\"Status code is 200\", function () {\r",
											"    pm.response.to.have.status(200);\r",
											"});\r",
											"\r",
											"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
											"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
											"});\r",
											"\r",
											"pm.test(\"Result conditions array contains two conditions\", function () {\r",
											"    pm.expect(conditionResult.length).to.be.eql(2);\r",
											"});\r",
											"\r",
											"// We want to test that the data in the database matches the response data\r",
											"\r",
											"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetEntityId, false);;\r",
											"\r",
											"await pm.sendRequest(postRequest, (error, response) => {\r",
											"    if (utils.getLogLevel() === 'DEBUG') {\r",
											"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
											"    }\r",
											"    databaseConditionResult = response.json().data;\r",
											"\r",
											"    if (utils.getLogLevel() === 'DEBUG') {\r",
											"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
											"    }\r",
											"\r",
											"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
											"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
											"\r",
											"    // Check the previous conditions in the response one-by-one against the database version\r",
											"    let previousConditionsFromResponse = graphConditionList;\r",
											"    let previousResponseConditionIds = previousConditionsFromResponse.map(({ condId }) => condId);\r",
											"    let previousConditionsFromDatabase = graphConditionList;\r",
											"    let previousDatabaseConditionIds = previousConditionsFromDatabase.map(({ condId }) => condId);\r",
											"\r",
											"    pm.test(`List of previous conditions in response match list of conditions from database`, function () {\r",
											"        pm.expect(previousResponseConditionIds).to.have.members(previousDatabaseConditionIds);\r",
											"    });\r",
											"\r",
											"    pm.test(`Two conditions for entity [${targetEntityId}] exist in the reponse`, function () {\r",
											"        pm.expect(previousConditionsFromResponse.length).to.eql(2);\r",
											"    });\r",
											"\r",
											"    pm.test(`Two conditions for entity [${targetEntityId}] exist in the database`, function () {\r",
											"        pm.expect(previousConditionsFromDatabase.length).to.eql(2);\r",
											"    });\r",
											"\r",
											"    for (let j = 0; j < previousConditionsFromResponse.length; j++) {\r",
											"\r",
											"        let justOneConditionFromResponse = previousConditionsFromResponse.filter(condition => condition._id === `conditions/${conditionResult[j].condId}`);\r",
											"        let sameConditionFromDatabase = previousConditionsFromDatabase.filter(condition => condition._id === `conditions/${conditionResult[j].condId}`);\r",
											"\r",
											"        for (let i = 0; i < sameConditionFromDatabase[0].evtTp.length; i++) {\r",
											"            pm.test(`Database condition.evtTp contains ${sameConditionFromDatabase[0].evtTp[i]}`, function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].evtTp).to.include.members([sameConditionFromDatabase[0].evtTp[i]]);\r",
											"            });\r",
											"        }\r",
											"\r",
											"        pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].condTp).to.be.eql(sameConditionFromDatabase[0].condTp);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].prsptv).to.be.eql(sameConditionFromDatabase[0].prsptv);\r",
											"        });\r",
											"\r",
											"        if (sameConditionFromDatabase[0].incptnDtTm) { // was an inception date specified?\r",
											"            pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].incptnDtTm).to.be.eql(sameConditionFromDatabase[0].incptnDtTm);\r",
											"            });\r",
											"        } else {    // if not, one must have been defaulted\r",
											"            pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].incptnDtTm).to.exist.and.not.be.empty;\r",
											"            });\r",
											"        }\r",
											"\r",
											"        if (sameConditionFromDatabase[0].xprtnDtTm) { // was an expiration date specified?\r",
											"            pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].xprtnDtTm).to.be.eql(sameConditionFromDatabase[0].xprtnDtTm);\r",
											"            });\r",
											"        } else {    // if not, one must not have been defaulted\r",
											"            pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].xprtnDtTm).to.not.exist;\r",
											"            });\r",
											"        }\r",
											"\r",
											"        pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].condRsn).to.be.eql(sameConditionFromDatabase[0].condRsn);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].ntty.id).to.be.eql(sameConditionFromDatabase[0].ntty.id);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].ntty.schmeNm.prtry).to.be.eql(sameConditionFromDatabase[0].ntty.schmeNm.prtry);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].forceCret).to.be.eql(sameConditionFromDatabase[0].forceCret);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].usr).to.be.eql(sameConditionFromDatabase[0].usr);\r",
											"        });\r",
											"\r",
											"        let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, justOneConditionFromResponse[0]._key);\r",
											"\r",
											"        pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
											"            pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database 'governed_as_creditor_by' edge exists\", function () {\r",
											"            pm.expect(edgeList).to.include.members([\"governed_as_creditor_by\"]);\r",
											"        });\r",
											"\r",
											"        pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
											"            pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
											"        });\r",
											"\r",
											"        pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
											"            pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
											"        });\r",
											"    }\r",
											"\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, JSON.parse(pm.globals.get(\"pacs008\")));\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const tenantId = submittedPacs008Message.TenantId;\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"tenantId\", tenantId);\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"pm.globals.set(\"synccache\", \"no\");"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"protocolProfileBehavior": {
								"disableBodyPruning": true
							},
							"request": {
								"method": "GET",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/admin/event-flow-control/entity?id={{dbtrNttyId}}&schmenm={{dbtrNttyIdSchmeNm}}&synccache={{synccache}}&activeonly=no",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"admin",
										"event-flow-control",
										"entity"
									],
									"query": [
										{
											"key": "id",
											"value": "{{dbtrNttyId}}"
										},
										{
											"key": "schmenm",
											"value": "{{dbtrNttyIdSchmeNm}}"
										},
										{
											"key": "synccache",
											"value": "{{synccache}}"
										},
										{
											"key": "activeonly",
											"value": "no"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Update Entity Condition - Existing condition",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Obliterate the current contents of the pacs008 global variable\r",
											"pm.globals.set(\"dbtrNttyId\", undefined);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", undefined);\r",
											"pm.globals.set(\"dbtrAcctId\", undefined);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", undefined);\r",
											"pm.globals.set(\"dbtrAgt\", undefined);\r",
											"pm.globals.set(\"cdtrNttyId\", undefined);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", undefined);\r",
											"pm.globals.set(\"cdtrAcctId\", undefined);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", undefined);\r",
											"pm.globals.set(\"cdtrAgt\", undefined);\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, JSON.parse(pm.globals.get(\"pacs008\")));\r",
											"\r",
											"// Create identifier variables from the pacs.008 message\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const tenantId = submittedPacs008Message.TenantId;\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"tenantId\", tenantId);\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"pm.globals.set(\"syncCache\", \"no\");\r",
											"\r",
											"// Fetch stashed conditions\r",
											"const conditions = JSON.parse(pm.globals.get(\"conditions\"));\r",
											"\r",
											"// Select and stash a condition ID\r",
											"pm.globals.set(\"condId\", conditions[0].condId);\r",
											"\r",
											"// Specify the expiration date (yyyy-mm-ddThh:mm:ss.sssZ)\r",
											"var rightNow = new Date();\r",
											"rightNow.setSeconds(rightNow.getSeconds() + 1);\r",
											"// rightNow.setHours(rightNow.getHours() + 1);\r",
											"xprtnDtTm = rightNow.toISOString();\r",
											"const messageBody = { \"xprtnDtTm\": xprtnDtTm }\r",
											"// pm.globals.set(\"xprtnDtTm\", undefined);\r",
											"// pm.globals.set(\"xprtnDtTm\", utils.getTimestampNow());\r",
											"// pm.globals.set(\"xprtnDtTm\", \"2024-09-20T12:00:00.000Z\");\r",
											"\r",
											"\r",
											"pm.globals.set(\"messageBody\", JSON.stringify(messageBody));"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"let nttyId = pm.globals.get(\"dbtrNttyId\");\r",
											"let nttyIdSchme = pm.globals.get(\"dbtrNttyIdSchmeNm\");\r",
											"let tenantId = pm.globals.get(\"tenantId\");\r",
											"let targetEntityId = nttyId + nttyIdSchme;\r",
											"let targetConditionId = pm.globals.get(\"condId\");\r",
											"let targetXprtnDtTm = JSON.parse(pm.globals.get(\"messageBody\")).xprtnDtTm;\r",
											"let targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
											"\r",
											"pm.test(\"Status code is 200\", function () {\r",
											"    pm.response.to.have.status(200);\r",
											"});\r",
											"\r",
											"// We want to test that the condition in the database is updated\r",
											"\r",
											"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetEntityId, false);;\r",
											"\r",
											"await pm.sendRequest(postRequest, (error, response) => {\r",
											"    if (utils.getLogLevel() === 'DEBUG') {\r",
											"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
											"    }\r",
											"    databaseConditionResult = response.json().data;\r",
											"\r",
											"    if (utils.getLogLevel() === 'DEBUG') {\r",
											"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
											"    }\r",
											"\r",
											"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
											"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
											"\r",
											"    let updatedCondition = graphConditionList.filter(condition => condition._id === `conditions/${targetConditionId}`);\r",
											"    let nonUpdatedConditions = graphConditionList.filter(condition => condition._id != `conditions/${targetConditionId}`);\r",
											"\r",
											"    pm.test(`The xprntDtTm in condId ${targetConditionId} has been updated to ${targetXprtnDtTm}`, function () {\r",
											"        pm.expect(updatedCondition[0].xprtnDtTm).to.eql(targetXprtnDtTm);\r",
											"    });\r",
											"\r",
											"    pm.test(`No other condition xprtnDtTm is updated`, function () {\r",
											"        pm.expect(nonUpdatedConditions.filter(cond => cond.xprtnDtTm === targetXprtnDtTm).length).to.eql(0);\r",
											"    });\r",
											"\r",
											"    let perspectives = utils.getConditionPerspectivesFromGraph(conditionGraph, updatedCondition[0]._key, \"all\");\r",
											"\r",
											"    // Check that the edges are updated\r",
											"    for (let i = 0; i < perspectives.length; i++) {\r",
											"        pm.test(`The xprntDtTm in condId ${targetConditionId} for perspective ${perspectives[i]._id} has been updated to ${targetXprtnDtTm}`, function () {\r",
											"            pm.expect(perspectives[i].xprtnDtTm).to.eql(targetXprtnDtTm);\r",
											"        });\r",
											"    }\r",
											"\r",
											"    // Check that none of the other edges have been updated\r",
											"    for (let i = 0; i < nonUpdatedConditions.length; i++) {\r",
											"\r",
											"        perspectives = utils.getConditionPerspectivesFromGraph(conditionGraph, nonUpdatedConditions[i]._key, \"all\");\r",
											"\r",
											"        // Check that the other edges are not updated\r",
											"        for (let j = 0; j < perspectives.length; j++) {\r",
											"            pm.test(`The xprntDtTm in condId ${nonUpdatedConditions[i]._key} for perspective ${perspectives[j]._id} has not been updated to ${targetXprtnDtTm}`, function () {\r",
											"                pm.expect(perspectives.xprtnDtTm).to.not.eql(targetXprtnDtTm);\r",
											"            });\r",
											"        }\r",
											"    }\r",
											"\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "PUT",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/admin/event-flow-control/entity?id={{dbtrNttyId}}&schmenm={{dbtrNttyIdSchmeNm}}&condid={{condId}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"admin",
										"event-flow-control",
										"entity"
									],
									"query": [
										{
											"key": "id",
											"value": "{{dbtrNttyId}}"
										},
										{
											"key": "schmenm",
											"value": "{{dbtrNttyIdSchmeNm}}"
										},
										{
											"key": "condid",
											"value": "{{condId}}"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Fetch Entity Conditions - Existing entity - after update - default scope",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"let conditionResult = responseJSON.conditions;\r",
											"pm.globals.set(\"conditions\", undefined); // obliterate current stashed conditions\r",
											"pm.globals.set(\"conditions\", JSON.stringify(conditionResult)); // stash response for future retrieval\r",
											"let conditionEntity = responseJSON.ntty;\r",
											"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
											"let nttyId = pm.globals.get(\"dbtrNttyId\");\r",
											"let nttyIdSchme = pm.globals.get(\"dbtrNttyIdSchmeNm\");\r",
											"let tenantId = pm.globals.get(\"tenantId\");\r",
											"let targetEntityId = nttyId + nttyIdSchme;\r",
											"\r",
											"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
											"\r",
											"pm.test(\"Status code is 200\", function () {\r",
											"    pm.response.to.have.status(200);\r",
											"});\r",
											"\r",
											"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
											"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
											"});\r",
											"\r",
											"pm.test(\"Result conditions array contains two conditions\", function () {\r",
											"    pm.expect(conditionResult.length).to.be.eql(2);\r",
											"});\r",
											"\r",
											"// We want to test that the data in the database matches the response data\r",
											"\r",
											"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetEntityId, false);;\r",
											"\r",
											"await pm.sendRequest(postRequest, (error, response) => {\r",
											"    if (utils.getLogLevel() === 'DEBUG') {\r",
											"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
											"    }\r",
											"    databaseConditionResult = response.json().data;\r",
											"\r",
											"    if (utils.getLogLevel() === 'DEBUG') {\r",
											"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
											"    }\r",
											"\r",
											"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
											"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
											"\r",
											"    // Check the previous conditions in the response one-by-one against the database version\r",
											"    let previousConditionsFromResponse = graphConditionList;\r",
											"    let previousResponseConditionIds = previousConditionsFromResponse.map(({ condId }) => condId);\r",
											"    let previousConditionsFromDatabase = graphConditionList;\r",
											"    let previousDatabaseConditionIds = previousConditionsFromDatabase.map(({ condId }) => condId);\r",
											"\r",
											"    pm.test(`List of previous conditions in response match list of conditions from database`, function () {\r",
											"        pm.expect(previousResponseConditionIds).to.have.members(previousDatabaseConditionIds);\r",
											"    });\r",
											"\r",
											"    pm.test(`Two conditions for entity [${targetEntityId}] exist in the reponse`, function () {\r",
											"        pm.expect(previousConditionsFromResponse.length).to.eql(2);\r",
											"    });\r",
											"\r",
											"    pm.test(`Two conditions for entity [${targetEntityId}] exist in the database`, function () {\r",
											"        pm.expect(previousConditionsFromDatabase.length).to.eql(2);\r",
											"    });\r",
											"\r",
											"    for (let j = 0; j < previousConditionsFromResponse.length; j++) {\r",
											"\r",
											"        let justOneConditionFromResponse = previousConditionsFromResponse.filter(condition => condition._id === `conditions/${conditionResult[j].condId}`);\r",
											"        let sameConditionFromDatabase = previousConditionsFromDatabase.filter(condition => condition._id === `conditions/${conditionResult[j].condId}`);\r",
											"\r",
											"        for (let i = 0; i < sameConditionFromDatabase[0].evtTp.length; i++) {\r",
											"            pm.test(`Database condition.evtTp contains ${sameConditionFromDatabase[0].evtTp[i]}`, function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].evtTp).to.include.members([sameConditionFromDatabase[0].evtTp[i]]);\r",
											"            });\r",
											"        }\r",
											"\r",
											"        pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].condTp).to.be.eql(sameConditionFromDatabase[0].condTp);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].prsptv).to.be.eql(sameConditionFromDatabase[0].prsptv);\r",
											"        });\r",
											"\r",
											"        if (sameConditionFromDatabase[0].incptnDtTm) { // was an inception date specified?\r",
											"            pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].incptnDtTm).to.be.eql(sameConditionFromDatabase[0].incptnDtTm);\r",
											"            });\r",
											"        } else {    // if not, one must have been defaulted\r",
											"            pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].incptnDtTm).to.exist.and.not.be.empty;\r",
											"            });\r",
											"        }\r",
											"\r",
											"        if (sameConditionFromDatabase[0].xprtnDtTm) { // was an expiration date specified?\r",
											"            pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].xprtnDtTm).to.be.eql(sameConditionFromDatabase[0].xprtnDtTm);\r",
											"            });\r",
											"        } else {    // if not, one must not have been defaulted\r",
											"            pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].xprtnDtTm).to.not.exist;\r",
											"            });\r",
											"        }\r",
											"\r",
											"        pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].condRsn).to.be.eql(sameConditionFromDatabase[0].condRsn);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].ntty.id).to.be.eql(sameConditionFromDatabase[0].ntty.id);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].ntty.schmeNm.prtry).to.be.eql(sameConditionFromDatabase[0].ntty.schmeNm.prtry);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].forceCret).to.be.eql(sameConditionFromDatabase[0].forceCret);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].usr).to.be.eql(sameConditionFromDatabase[0].usr);\r",
											"        });\r",
											"\r",
											"        let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, justOneConditionFromResponse[0]._key);\r",
											"\r",
											"        pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
											"            pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database 'governed_as_creditor_by' edge exists\", function () {\r",
											"            pm.expect(edgeList).to.include.members([\"governed_as_creditor_by\"]);\r",
											"        });\r",
											"\r",
											"        pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
											"            pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
											"        });\r",
											"\r",
											"        pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
											"            pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
											"        });\r",
											"    }\r",
											"\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, JSON.parse(pm.globals.get(\"pacs008\")));\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const tenantId = submittedPacs008Message.TenantId;\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"tenantId\", tenantId);\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"pm.globals.set(\"synccache\", \"no\");"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"protocolProfileBehavior": {
								"disableBodyPruning": true
							},
							"request": {
								"method": "GET",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/admin/event-flow-control/entity?id={{dbtrNttyId}}&schmenm={{dbtrNttyIdSchmeNm}}&synccache={{synccache}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"admin",
										"event-flow-control",
										"entity"
									],
									"query": [
										{
											"key": "id",
											"value": "{{dbtrNttyId}}"
										},
										{
											"key": "schmenm",
											"value": "{{dbtrNttyIdSchmeNm}}"
										},
										{
											"key": "synccache",
											"value": "{{synccache}}"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Fetch Entity Conditions - Existing entity - after update - active only scope",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"let conditionResult = responseJSON.conditions;\r",
											"pm.globals.set(\"conditions\", undefined); // obliterate current stashed conditions\r",
											"pm.globals.set(\"conditions\", JSON.stringify(conditionResult)); // stash response for future retrieval\r",
											"let conditionEntity = responseJSON.ntty;\r",
											"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
											"let nttyId = pm.globals.get(\"dbtrNttyId\");\r",
											"let nttyIdSchme = pm.globals.get(\"dbtrNttyIdSchmeNm\");\r",
											"let tenantId = pm.globals.get(\"tenantId\");\r",
											"let targetEntityId = nttyId + nttyIdSchme;\r",
											"\r",
											"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
											"\r",
											"pm.test(\"Status code is 200\", function () {\r",
											"    pm.response.to.have.status(200);\r",
											"});\r",
											"\r",
											"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
											"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
											"});\r",
											"\r",
											"pm.test(\"Result conditions array contains one condition\", function () {\r",
											"    pm.expect(conditionResult.length).to.be.eql(1);\r",
											"});\r",
											"\r",
											"// We want to test that the data in the database matches the response data\r",
											"\r",
											"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetEntityId, true);\r",
											"\r",
											"await pm.sendRequest(postRequest, (error, response) => {\r",
											"    if (utils.getLogLevel() === 'DEBUG') {\r",
											"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
											"    }\r",
											"    databaseConditionResult = response.json().data;\r",
											"\r",
											"    if (utils.getLogLevel() === 'DEBUG') {\r",
											"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
											"    }\r",
											"\r",
											"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
											"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
											"\r",
											"    // Check the previous conditions in the response one-by-one against the database version\r",
											"    let previousConditionsFromResponse = graphConditionList;\r",
											"    let previousResponseConditionIds = previousConditionsFromResponse.map(({ condId }) => condId);\r",
											"    let previousConditionsFromDatabase = graphConditionList;\r",
											"    let previousDatabaseConditionIds = previousConditionsFromDatabase.map(({ condId }) => condId);\r",
											"\r",
											"    pm.test(`List of previous conditions in response match list of conditions from database`, function () {\r",
											"        pm.expect(previousResponseConditionIds).to.have.members(previousDatabaseConditionIds);\r",
											"    });\r",
											"\r",
											"    pm.test(`One active condition for entity [${targetEntityId}] exists in the reponse`, function () {\r",
											"        pm.expect(previousConditionsFromResponse.length).to.eql(1);\r",
											"    });\r",
											"\r",
											"    pm.test(`One active condition for entity [${targetEntityId}] exists in the database`, function () {\r",
											"        pm.expect(previousConditionsFromDatabase.length).to.eql(1);\r",
											"    });\r",
											"\r",
											"    for (let j = 0; j < previousConditionsFromResponse.length; j++) {\r",
											"\r",
											"        let justOneConditionFromResponse = previousConditionsFromResponse.filter(condition => condition._id === `conditions/${conditionResult[j].condId}`);\r",
											"        let sameConditionFromDatabase = previousConditionsFromDatabase.filter(condition => condition._id === `conditions/${conditionResult[j].condId}`);\r",
											"\r",
											"        for (let i = 0; i < sameConditionFromDatabase[0].evtTp.length; i++) {\r",
											"            pm.test(`Database condition.evtTp contains ${sameConditionFromDatabase[0].evtTp[i]}`, function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].evtTp).to.include.members([sameConditionFromDatabase[0].evtTp[i]]);\r",
											"            });\r",
											"        }\r",
											"\r",
											"        pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].condTp).to.be.eql(sameConditionFromDatabase[0].condTp);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].prsptv).to.be.eql(sameConditionFromDatabase[0].prsptv);\r",
											"        });\r",
											"\r",
											"        if (sameConditionFromDatabase[0].incptnDtTm) { // was an inception date specified?\r",
											"            pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].incptnDtTm).to.be.eql(sameConditionFromDatabase[0].incptnDtTm);\r",
											"            });\r",
											"        } else {    // if not, one must have been defaulted\r",
											"            pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].incptnDtTm).to.exist.and.not.be.empty;\r",
											"            });\r",
											"        }\r",
											"\r",
											"        if (sameConditionFromDatabase[0].xprtnDtTm) { // was an expiration date specified?\r",
											"            pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].xprtnDtTm).to.be.eql(sameConditionFromDatabase[0].xprtnDtTm);\r",
											"            });\r",
											"        } else {    // if not, one must not have been defaulted\r",
											"            pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].xprtnDtTm).to.not.exist;\r",
											"            });\r",
											"        }\r",
											"\r",
											"        pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].condRsn).to.be.eql(sameConditionFromDatabase[0].condRsn);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].ntty.id).to.be.eql(sameConditionFromDatabase[0].ntty.id);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].ntty.schmeNm.prtry).to.be.eql(sameConditionFromDatabase[0].ntty.schmeNm.prtry);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].forceCret).to.be.eql(sameConditionFromDatabase[0].forceCret);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].usr).to.be.eql(sameConditionFromDatabase[0].usr);\r",
											"        });\r",
											"\r",
											"        let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, justOneConditionFromResponse[0]._key);\r",
											"\r",
											"        pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
											"            pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database 'governed_as_creditor_by' edge exists\", function () {\r",
											"            pm.expect(edgeList).to.include.members([\"governed_as_creditor_by\"]);\r",
											"        });\r",
											"\r",
											"        pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
											"            pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
											"        });\r",
											"\r",
											"        pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
											"            pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
											"        });\r",
											"    }\r",
											"\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, JSON.parse(pm.globals.get(\"pacs008\")));\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const tenantId = submittedPacs008Message.TenantId;\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"tenantId\", tenantId);\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"pm.globals.set(\"synccache\", \"no\");"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"protocolProfileBehavior": {
								"disableBodyPruning": true
							},
							"request": {
								"method": "GET",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/admin/event-flow-control/entity?id={{dbtrNttyId}}&schmenm={{dbtrNttyIdSchmeNm}}&synccache={{synccache}}&activeonly=yes",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"admin",
										"event-flow-control",
										"entity"
									],
									"query": [
										{
											"key": "id",
											"value": "{{dbtrNttyId}}"
										},
										{
											"key": "schmenm",
											"value": "{{dbtrNttyIdSchmeNm}}"
										},
										{
											"key": "synccache",
											"value": "{{synccache}}"
										},
										{
											"key": "activeonly",
											"value": "yes"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Fetch Entity Conditions - Existing entity - after update - complete scope",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"responseJSON = pm.response.json();\r",
											"let conditionResult = responseJSON.conditions;\r",
											"pm.globals.set(\"conditions\", undefined); // obliterate current stashed conditions\r",
											"pm.globals.set(\"conditions\", JSON.stringify(conditionResult)); // stash response for future retrieval\r",
											"let conditionEntity = responseJSON.ntty;\r",
											"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
											"let nttyId = pm.globals.get(\"dbtrNttyId\");\r",
											"let nttyIdSchme = pm.globals.get(\"dbtrNttyIdSchmeNm\");\r",
											"let tenantId = pm.globals.get(\"tenantId\");\r",
											"let targetEntityId = nttyId + nttyIdSchme;\r",
											"\r",
											"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
											"\r",
											"pm.test(\"Status code is 200\", function () {\r",
											"    pm.response.to.have.status(200);\r",
											"});\r",
											"\r",
											"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
											"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
											"});\r",
											"\r",
											"pm.test(\"Result conditions array contains two conditions\", function () {\r",
											"    pm.expect(conditionResult.length).to.be.eql(2);\r",
											"});\r",
											"\r",
											"// We want to test that the data in the database matches the response data\r",
											"\r",
											"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetEntityId, false);;\r",
											"\r",
											"await pm.sendRequest(postRequest, (error, response) => {\r",
											"    if (utils.getLogLevel() === 'DEBUG') {\r",
											"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
											"    }\r",
											"    databaseConditionResult = response.json().data;\r",
											"\r",
											"    if (utils.getLogLevel() === 'DEBUG') {\r",
											"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
											"    }\r",
											"\r",
											"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
											"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
											"\r",
											"    // Check the previous conditions in the response one-by-one against the database version\r",
											"    let previousConditionsFromResponse = graphConditionList;\r",
											"    let previousResponseConditionIds = previousConditionsFromResponse.map(({ condId }) => condId);\r",
											"    let previousConditionsFromDatabase = graphConditionList;\r",
											"    let previousDatabaseConditionIds = previousConditionsFromDatabase.map(({ condId }) => condId);\r",
											"\r",
											"    pm.test(`List of previous conditions in response match list of conditions from database`, function () {\r",
											"        pm.expect(previousResponseConditionIds).to.have.members(previousDatabaseConditionIds);\r",
											"    });\r",
											"\r",
											"    pm.test(`Two previous conditions for entity [${targetEntityId}] exist in the reponse`, function () {\r",
											"        pm.expect(previousConditionsFromResponse.length).to.eql(2);\r",
											"    });\r",
											"\r",
											"    pm.test(`Two previous conditions for entity [${targetEntityId}] exist in the database`, function () {\r",
											"        pm.expect(previousConditionsFromDatabase.length).to.eql(2);\r",
											"    });\r",
											"\r",
											"    for (let j = 0; j < previousConditionsFromResponse.length; j++) {\r",
											"\r",
											"        let justOneConditionFromResponse = previousConditionsFromResponse.filter(condition => condition._id === `conditions/${conditionResult[j].condId}`);\r",
											"        let sameConditionFromDatabase = previousConditionsFromDatabase.filter(condition => condition._id === `conditions/${conditionResult[j].condId}`);\r",
											"\r",
											"        for (let i = 0; i < sameConditionFromDatabase[0].evtTp.length; i++) {\r",
											"            pm.test(`Database condition.evtTp contains ${sameConditionFromDatabase[0].evtTp[i]}`, function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].evtTp).to.include.members([sameConditionFromDatabase[0].evtTp[i]]);\r",
											"            });\r",
											"        }\r",
											"\r",
											"        pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].condTp).to.be.eql(sameConditionFromDatabase[0].condTp);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].prsptv).to.be.eql(sameConditionFromDatabase[0].prsptv);\r",
											"        });\r",
											"\r",
											"        if (sameConditionFromDatabase[0].incptnDtTm) { // was an inception date specified?\r",
											"            pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].incptnDtTm).to.be.eql(sameConditionFromDatabase[0].incptnDtTm);\r",
											"            });\r",
											"        } else {    // if not, one must have been defaulted\r",
											"            pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].incptnDtTm).to.exist.and.not.be.empty;\r",
											"            });\r",
											"        }\r",
											"\r",
											"        if (sameConditionFromDatabase[0].xprtnDtTm) { // was an expiration date specified?\r",
											"            pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].xprtnDtTm).to.be.eql(sameConditionFromDatabase[0].xprtnDtTm);\r",
											"            });\r",
											"        } else {    // if not, one must not have been defaulted\r",
											"            pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
											"                pm.expect(justOneConditionFromResponse[0].xprtnDtTm).to.not.exist;\r",
											"            });\r",
											"        }\r",
											"\r",
											"        pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].condRsn).to.be.eql(sameConditionFromDatabase[0].condRsn);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].ntty.id).to.be.eql(sameConditionFromDatabase[0].ntty.id);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].ntty.schmeNm.prtry).to.be.eql(sameConditionFromDatabase[0].ntty.schmeNm.prtry);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].forceCret).to.be.eql(sameConditionFromDatabase[0].forceCret);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
											"            pm.expect(justOneConditionFromResponse[0].usr).to.be.eql(sameConditionFromDatabase[0].usr);\r",
											"        });\r",
											"\r",
											"        let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, justOneConditionFromResponse[0]._key);\r",
											"\r",
											"        pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
											"            pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
											"        });\r",
											"\r",
											"        pm.test(\"Database 'governed_as_creditor_by' edge exists\", function () {\r",
											"            pm.expect(edgeList).to.include.members([\"governed_as_creditor_by\"]);\r",
											"        });\r",
											"\r",
											"        pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
											"            pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
											"        });\r",
											"\r",
											"        pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
											"            pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
											"        });\r",
											"    }\r",
											"\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
											"\r",
											"// Retrieve the created pacs.008 message\r",
											"const submittedPacs008Message = utils.addTenantId(null, JSON.parse(pm.globals.get(\"pacs008\")));\r",
											"\r",
											"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
											"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
											"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
											"const tenantId = submittedPacs008Message.TenantId;\r",
											"\r",
											"// Load deconstructued identifier variables into global variables\r",
											"pm.globals.set(\"tenantId\", tenantId);\r",
											"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
											"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
											"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
											"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
											"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
											"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
											"\r",
											"pm.globals.set(\"synccache\", \"no\");"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"protocolProfileBehavior": {
								"disableBodyPruning": true
							},
							"request": {
								"method": "GET",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/admin/event-flow-control/entity?id={{dbtrNttyId}}&schmenm={{dbtrNttyIdSchmeNm}}&synccache={{synccache}}&activeonly=no",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"admin",
										"event-flow-control",
										"entity"
									],
									"query": [
										{
											"key": "id",
											"value": "{{dbtrNttyId}}"
										},
										{
											"key": "schmenm",
											"value": "{{dbtrNttyIdSchmeNm}}"
										},
										{
											"key": "synccache",
											"value": "{{synccache}}"
										},
										{
											"key": "activeonly",
											"value": "no"
										}
									]
								}
							},
							"response": []
						}
					]
				}
			]
		},
		{
			"name": "EFRuP Behaviour",
			"item": [
				{
					"name": "No Conditions",
					"item": [
						{
							"name": "Create messages in memory",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"utils.setPm(pm); // set the utils _pm to the pre-request script pm\r",
											"\r",
											"pm.globals.clear();\r",
											"\r",
											"console.log(`Data Preparation Service - Public Network Map`);\r",
											"\r",
											"// ## Set up transaction eco-system\r",
											"\r",
											"messageSet = utils.createTransactionSetInMemory();"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"const activePain001 = JSON.parse(pm.environment.get('activePain001'));\r",
											"\r",
											"pm.test(\"Status code is 200\", function () {\r",
											"    pm.response.to.have.status(200);\r",
											"});\r",
											"\r",
											"let dataCache = JSON.parse(pm.globals.get(\"dataCache\"));\r",
											"let endToEndId = pm.globals.get(\"endToEndId\");\r",
											"let messageIdPacs008 = pm.globals.get(\"messageIdPacs008\");\r",
											"let messageIdPacs002 = pm.globals.get(\"messageIdPacs002\");\r",
											"let pacs008 = pm.globals.get(\"pacs008\");\r",
											"let pacs002 = pm.globals.get(\"pacs002\");\r",
											"\r",
											"pm.test(`Has a new dataCache:dbtrId value: ${dataCache.dbtrId}`, function() {\r",
											"  pm.expect(dataCache.dbtrId, `${dataCache.dbtrId}`).to.be.a('string');\r",
											"});\r",
											"\r",
											"pm.test(`Has a new dataCache:cdtrId value: ${dataCache.cdtrId}`, function() {\r",
											"  pm.expect(dataCache.cdtrId).to.be.a('string');\r",
											"});\r",
											"\r",
											"pm.test(`Has a dataCache:dbtrAcctId value: ${dataCache.dbtrAcctId}`, function() {\r",
											"  pm.expect(dataCache.dbtrAcctId).to.be.a('string');\r",
											"});\r",
											"\r",
											"pm.test(`Has a dataCache:cdtrAcctId value: ${dataCache.cdtrAcctId}`, function() {\r",
											"  pm.expect(dataCache.cdtrAcctId).to.be.a('string');\r",
											"});\r",
											"\r",
											"pm.test(`Has a new endToEndId value: ${endToEndId}`, function() {\r",
											"  pm.expect(endToEndId).to.be.a('string');\r",
											"});\r",
											"\r",
											"\r",
											"pm.test(`Has a new pacs.008 msgId value: ${messageIdPacs008}`, function() {\r",
											"  pm.expect(messageIdPacs008).to.be.a('string');\r",
											"});\r",
											"\r",
											"pm.test(`Has a new pacs.002 msgId value: ${messageIdPacs002}`, function() {\r",
											"  pm.expect(messageIdPacs002).to.be.a('string');\r",
											"});\r",
											"\r",
											"pm.test(`Has a new pacs.008 body for TMS API`, function() {\r",
											"  pm.expect(pacs008).to.be.a('string');\r",
											"});\r",
											"\r",
											"pm.test(`Has a new pacs.002 body for Data Preparation`, function() {\r",
											"  pm.expect(pacs002).to.be.a('string');\r",
											"});\r",
											"\r",
											"if (activePain001) {\r",
											"    let messageIdPain001 = pm.globals.get(\"messageIdPain001\");\r",
											"    let messageIdPain013 = pm.globals.get(\"messageIdPain013\");\r",
											"    let pain001 = pm.globals.get(\"pain001\");\r",
											"    let pain013 = pm.globals.get(\"pain013\");\r",
											"    pm.test(`Has a new pain.001 msgId value: ${messageIdPain001}`, function() {\r",
											"    pm.expect(messageIdPain001).to.be.a('string');\r",
											"    });\r",
											"\r",
											"    pm.test(`Has a new pain.013 msgId value: ${messageIdPain013}`, function() {\r",
											"    pm.expect(messageIdPain013).to.be.a('string');\r",
											"    });\r",
											"\r",
											"    pm.test(`Has a new pain.001 body for TMS API`, function() {\r",
											"    pm.expect(pain001).to.be.a('string');\r",
											"    });\r",
											"\r",
											"    pm.test(`Has a new pain.013 body for TMS API`, function() {\r",
											"    pm.expect(pain013).to.be.a('string');\r",
											"    });\r",
											"} else {\r",
											"    pm.test(`pain.001/013 messages disabled`, function() {\r",
											"    pm.expect(activePain001).to.be.false;\r",
											"    });\r",
											"}"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"protocolProfileBehavior": {
								"disableBodyPruning": true
							},
							"request": {
								"method": "GET",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaTMSUrl}}",
									"host": [
										"{{tazamaTMSUrl}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Post pacs.008 to TMS API",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"let messageBody = pm.globals.get('pacs008');\r",
											"pm.globals.set('messageBody', messageBody);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
											"    pm.response.to.have.status(200);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{messageBody}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
									"host": [
										"{{tazamaTMSUrl}}{{path-tms-api-version}}"
									],
									"path": [
										"{{path-pacs008}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Post pacs.002 to TMS API",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"let messageBody = pm.globals.get('pacs002');\r",
											"pm.globals.set('messageBody', messageBody);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
											"    pm.response.to.have.status(200);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{{pacs002}}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs002}}",
									"host": [
										"{{tazamaTMSUrl}}{{path-tms-api-version}}"
									],
									"path": [
										"{{path-pacs002}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Fetch evaluation results with msgId from admin-service",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"const resJson = pm.response.json();\r",
											"\r",
											"const rulesPerTypologyCount = [3];\r",
											"const totalExpectedTypologies = 1;\r",
											"const expectedAlertStatus = \"NALT\";\r",
											"const interdictionTypologies = [\r",
											"  \"999\"\r",
											"];\r",
											"const ruleDescriptions = {\r",
											"  \"901\": \"Number of outgoing transactions - debtor\",\r",
											"  \"902\": \"Number of incoming transactions - creditor\",\r",
											"  \"EFR\": \"Event-Flow Rule Processor\"\r",
											"}\r",
											"const typologyDescriptions = {\r",
											"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
											"}\r",
											"const expectedIndependentVariable = [/* rule-901 */ 1, /* rule-902 */ 1, /* EFRuP */ 0];\r",
											"\r",
											"let ruleCount = 0;\r",
											"let typologyCount = 0;\r",
											"let slowestRule = 0;\r",
											"let fastestRule = 999999999;\r",
											"let slowestTypology = 0;\r",
											"let fastestTypology = 999999999;\r",
											"let totalRule = 0;\r",
											"let totalTypology = 0;\r",
											"let prcgTmDP = resJson.data.report.metaData.prcgTmDP;\r",
											"let prcgTmED = resJson.data.report.metaData.prcgTmED;\r",
											"let tadpTime = resJson.data.report.tadpResult.prcgTm;\r",
											"let whichTypologyIsSlowest = 0;\r",
											"let whichTypologyIsFastest = 0;\r",
											"let whichRuleIsSlowest = 0;\r",
											"\r",
											"let typologyTimings = resJson.data.report.tadpResult.typologyResult.filter(e => e.prcgTm > 0);\r",
											"\r",
											"let timingsPerTypology = `Elapsed typology processor time per typology\r",
											"====================================================\r",
											"`;\r",
											"\r",
											"let sortedTypologyTimings = typologyTimings.sort((e1, e2) => (e1.prcgTm < e2.prcgTm) ? 1 : (e1.prcgTm > e2.prcgTm) ? -1 : 0);\r",
											"\r",
											"for (let i = 0; i < sortedTypologyTimings.count(); i++) {\r",
											"    timingsPerTypology = timingsPerTypology + `   ${sortedTypologyTimings[i].cfg}: ${(sortedTypologyTimings[i].prcgTm/1000000).toFixed(3)}\\n`;\r",
											"}\r",
											"\r",
											"typologyTimings = typologyTimings.filter(e => e.prcgTm > 0).map(e => e.prcgTm);\r",
											"\r",
											"ruleResults = [];\r",
											"for (let i = 0; i < resJson.data.report.tadpResult.typologyResult.count(); i++) {\r",
											"    ruleResultsPerTypology = resJson.data.report.tadpResult.typologyResult[i].ruleResults.filter(e => e.prcgTm > 0);\r",
											"    for (let j = 0; j < ruleResultsPerTypology.count(); j++) {\r",
											"        ruleResults.push(ruleResultsPerTypology[j]);\r",
											"    };\r",
											"    ruleResultsPerTypology = [];\r",
											"}\r",
											"\r",
											"const ruleResultsUnique = [...new Map(ruleResults.map((e) => [e.id, e])).values()];\r",
											"ruleTimings = ruleResultsUnique.filter(e => e.prcgTm > 0).map(e => e.prcgTm);\r",
											"\r",
											"ruleCount = ruleTimings.count();\r",
											"typologyCount = typologyTimings.count();\r",
											"\r",
											"for (let i = 0; i < typologyCount; i++) {\r",
											"    totalTypology += typologyTimings[i];\r",
											"    if (typologyTimings[i] > slowestTypology) {\r",
											"        slowestTypology = typologyTimings[i];\r",
											"        whichTypologyIsSlowest = i;\r",
											"    }\r",
											"    if (typologyTimings[i] < fastestTypology) {\r",
											"        fastestTypology = typologyTimings[i];\r",
											"        whichTypologyIsFastest = i;\r",
											"    }\r",
											"}\r",
											"\r",
											"for (let i = 0; i < ruleCount; i++) {\r",
											"    totalRule += ruleTimings[i];\r",
											"    if (ruleTimings[i] > slowestRule) {\r",
											"        slowestRule = ruleTimings[i];\r",
											"    }\r",
											"    if (ruleTimings[i] < fastestRule) {\r",
											"        fastestRule = ruleTimings[i];\r",
											"    }\r",
											"}\r",
											"\r",
											"whichRuleIsSlowest = ruleResultsUnique.filter(e => e.prcgTm === slowestRule)[0].id;\r",
											"whichRuleIsFastest = ruleResultsUnique.filter(e => e.prcgTm === fastestRule)[0].id;\r",
											"\r",
											"let totalEstimatedTime = prcgTmDP + prcgTmED + slowestRule + slowestTypology + tadpTime;\r",
											"let averageRuleTime = totalRule / ruleCount;\r",
											"let averageTypologyTime = totalTypology / typologyCount;\r",
											"\r",
											"console.log(`====================================================\r",
											"Total Estimate Time: ${(totalEstimatedTime/1000000).toFixed(3)}ms;\r",
											"====================================================\r",
											"Data Preparation Service: ${(prcgTmDP/1000000).toFixed(3)}ms\r",
											"ED: ${(prcgTmED/1000000).toFixed(3)}ms\r",
											"====================================================\r",
											"Number of Rules: ${ruleCount}\r",
											"Slowest Rule: ${(slowestRule/1000000).toFixed(3)}ms (Rule ${whichRuleIsSlowest})\r",
											"Fastest Rule: ${(fastestRule/1000000).toFixed(3)}ms (Rule ${whichRuleIsFastest})\r",
											"Rule Average: ${(averageRuleTime/1000000).toFixed(3)}ms\r",
											"====================================================\r",
											"Number of Typologies: ${typologyCount}\r",
											"Slowest Typology: ${(slowestTypology/1000000).toFixed(3)}ms (Typology ${resJson.data.report.tadpResult.typologyResult[whichTypologyIsSlowest].cfg})\r",
											"Fastest Typology: ${(fastestTypology/1000000).toFixed(3)}ms (Typology ${resJson.data.report.tadpResult.typologyResult[whichTypologyIsFastest].cfg})\r",
											"\r",
											"Typology Average: ${(averageTypologyTime/1000000).toFixed(3)}ms\r",
											"====================================================\r",
											"TADP: ${(tadpTime/1000000).toFixed(3)}ms\r",
											"====================================================`);\r",
											"\r",
											"let timingsPerRule = `Elapsed time per rule\r",
											"====================================================\r",
											"`;\r",
											"\r",
											"let sortedRuleTimings = ruleResultsUnique.sort((e1, e2) => (e1.prcgTm < e2.prcgTm) ? 1 : (e1.prcgTm > e2.prcgTm) ? -1 : 0);\r",
											"\r",
											"for (let i = 0; i < sortedRuleTimings.count(); i++) {\r",
											"    timingsPerRule = timingsPerRule + `   ${sortedRuleTimings[i].id}: ${(sortedRuleTimings[i].prcgTm/1000000).toFixed(3)} - ${ruleDescriptions[sortedRuleTimings[i].id.substring(0,3)]}\\n`;\r",
											"}\r",
											"\r",
											"console.log(timingsPerRule);\r",
											"console.log(timingsPerTypology);\r",
											"\r",
											"let sortedRuleTimingsById = ruleResultsUnique.sort((e1, e2) => (e1.id > e2.id) ? 1 : (e1.id < e2.id) ? -1 : 0);\r",
											"\r",
											"for (let i = 0; i < sortedRuleTimingsById.length; i++) {\r",
											"    pm.test(`Rule ${sortedRuleTimingsById[i].id}@${sortedRuleTimingsById[i].cfg} result.reason omitted`, function () {\r",
											"        pm.expect(sortedRuleTimingsById[i].reason).to.be.eql(undefined);\r",
											"    });\r",
											"\r",
											"    pm.test(`Rule ${sortedRuleTimingsById[i].id}@${sortedRuleTimingsById[i].cfg} result.desc omitted`, function () {\r",
											"        pm.expect(sortedRuleTimingsById[i].desc).to.be.eql(undefined);\r",
											"    });\r",
											"\r",
											"    pm.test(`Rule ${sortedRuleTimingsById[i].id}@${sortedRuleTimingsById[i].cfg} result.indpdntVarbl ${sortedRuleTimingsById[i].indpdntVarbl} matches target ${expectedIndependentVariable[i]}`, function () {\r",
											"        pm.expect(sortedRuleTimingsById[i].indpdntVarbl).to.be.eql(expectedIndependentVariable[i]);\r",
											"    });\r",
											"\r",
											"}\r",
											"\r",
											"pm.test(`Total (estimated) processing time: ${(totalEstimatedTime / 1000000).toFixed(3)} milliseconds`, function () {\r",
											"    pm.expect(totalEstimatedTime).to.be.greaterThan(0);\r",
											"});\r",
											"\r",
											"pm.test(`Data preparation procesing time: ${(prcgTmDP / 1000000).toFixed(3)} milliseconds`, function () {\r",
											"    pm.expect(prcgTmDP).to.be.greaterThan(0);\r",
											"});\r",
											"\r",
											"pm.test(`ED procesing time: ${(prcgTmED / 1000000).toFixed(3)} milliseconds`, function () {\r",
											"    pm.expect(prcgTmED).to.be.greaterThan(0);\r",
											"});\r",
											"\r",
											"pm.test(`Slowest rule procesing time: ${(slowestRule / 1000000).toFixed(3)} milliseconds (Rule ${whichRuleIsSlowest})`, function () {\r",
											"    pm.expect(slowestRule).to.be.greaterThan(0);\r",
											"});\r",
											"\r",
											"pm.test(`Fastest rule procesing time: ${(fastestRule / 1000000).toFixed(3)} milliseconds (Rule ${whichRuleIsFastest})`, function () {\r",
											"    pm.expect(fastestRule).to.be.greaterThan(0);\r",
											"});\r",
											"\r",
											"pm.test(`Average rule procesing time: ${(averageRuleTime / 1000000).toFixed(3)} milliseconds`, function () {\r",
											"    pm.expect(averageRuleTime).to.be.greaterThan(0);\r",
											"});\r",
											"\r",
											"pm.test(`Slowest typology processing time: ${(slowestTypology / 1000000).toFixed(3)} milliseconds (Typology ${resJson.data.report.tadpResult.typologyResult[whichTypologyIsSlowest].id})`, function () {\r",
											"    pm.expect(slowestTypology).to.be.greaterThan(0);\r",
											"});\r",
											"\r",
											"pm.test(`Fastest typology processing time: ${(fastestTypology / 1000000).toFixed(3)} milliseconds (Typology ${resJson.data.report.tadpResult.typologyResult[whichTypologyIsFastest].id})`, function () {\r",
											"    pm.expect(fastestTypology).to.be.lessThan(999999999);\r",
											"});\r",
											"\r",
											"pm.test(`Average typology processing time: ${(averageTypologyTime / 1000000).toFixed(3)} milliseconds`, function () {\r",
											"    pm.expect(averageTypologyTime).to.be.greaterThan(0);\r",
											"});\r",
											"\r",
											"pm.test(`TADProc processing time: ${(tadpTime / 1000000).toFixed(3)} milliseconds`, function () {\r",
											"    pm.expect(tadpTime).to.be.greaterThan(0);\r",
											"});\r",
											"\r",
											"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
											"    pm.expect(resJson.data.report.status).to.equal(expectedAlertStatus);\r",
											"});\r",
											"\r",
											"let sortedTypologiesById = resJson.data.report.tadpResult.typologyResult.sort((e1, e2) => (e1.cfg > e2.cfg) ? 1 : (e1.cfg < e2.cfg) ? -1 : 0);\r",
											"\r",
											"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
											"    pm.expect(sortedTypologiesById.length).to.equal(totalExpectedTypologies);\r",
											"});\r",
											"\r",
											"let ruleWeightingTotal = 0;\r",
											"for (let i = 0; i < sortedTypologiesById.length; i++) {\r",
											"    ruleWeightingTotal = 0;\r",
											"    for (let j = 0; j < sortedTypologiesById[i].ruleResults.length; j++) {\r",
											"        ruleWeightingTotal += sortedTypologiesById[i].ruleResults[j].wght;\r",
											"    }\r",
											"\r",
											"    pm.test(`Typology ${sortedTypologiesById[i].cfg} contains ${rulesPerTypologyCount[i]} rule results`, function () {\r",
											"        pm.expect(sortedTypologiesById[i].ruleResults.length).to.equal(rulesPerTypologyCount[i]);\r",
											"    });\r",
											"\r",
											"    pm.test(`Typology ${sortedTypologiesById[i].cfg} result (${sortedTypologiesById[i].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
											"        pm.expect(sortedTypologiesById[i].result).to.equal(ruleWeightingTotal);\r",
											"    });\r",
											"\r",
											"    if (sortedTypologiesById[i].cfg == \"105@1.0.0\" && expectedAlertStatus == \"ALRT\") {\r",
											"        pm.test(`Typology ${sortedTypologiesById[i].cfg} result (${sortedTypologiesById[i].result}) breached threshold (${sortedTypologiesById[i].workflow.alertThreshold})`, function () {\r",
											"            pm.expect(sortedTypologiesById[i].result).to.be.greaterThanOrEqual(sortedTypologiesById[i].workflow.alertThreshold);\r",
											"        });\r",
											"        pm.test(`Typology ${sortedTypologiesById[i].cfg} review flag is true`, function () {\r",
											"            pm.expect(sortedTypologiesById[i].review).to.be.true;\r",
											"        });\r",
											"    } else {\r",
											"        pm.test(`Typology ${sortedTypologiesById[i].cfg} result (${sortedTypologiesById[i].result}) did not breach threshold (${sortedTypologiesById[i].workflow.alertThreshold})`, function () {\r",
											"            pm.expect(sortedTypologiesById[i].result).to.be.lessThan(sortedTypologiesById[i].workflow.alertThreshold);\r",
											"        });\r",
											"        pm.test(`Typology ${sortedTypologiesById[i].cfg} review flag is false`, function () {\r",
											"            pm.expect(sortedTypologiesById[i].review).to.be.false;\r",
											"        });\r",
											"    }\r",
											"\r",
											"    if (interdictionTypologies.includes(sortedTypologiesById[i].cfg.substring(0,3))) {\r",
											"        pm.test(`Typology ${sortedTypologiesById[i].cfg} interdictionThreshold is greater than zero if not omitted`, function () {\r",
											"            pm.expect(sortedTypologiesById[i].workflow.interdictionThreshold).to.be.greaterThan(0);\r",
											"        });\r",
											"    } else {\r",
											"        pm.test(`Typology ${sortedTypologiesById[i].cfg} interdictionThreshold is omitted`, function () {\r",
											"            pm.expect(sortedTypologiesById[i].workflow.interdictionThreshold).to.be.eql(undefined);\r",
											"        });\r",
											"    }\r",
											"}"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"protocolProfileBehavior": {
								"disableBodyPruning": true
							},
							"request": {
								"auth": {
									"type": "bearer",
									"bearer": [
										{
											"key": "token",
											"value": "{{auth-token}}",
											"type": "string"
										}
									]
								},
								"method": "GET",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/admin/reports/getreportbymsgid?msgid={{messageIdPacs002}}",
									"host": [
										"{{tazamaAdminUrl}}{{path-admin-api-version}}"
									],
									"path": [
										"admin",
										"reports",
										"getreportbymsgid"
									],
									"query": [
										{
											"key": "msgid",
											"value": "{{messageIdPacs002}}"
										}
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "dbtrId - perspective=both",
					"item": [
						{
							"name": "non-overridable block",
							"item": [
								{
									"name": "Create New Entity Condition Manually - Unknown debtor entity",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"responseJSON = pm.response.json();\r",
													"let conditionResult = responseJSON.result.conditions;\r",
													"let conditionEntity = responseJSON.result.ntty;\r",
													"let requestMessage = responseJSON.message;\r",
													"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
													"let nttyId = pm.globals.get(\"dbtrNttyId\");\r",
													"let nttyIdSchme = pm.globals.get(\"dbtrNttyIdSchmeNm\");\r",
													"let tenantId = pm.globals.get(\"tenantId\");\r",
													"let targetEntityId = nttyId + nttyIdSchme;\r",
													"\r",
													"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
													"targetRequestMessage = \"New condition was saved successfully.\"\r",
													"\r",
													"pm.test(\"Status code is 200\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(\"Result message matches target result message\", function () {\r",
													"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
													"});\r",
													"\r",
													"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
													"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
													"});\r",
													"\r",
													"pm.test(\"Result conditions array only contains a single condition\", function () {\r",
													"    pm.expect(conditionResult.length).to.be.eql(1);\r",
													"});\r",
													"\r",
													"let firstElement = conditionResult[0];\r",
													"\r",
													"pm.test(\"Result condition has a non-empty condId\", function () {\r",
													"    pm.expect(firstElement.condId).to.exist.and.not.be.empty;\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.condTp).to.be.eql(targetConditionResult.condTp);\r",
													"});\r",
													"\r",
													"if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"    pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
													"        pm.expect(firstElement.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"    });\r",
													"} else {    // if not, one must have been defaulted\r",
													"    pm.test(\"Result condition has a non-empty incptnDtTm\", function () {\r",
													"        pm.expect(firstElement.incptnDtTm).to.exist.and.not.be.empty;\r",
													"    });\r",
													"}\r",
													"\r",
													"if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"    pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
													"        pm.expect(firstElement.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"    });\r",
													"} else {    // if not, one must not have been defaulted\r",
													"    pm.test(\"Result condition does not have an xprtnDtTm\", function () {\r",
													"        pm.expect(firstElement.xprtnDtTm).to.not.exist;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.usr).to.be.eql(targetConditionResult.usr);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition has a non-empty creDtTm\", function () {\r",
													"    pm.expect(firstElement.creDtTm).to.exist.and.not.be.empty;\r",
													"});\r",
													"\r",
													"// create an array that only includes the perspective descriptions so that we can evaluate them easily\r",
													"let perspectives = firstElement.prsptvs.map(({ prsptv }) => prsptv);\r",
													"\r",
													"if (targetConditionResult.prsptv === \"both\") {\r",
													"    pm.test(\"Result prsptv array contains only 2 perspectives\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(2);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_creditor_by\", \"governed_as_debtor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains both ${JSON.stringify(targetPerspectives)} perspectives`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"} else if (targetConditionResult.prsptv === \"debtor\") {\r",
													"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_debtor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"} else if (targetConditionResult.prsptv === \"creditor\") {\r",
													"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_creditor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"};\r",
													"\r",
													"for (let i = 0; i < firstElement.prsptvs.length; i++) {   // for each perspective\r",
													"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} contains a non-empty evtTp array`, function () {\r",
													"        pm.expect(firstElement.prsptvs[i].evtTp).to.be.an('array').and.not.be.empty;\r",
													"    });\r",
													"\r",
													"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} evtTp array matches submitted condition`, function () {\r",
													"        pm.expect(firstElement.prsptvs[i].evtTp).to.include.members(targetConditionResult.evtTp);\r",
													"    });\r",
													"\r",
													"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches submitted condition`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must have been defaulted\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches created condition incptDtTm`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.eql(firstElement.incptnDtTm);\r",
													"        });\r",
													"    }\r",
													"\r",
													"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} xprtnDtTm matches submitted condition`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must not have been defaulted\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} does not have an xprtnDtTm`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.not.exist;\r",
													"        });\r",
													"    }\r",
													"\r",
													"}\r",
													"\r",
													"pm.test(\"Result condition ntty.id matches submitted condition\", function () {\r",
													"    pm.expect(conditionEntity.id).to.be.eql(targetConditionResult.ntty.id);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"    pm.expect(conditionEntity.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
													"});\r",
													"\r",
													"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetEntityId, false);;\r",
													"\r",
													"await pm.sendRequest(postRequest, (error, response) => {\r",
													"    if (utils.getLogLevel() === 'DEBUG') {\r",
													"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
													"    }\r",
													"    databaseConditionResult = response.json().data;\r",
													"\r",
													"    if (utils.getLogLevel() === 'DEBUG') {\r",
													"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
													"    }\r",
													"\r",
													"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
													"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
													"\r",
													"    pm.test(`Only one condition for entity [${targetEntityId}] exists in the database`, function () {\r",
													"        pm.expect(graphConditionList.length).to.eql(1);\r",
													"    });\r",
													"\r",
													"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
													"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
													"            pm.expect(conditionGraph.v[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
													"        });\r",
													"    }\r",
													"\r",
													"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
													"    });\r",
													"\r",
													"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"        pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
													"            pm.expect(conditionGraph.v[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must have been defaulted\r",
													"        pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
													"            pm.expect(conditionGraph.v[0].incptnDtTm).to.exist.and.not.be.empty;\r",
													"        });\r",
													"    }\r",
													"\r",
													"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"        pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
													"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must not have been defaulted\r",
													"        pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
													"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.not.exist;\r",
													"        });\r",
													"    }\r",
													"\r",
													"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].ntty.id).to.be.eql(targetConditionResult.ntty.id);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].ntty.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].usr).to.be.eql(targetConditionResult.usr);\r",
													"    });\r",
													"\r",
													"    let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, conditionGraph.v[0]._key);\r",
													"\r",
													"    pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
													"        pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database 'governed_as_creditor_by' edge exists\", function () {\r",
													"        pm.expect(edgeList).to.include.members([\"governed_as_creditor_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
													"    });\r",
													"\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"// Obliterate the current contents of the global variables\r",
													"pm.globals.clear();\r",
													"\r",
													"// Set up the transaction (in memory)\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ 3600000,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"\r",
													"// Retrieve the created pacs.008 message\r",
													"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
													"\r",
													"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
													"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
													"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
													"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
													"\r",
													"// Load deconstructued identifier variables into global variables\r",
													"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
													"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
													"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
													"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
													"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
													"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
													"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
													"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
													"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
													"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
													"\r",
													"// Set up the condition\r",
													"\r",
													"messageBody = {\r",
													"  \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09\",\"pacs.008.001.10\",\"pacs.002.001.12\"],\r",
													"  \"condTp\":\"non-overridable-block\",\r",
													"  \"prsptv\":\"both\",\r",
													"  \"condRsn\":\"Default Test Condition\",\r",
													"  \"ntty\":\r",
													"  {\r",
													"    \"id\": `${dbtrNttyId.id}`,\r",
													"    \"schmeNm\":\r",
													"    {\r",
													"      \"prtry\":\"TAZAMA_EID\"\r",
													"    }\r",
													"  },\r",
													"  \"forceCret\":true,\r",
													"  \"usr\":\"POSTMAN\"\r",
													"}\r",
													"\r",
													"// Set up body variables\r",
													"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
													"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
											"host": [
												"{{tazamaAdminUrl}}{{path-admin-api-version}}"
											],
											"path": [
												"{{path-entity-condition}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('debtorId');\r",
													"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
													"let cdtrId = pm.globals.get('creditorId');\r",
													"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ dbtrId,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ dbtrAcctId,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ 'fsp001',\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Post pacs.002 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`Alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													""
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"ALRT\";\r",
													"const expectedBlockingOutcome = \"block\";\r",
													"const expectedReviewFlag = true;\r",
													"const expectedTypologyAlert = false;\r",
													"const expectedTypologyInterdiction = false;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFR\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"const expectedIndependentVariable = [/* rule-901 */ 1, /* rule-902 */ 1, /* EFRuP */ 0];\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.data.report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.data.report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.data.report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"protocolProfileBehavior": {
										"disableBodyPruning": true
									},
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "GET",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/admin/reports/getreportbymsgid?msgid={{messageIdPacs002}}",
											"host": [
												"{{tazamaAdminUrl}}{{path-admin-api-version}}"
											],
											"path": [
												"admin",
												"reports",
												"getreportbymsgid"
											],
											"query": [
												{
													"key": "msgid",
													"value": "{{messageIdPacs002}}"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('debtorId');\r",
													"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
													"let cdtrId = pm.globals.get('creditorId');\r",
													"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ dbtrId,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ dbtrAcctId,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ 'fsp001',\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Post pacs.002 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`Alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"ALRT\";\r",
													"const expectedBlockingOutcome = \"block\";\r",
													"const expectedReviewFlag = true;\r",
													"const expectedTypologyAlert = true;\r",
													"const expectedTypologyInterdiction = false;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFR\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"const expectedIndependentVariable = [/* rule-901 */ 1, /* rule-902 */ 1, /* EFRuP */ 0];\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.data.report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.data.report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.data.report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"protocolProfileBehavior": {
										"disableBodyPruning": true
									},
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "GET",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/admin/reports/getreportbymsgid?msgid={{messageIdPacs002}}",
											"host": [
												"{{tazamaAdminUrl}}{{path-admin-api-version}}"
											],
											"path": [
												"admin",
												"reports",
												"getreportbymsgid"
											],
											"query": [
												{
													"key": "msgid",
													"value": "{{messageIdPacs002}}"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('debtorId');\r",
													"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
													"let cdtrId = pm.globals.get('creditorId');\r",
													"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ dbtrId,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ dbtrAcctId,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ 'fsp001',\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Post pacs.002 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`Alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"ALRT\";\r",
													"const expectedBlockingOutcome = \"block\";\r",
													"const expectedReviewFlag = true;\r",
													"const expectedTypologyAlert = true;\r",
													"const expectedTypologyInterdiction = true;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFR\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"const expectedIndependentVariable = [/* rule-901 */ 1, /* rule-902 */ 1, /* EFRuP */ 0];\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.data.report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.data.report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.data.report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"protocolProfileBehavior": {
										"disableBodyPruning": true
									},
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "GET",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/admin/reports/getreportbymsgid?msgid={{messageIdPacs002}}",
											"host": [
												"{{tazamaAdminUrl}}{{path-admin-api-version}}"
											],
											"path": [
												"admin",
												"reports",
												"getreportbymsgid"
											],
											"query": [
												{
													"key": "msgid",
													"value": "{{messageIdPacs002}}"
												}
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "overridable block",
							"item": [
								{
									"name": "Create New Entity Condition Manually - Unknown debtor entity",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"responseJSON = pm.response.json();\r",
													"let conditionResult = responseJSON.result.conditions;\r",
													"let conditionEntity = responseJSON.result.ntty;\r",
													"let requestMessage = responseJSON.message;\r",
													"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
													"let nttyId = pm.globals.get(\"dbtrNttyId\");\r",
													"let nttyIdSchme = pm.globals.get(\"dbtrNttyIdSchmeNm\");\r",
													"let tenantId = pm.globals.get(\"tenantId\");\r",
													"let targetEntityId = nttyId + nttyIdSchme;\r",
													"\r",
													"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
													"targetRequestMessage = \"New condition was saved successfully.\"\r",
													"\r",
													"pm.test(\"Status code is 200\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(\"Result message matches target result message\", function () {\r",
													"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
													"});\r",
													"\r",
													"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
													"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
													"});\r",
													"\r",
													"pm.test(\"Result conditions array only contains a single condition\", function () {\r",
													"    pm.expect(conditionResult.length).to.be.eql(1);\r",
													"});\r",
													"\r",
													"let firstElement = conditionResult[0];\r",
													"\r",
													"pm.test(\"Result condition has a non-empty condId\", function () {\r",
													"    pm.expect(firstElement.condId).to.exist.and.not.be.empty;\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.condTp).to.be.eql(targetConditionResult.condTp);\r",
													"});\r",
													"\r",
													"if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"    pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
													"        pm.expect(firstElement.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"    });\r",
													"} else {    // if not, one must have been defaulted\r",
													"    pm.test(\"Result condition has a non-empty incptnDtTm\", function () {\r",
													"        pm.expect(firstElement.incptnDtTm).to.exist.and.not.be.empty;\r",
													"    });\r",
													"}\r",
													"\r",
													"if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"    pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
													"        pm.expect(firstElement.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"    });\r",
													"} else {    // if not, one must not have been defaulted\r",
													"    pm.test(\"Result condition does not have an xprtnDtTm\", function () {\r",
													"        pm.expect(firstElement.xprtnDtTm).to.not.exist;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.usr).to.be.eql(targetConditionResult.usr);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition has a non-empty creDtTm\", function () {\r",
													"    pm.expect(firstElement.creDtTm).to.exist.and.not.be.empty;\r",
													"});\r",
													"\r",
													"// create an array that only includes the perspective descriptions so that we can evaluate them easily\r",
													"let perspectives = firstElement.prsptvs.map(({ prsptv }) => prsptv);\r",
													"\r",
													"if (targetConditionResult.prsptv === \"both\") {\r",
													"    pm.test(\"Result prsptv array contains only 2 perspectives\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(2);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_creditor_by\", \"governed_as_debtor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains both ${JSON.stringify(targetPerspectives)} perspectives`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"} else if (targetConditionResult.prsptv === \"debtor\") {\r",
													"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_debtor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"} else if (targetConditionResult.prsptv === \"creditor\") {\r",
													"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_creditor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"};\r",
													"\r",
													"for (let i = 0; i < firstElement.prsptvs.length; i++) {   // for each perspective\r",
													"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} contains a non-empty evtTp array`, function () {\r",
													"        pm.expect(firstElement.prsptvs[i].evtTp).to.be.an('array').and.not.be.empty;\r",
													"    });\r",
													"\r",
													"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} evtTp array matches submitted condition`, function () {\r",
													"        pm.expect(firstElement.prsptvs[i].evtTp).to.include.members(targetConditionResult.evtTp);\r",
													"    });\r",
													"\r",
													"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches submitted condition`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must have been defaulted\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches created condition incptDtTm`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.eql(firstElement.incptnDtTm);\r",
													"        });\r",
													"    }\r",
													"\r",
													"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} xprtnDtTm matches submitted condition`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must not have been defaulted\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} does not have an xprtnDtTm`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.not.exist;\r",
													"        });\r",
													"    }\r",
													"\r",
													"}\r",
													"\r",
													"pm.test(\"Result condition ntty.id matches submitted condition\", function () {\r",
													"    pm.expect(conditionEntity.id).to.be.eql(targetConditionResult.ntty.id);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"    pm.expect(conditionEntity.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
													"});\r",
													"\r",
													"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetEntityId, false);;\r",
													"\r",
													"await pm.sendRequest(postRequest, (error, response) => {\r",
													"    if (utils.getLogLevel() === 'DEBUG') {\r",
													"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
													"    }\r",
													"    databaseConditionResult = response.json().data;\r",
													"\r",
													"    if (utils.getLogLevel() === 'DEBUG') {\r",
													"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
													"    }\r",
													"\r",
													"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
													"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
													"\r",
													"    pm.test(`Only one condition for entity [${targetEntityId}] exists in the database`, function () {\r",
													"        pm.expect(graphConditionList.length).to.eql(1);\r",
													"    });\r",
													"\r",
													"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
													"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
													"            pm.expect(conditionGraph.v[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
													"        });\r",
													"    }\r",
													"\r",
													"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
													"    });\r",
													"\r",
													"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"        pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
													"            pm.expect(conditionGraph.v[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must have been defaulted\r",
													"        pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
													"            pm.expect(conditionGraph.v[0].incptnDtTm).to.exist.and.not.be.empty;\r",
													"        });\r",
													"    }\r",
													"\r",
													"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"        pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
													"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must not have been defaulted\r",
													"        pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
													"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.not.exist;\r",
													"        });\r",
													"    }\r",
													"\r",
													"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].ntty.id).to.be.eql(targetConditionResult.ntty.id);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].ntty.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].usr).to.be.eql(targetConditionResult.usr);\r",
													"    });\r",
													"\r",
													"    let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, conditionGraph.v[0]._key);\r",
													"\r",
													"    pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
													"        pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database 'governed_as_creditor_by' edge exists\", function () {\r",
													"        pm.expect(edgeList).to.include.members([\"governed_as_creditor_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
													"    });\r",
													"\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"// Obliterate the current contents of the global variables\r",
													"pm.globals.clear();\r",
													"\r",
													"// Set up the transaction (in memory)\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ 3600000,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"\r",
													"// Retrieve the created pacs.008 message\r",
													"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
													"\r",
													"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
													"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
													"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
													"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
													"\r",
													"// Load deconstructued identifier variables into global variables\r",
													"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
													"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
													"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
													"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
													"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
													"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
													"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
													"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
													"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
													"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
													"\r",
													"// Set up the condition\r",
													"\r",
													"messageBody = {\r",
													"  \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09\",\"pacs.008.001.10\",\"pacs.002.001.12\"],\r",
													"  \"condTp\":\"overridable-block\",\r",
													"  \"prsptv\":\"both\",\r",
													"  \"condRsn\":\"Default Test Condition\",\r",
													"  \"ntty\":\r",
													"  {\r",
													"    \"id\": `${dbtrNttyId.id}`,\r",
													"    \"schmeNm\":\r",
													"    {\r",
													"      \"prtry\":\"TAZAMA_EID\"\r",
													"    }\r",
													"  },\r",
													"  \"forceCret\":true,\r",
													"  \"usr\":\"POSTMAN\"\r",
													"}\r",
													"\r",
													"// Set up body variables\r",
													"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
													"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
											"host": [
												"{{tazamaAdminUrl}}{{path-admin-api-version}}"
											],
											"path": [
												"{{path-entity-condition}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('debtorId');\r",
													"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
													"let cdtrId = pm.globals.get('creditorId');\r",
													"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ dbtrId,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ dbtrAcctId,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ 'fsp001',\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Post pacs.002 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`Alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"ALRT\";\r",
													"const expectedBlockingOutcome = \"block\";\r",
													"const expectedReviewFlag = true;\r",
													"const expectedTypologyAlert = false;\r",
													"const expectedTypologyInterdiction = false;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('debtorId');\r",
													"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
													"let cdtrId = pm.globals.get('creditorId');\r",
													"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ dbtrId,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ dbtrAcctId,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ 'fsp001',\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Post pacs.002 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`Alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"ALRT\";\r",
													"const expectedBlockingOutcome = \"block\";\r",
													"const expectedReviewFlag = true;\r",
													"const expectedTypologyAlert = true;\r",
													"const expectedTypologyInterdiction = false;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('debtorId');\r",
													"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
													"let cdtrId = pm.globals.get('creditorId');\r",
													"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ dbtrId,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ dbtrAcctId,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ 'fsp001',\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Post pacs.002 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`Alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"ALRT\";\r",
													"const expectedBlockingOutcome = \"block\";\r",
													"const expectedReviewFlag = true;\r",
													"const expectedTypologyAlert = true;\r",
													"const expectedTypologyInterdiction = true;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "overridable block with override",
							"item": [
								{
									"name": "Create New Entity Condition Manually - Unknown debtor entity",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"responseJSON = pm.response.json();\r",
													"let conditionResult = responseJSON.result.conditions;\r",
													"let conditionEntity = responseJSON.result.ntty;\r",
													"let requestMessage = responseJSON.message;\r",
													"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
													"let nttyId = pm.globals.get(\"dbtrNttyId\");\r",
													"let nttyIdSchme = pm.globals.get(\"dbtrNttyIdSchmeNm\");\r",
													"let tenantId = pm.globals.get(\"tenantId\");\r",
													"let targetEntityId = nttyId + nttyIdSchme;\r",
													"\r",
													"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
													"targetRequestMessage = \"New condition was saved successfully.\"\r",
													"\r",
													"pm.test(\"Status code is 200\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(\"Result message matches target result message\", function () {\r",
													"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
													"});\r",
													"\r",
													"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
													"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
													"});\r",
													"\r",
													"pm.test(\"Result conditions array only contains a single condition\", function () {\r",
													"    pm.expect(conditionResult.length).to.be.eql(1);\r",
													"});\r",
													"\r",
													"let firstElement = conditionResult[0];\r",
													"\r",
													"pm.test(\"Result condition has a non-empty condId\", function () {\r",
													"    pm.expect(firstElement.condId).to.exist.and.not.be.empty;\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.condTp).to.be.eql(targetConditionResult.condTp);\r",
													"});\r",
													"\r",
													"if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"    pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
													"        pm.expect(firstElement.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"    });\r",
													"} else {    // if not, one must have been defaulted\r",
													"    pm.test(\"Result condition has a non-empty incptnDtTm\", function () {\r",
													"        pm.expect(firstElement.incptnDtTm).to.exist.and.not.be.empty;\r",
													"    });\r",
													"}\r",
													"\r",
													"if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"    pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
													"        pm.expect(firstElement.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"    });\r",
													"} else {    // if not, one must not have been defaulted\r",
													"    pm.test(\"Result condition does not have an xprtnDtTm\", function () {\r",
													"        pm.expect(firstElement.xprtnDtTm).to.not.exist;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.usr).to.be.eql(targetConditionResult.usr);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition has a non-empty creDtTm\", function () {\r",
													"    pm.expect(firstElement.creDtTm).to.exist.and.not.be.empty;\r",
													"});\r",
													"\r",
													"// create an array that only includes the perspective descriptions so that we can evaluate them easily\r",
													"let perspectives = firstElement.prsptvs.map(({ prsptv }) => prsptv);\r",
													"\r",
													"if (targetConditionResult.prsptv === \"both\") {\r",
													"    pm.test(\"Result prsptv array contains only 2 perspectives\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(2);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_creditor_by\", \"governed_as_debtor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains both ${JSON.stringify(targetPerspectives)} perspectives`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"} else if (targetConditionResult.prsptv === \"debtor\") {\r",
													"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_debtor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"} else if (targetConditionResult.prsptv === \"creditor\") {\r",
													"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_creditor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"};\r",
													"\r",
													"for (let i = 0; i < firstElement.prsptvs.length; i++) {   // for each perspective\r",
													"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} contains a non-empty evtTp array`, function () {\r",
													"        pm.expect(firstElement.prsptvs[i].evtTp).to.be.an('array').and.not.be.empty;\r",
													"    });\r",
													"\r",
													"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} evtTp array matches submitted condition`, function () {\r",
													"        pm.expect(firstElement.prsptvs[i].evtTp).to.include.members(targetConditionResult.evtTp);\r",
													"    });\r",
													"\r",
													"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches submitted condition`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must have been defaulted\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches created condition incptDtTm`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.eql(firstElement.incptnDtTm);\r",
													"        });\r",
													"    }\r",
													"\r",
													"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} xprtnDtTm matches submitted condition`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must not have been defaulted\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} does not have an xprtnDtTm`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.not.exist;\r",
													"        });\r",
													"    }\r",
													"\r",
													"}\r",
													"\r",
													"pm.test(\"Result condition ntty.id matches submitted condition\", function () {\r",
													"    pm.expect(conditionEntity.id).to.be.eql(targetConditionResult.ntty.id);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"    pm.expect(conditionEntity.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
													"});\r",
													"\r",
													"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetEntityId, false);;\r",
													"\r",
													"await pm.sendRequest(postRequest, (error, response) => {\r",
													"    if (utils.getLogLevel() === 'DEBUG') {\r",
													"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
													"    }\r",
													"    databaseConditionResult = response.json().data;\r",
													"\r",
													"    if (utils.getLogLevel() === 'DEBUG') {\r",
													"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
													"    }\r",
													"\r",
													"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
													"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
													"\r",
													"    pm.test(`Only one condition for entity [${targetEntityId}] exists in the database`, function () {\r",
													"        pm.expect(graphConditionList.length).to.eql(1);\r",
													"    });\r",
													"\r",
													"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
													"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
													"            pm.expect(conditionGraph.v[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
													"        });\r",
													"    }\r",
													"\r",
													"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
													"    });\r",
													"\r",
													"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"        pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
													"            pm.expect(conditionGraph.v[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must have been defaulted\r",
													"        pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
													"            pm.expect(conditionGraph.v[0].incptnDtTm).to.exist.and.not.be.empty;\r",
													"        });\r",
													"    }\r",
													"\r",
													"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"        pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
													"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must not have been defaulted\r",
													"        pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
													"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.not.exist;\r",
													"        });\r",
													"    }\r",
													"\r",
													"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].ntty.id).to.be.eql(targetConditionResult.ntty.id);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].ntty.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].usr).to.be.eql(targetConditionResult.usr);\r",
													"    });\r",
													"\r",
													"    let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, conditionGraph.v[0]._key);\r",
													"\r",
													"    pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
													"        pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database 'governed_as_creditor_by' edge exists\", function () {\r",
													"        pm.expect(edgeList).to.include.members([\"governed_as_creditor_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
													"    });\r",
													"\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"// Obliterate the current contents of the global variables\r",
													"pm.globals.clear();\r",
													"\r",
													"// Set up the transaction (in memory)\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ 3600000,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"\r",
													"// Retrieve the created pacs.008 message\r",
													"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
													"\r",
													"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
													"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
													"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
													"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
													"\r",
													"// Load deconstructued identifier variables into global variables\r",
													"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
													"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
													"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
													"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
													"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
													"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
													"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
													"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
													"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
													"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
													"\r",
													"// Set up the condition\r",
													"\r",
													"console.log(`Overridable block incepts at ${utils.getTimestampNow()}`);\r",
													"\r",
													"messageBody = {\r",
													"  \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09\",\"pacs.008.001.10\",\"pacs.002.001.12\"],\r",
													"  \"condTp\":\"overridable-block\",\r",
													"  \"prsptv\":\"both\",\r",
													"  \"condRsn\":\"Default Test Condition\",\r",
													"  \"ntty\":\r",
													"  {\r",
													"    \"id\": `${dbtrNttyId.id}`,\r",
													"    \"schmeNm\":\r",
													"    {\r",
													"      \"prtry\":\"TAZAMA_EID\"\r",
													"    }\r",
													"  },\r",
													"  \"forceCret\":true,\r",
													"  \"usr\":\"POSTMAN\"\r",
													"}\r",
													"\r",
													"// Set up body variables\r",
													"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
													"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
											"host": [
												"{{tazamaAdminUrl}}{{path-admin-api-version}}"
											],
											"path": [
												"{{path-entity-condition}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Create New Entity Condition Manually - set override",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"responseJSON = pm.response.json();\r",
													"let conditionResult = responseJSON.result.conditions;\r",
													"let conditionEntity = responseJSON.result.ntty;\r",
													"let requestMessage = responseJSON.message;\r",
													"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
													"let nttyId = pm.globals.get(\"dbtrNttyId\");\r",
													"let nttyIdSchme = pm.globals.get(\"dbtrNttyIdSchmeNm\");\r",
													"let tenantId = pm.globals.get(\"tenantId\");\r",
													"let targetEntityId = nttyId + nttyIdSchme;\r",
													"\r",
													"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
													"targetRequestMessage = \"1 conditions already exist for the entity\"\r",
													"\r",
													"pm.test(\"Status code is 200\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(\"Result message matches target result message\", function () {\r",
													"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
													"});\r",
													"\r",
													"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
													"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
													"});\r",
													"\r",
													"pm.test(\"Result conditions array contains two conditions\", function () {\r",
													"    pm.expect(conditionResult.length).to.be.eql(2);\r",
													"});\r",
													"\r",
													"let newElement = conditionResult[conditionResult.length - 1];  // the last element is the newly submitted condition\r",
													"\r",
													"pm.test(\"Result condition has a non-empty condId\", function () {\r",
													"    pm.expect(newElement.condId).to.exist.and.not.be.empty;\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
													"    pm.expect(newElement.condTp).to.be.eql(targetConditionResult.condTp);\r",
													"});\r",
													"\r",
													"if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"    pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
													"        pm.expect(newElement.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"    });\r",
													"} else {    // if not, one must have been defaulted\r",
													"    pm.test(\"Result condition has a non-empty incptnDtTm\", function () {\r",
													"        pm.expect(newElement.incptnDtTm).to.exist.and.not.be.empty;\r",
													"    });\r",
													"}\r",
													"\r",
													"if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"    pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
													"        pm.expect(newElement.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"    });\r",
													"} else {    // if not, one must not have been defaulted\r",
													"    pm.test(\"Result condition does not have an xprtnDtTm\", function () {\r",
													"        pm.expect(newElement.xprtnDtTm).to.not.exist;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
													"    pm.expect(newElement.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
													"    pm.expect(newElement.usr).to.be.eql(targetConditionResult.usr);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition has a non-empty creDtTm\", function () {\r",
													"    pm.expect(newElement.creDtTm).to.exist.and.not.be.empty;\r",
													"});\r",
													"\r",
													"// create an array that only includes the perspective descriptions so that we can evaluate them easily\r",
													"let perspectives = newElement.prsptvs.map(({ prsptv }) => prsptv);\r",
													"\r",
													"if (targetConditionResult.prsptv === \"both\") {\r",
													"    pm.test(\"Result prsptv array contains only 2 perspectives\", function () {\r",
													"        pm.expect(newElement.prsptvs.length).to.be.eql(2);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_creditor_by\", \"governed_as_debtor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains both ${JSON.stringify(targetPerspectives)} perspectives`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"} else if (targetConditionResult.prsptv === \"debtor\") {\r",
													"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
													"        pm.expect(newElement.prsptvs.length).to.be.eql(1);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_debtor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"} else if (targetConditionResult.prsptv === \"creditor\") {\r",
													"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
													"        pm.expect(newElement.prsptvs.length).to.be.eql(1);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_creditor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"};\r",
													"\r",
													"for (let i = 0; i < newElement.prsptvs.length; i++) {   // for each perspective\r",
													"    pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} contains a non-empty evtTp array`, function () {\r",
													"        pm.expect(newElement.prsptvs[i].evtTp).to.be.an('array').and.not.be.empty;\r",
													"    });\r",
													"\r",
													"    pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} evtTp array matches submitted condition`, function () {\r",
													"        pm.expect(newElement.prsptvs[i].evtTp).to.include.members(targetConditionResult.evtTp);\r",
													"    });\r",
													"\r",
													"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"        pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} incptnDtTm matches submitted condition`, function () {\r",
													"            pm.expect(newElement.prsptvs[i].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must have been defaulted\r",
													"        pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} incptnDtTm matches created condition incptDtTm`, function () {\r",
													"            pm.expect(newElement.prsptvs[i].incptnDtTm).to.eql(newElement.incptnDtTm);\r",
													"        });\r",
													"    }\r",
													"\r",
													"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"        pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} xprtnDtTm matches submitted condition`, function () {\r",
													"            pm.expect(newElement.prsptvs[i].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must not have been defaulted\r",
													"        pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} does not have an xprtnDtTm`, function () {\r",
													"            pm.expect(newElement.prsptvs[i].xprtnDtTm).to.not.exist;\r",
													"        });\r",
													"    }\r",
													"\r",
													"}\r",
													"\r",
													"pm.test(\"Result condition ntty.id matches submitted condition\", function () {\r",
													"    pm.expect(conditionEntity.id).to.be.eql(targetConditionResult.ntty.id);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"    pm.expect(conditionEntity.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
													"});\r",
													"\r",
													"// Now we want to test that the data in the database matches the submitted data AND the response data\r",
													"\r",
													"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetEntityId, false);;\r",
													"\r",
													"await pm.sendRequest(postRequest, (error, response) => {\r",
													"    if (utils.getLogLevel() === 'DEBUG') {\r",
													"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
													"    }\r",
													"    databaseConditionResult = response.json().data;\r",
													"\r",
													"    if (utils.getLogLevel() === 'DEBUG') {\r",
													"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
													"    }\r",
													"\r",
													"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
													"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
													"\r",
													"    let submittedCondition = graphConditionList.filter(condition => condition._id === `conditions/${newElement.condId}`);\r",
													"\r",
													"    // First we check that the submitted condition matches the database version\r",
													"\r",
													"    pm.test(`Only two conditions for entity [${targetEntityId}] exists in the database`, function () {\r",
													"        pm.expect(graphConditionList.length).to.eql(2);\r",
													"    });\r",
													"\r",
													"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
													"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
													"            pm.expect(submittedCondition[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
													"        });\r",
													"    }\r",
													"\r",
													"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
													"        pm.expect(submittedCondition[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
													"        pm.expect(submittedCondition[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
													"    });\r",
													"\r",
													"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"        pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
													"            pm.expect(submittedCondition[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must have been defaulted\r",
													"        pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
													"            pm.expect(submittedCondition[0].incptnDtTm).to.exist.and.not.be.empty;\r",
													"        });\r",
													"    }\r",
													"\r",
													"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"        pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
													"            pm.expect(submittedCondition[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must not have been defaulted\r",
													"        pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
													"            pm.expect(submittedCondition[0].xprtnDtTm).to.not.exist;\r",
													"        });\r",
													"    }\r",
													"\r",
													"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
													"        pm.expect(submittedCondition[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
													"        pm.expect(submittedCondition[0].ntty.id).to.be.eql(targetConditionResult.ntty.id);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"        pm.expect(submittedCondition[0].ntty.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
													"        pm.expect(submittedCondition[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
													"        pm.expect(submittedCondition[0].usr).to.be.eql(targetConditionResult.usr);\r",
													"    });\r",
													"\r",
													"    let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, submittedCondition[0]._key);\r",
													"\r",
													"    pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
													"        pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database 'governed_as_creditor_by' edge exists\", function () {\r",
													"        pm.expect(edgeList).to.include.members([\"governed_as_creditor_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
													"    });\r",
													"\r",
													"    // Then we check the previous conditions in the response one-by-one against the database version\r",
													"    let previousConditionsFromResponse = graphConditionList.filter(condition => condition._id != `conditions/${newElement.condId}`);\r",
													"    let previousResponseConditionIds = previousConditionsFromResponse.map(({ condId }) => condId);\r",
													"    let previousConditionsFromDatabase = graphConditionList.filter(condition => condition._id != `conditions/${newElement.condId}`);\r",
													"    let previousDatabaseConditionIds = previousConditionsFromDatabase.map(({ condId }) => condId);\r",
													"\r",
													"    pm.test(`List of previous conditions in response match list of conditions from database`, function () {\r",
													"        pm.expect(previousResponseConditionIds).to.have.members(previousDatabaseConditionIds);\r",
													"    });\r",
													"\r",
													"    pm.test(`Only one previous condition for entity [${targetEntityId}] exists in the reponse`, function () {\r",
													"        pm.expect(previousConditionsFromResponse.length).to.eql(1);\r",
													"    });\r",
													"\r",
													"    pm.test(`Only one previous condition for entity [${targetEntityId}] exists in the database`, function () {\r",
													"        pm.expect(previousConditionsFromDatabase.length).to.eql(1);\r",
													"    });\r",
													"\r",
													"    for (let j = 0; j < previousConditionsFromResponse.length; j++) {\r",
													"\r",
													"        let justOneConditionFromResponse = previousConditionsFromResponse.filter(condition => condition._id === `conditions/${conditionResult[j].condId}`);\r",
													"        let sameConditionFromDatabase = previousConditionsFromDatabase.filter(condition => condition._id === `conditions/${conditionResult[j].condId}`);\r",
													"\r",
													"        for (let i = 0; i < sameConditionFromDatabase[0].evtTp.length; i++) {\r",
													"            pm.test(`Database condition.evtTp contains ${sameConditionFromDatabase[0].evtTp[i]}`, function () {\r",
													"                pm.expect(justOneConditionFromResponse[0].evtTp).to.include.members([sameConditionFromDatabase[0].evtTp[i]]);\r",
													"            });\r",
													"        }\r",
													"\r",
													"        pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
													"            pm.expect(justOneConditionFromResponse[0].condTp).to.be.eql(sameConditionFromDatabase[0].condTp);\r",
													"        });\r",
													"\r",
													"        pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
													"            pm.expect(justOneConditionFromResponse[0].prsptv).to.be.eql(sameConditionFromDatabase[0].prsptv);\r",
													"        });\r",
													"\r",
													"        if (sameConditionFromDatabase[0].incptnDtTm) { // was an inception date specified?\r",
													"            pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
													"                pm.expect(justOneConditionFromResponse[0].incptnDtTm).to.be.eql(sameConditionFromDatabase[0].incptnDtTm);\r",
													"            });\r",
													"        } else {    // if not, one must have been defaulted\r",
													"            pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
													"                pm.expect(justOneConditionFromResponse[0].incptnDtTm).to.exist.and.not.be.empty;\r",
													"            });\r",
													"        }\r",
													"\r",
													"        if (sameConditionFromDatabase[0].xprtnDtTm) { // was an expiration date specified?\r",
													"            pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
													"                pm.expect(justOneConditionFromResponse[0].xprtnDtTm).to.be.eql(sameConditionFromDatabase[0].xprtnDtTm);\r",
													"            });\r",
													"        } else {    // if not, one must not have been defaulted\r",
													"            pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
													"                pm.expect(justOneConditionFromResponse[0].xprtnDtTm).to.not.exist;\r",
													"            });\r",
													"        }\r",
													"\r",
													"        pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
													"            pm.expect(justOneConditionFromResponse[0].condRsn).to.be.eql(sameConditionFromDatabase[0].condRsn);\r",
													"        });\r",
													"\r",
													"        pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
													"            pm.expect(justOneConditionFromResponse[0].ntty.id).to.be.eql(sameConditionFromDatabase[0].ntty.id);\r",
													"        });\r",
													"\r",
													"        pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"            pm.expect(justOneConditionFromResponse[0].ntty.schmeNm.prtry).to.be.eql(sameConditionFromDatabase[0].ntty.schmeNm.prtry);\r",
													"        });\r",
													"\r",
													"        pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
													"            pm.expect(justOneConditionFromResponse[0].forceCret).to.be.eql(sameConditionFromDatabase[0].forceCret);\r",
													"        });\r",
													"\r",
													"        pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
													"            pm.expect(justOneConditionFromResponse[0].usr).to.be.eql(sameConditionFromDatabase[0].usr);\r",
													"        });\r",
													"\r",
													"        let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, justOneConditionFromResponse[0]._key);\r",
													"\r",
													"        pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
													"            pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
													"        });\r",
													"\r",
													"        pm.test(\"Database 'governed_as_creditor_by' edge exists\", function () {\r",
													"            pm.expect(edgeList).to.include.members([\"governed_as_creditor_by\"]);\r",
													"        });\r",
													"\r",
													"        pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
													"            pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
													"        });\r",
													"\r",
													"        pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
													"            pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
													"        });\r",
													"    }\r",
													"\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"// Retrieve the created pacs.008 message\r",
													"const submittedPacs008Message = utils.addTenantId(null, JSON.parse(pm.globals.get(\"pacs008\")));\r",
													"\r",
													"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
													"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
													"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
													"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
													"\r",
													"// Load deconstructued identifier variables into global variables\r",
													"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
													"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
													"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
													"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
													"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
													"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
													"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
													"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
													"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
													"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
													"\r",
													"xprtnDtTm = utils.timestampAtTMinus(-10, \"m\");\r",
													"\r",
													"// Set up the condition\r",
													"\r",
													"console.log(`Override incepts at ${utils.getTimestampNow()}`);\r",
													"\r",
													"messageBody = {\r",
													"  \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09\",\"pacs.008.001.10\",\"pacs.002.001.12\"],\r",
													"  \"condTp\":\"override\",\r",
													"  \"prsptv\":\"both\",\r",
													"  \"xprtnDtTm\": xprtnDtTm,\r",
													"  \"condRsn\":\"Default Test Condition\",\r",
													"  \"ntty\":\r",
													"  {\r",
													"    \"id\": `${dbtrNttyId.id}`,\r",
													"    \"schmeNm\":\r",
													"    {\r",
													"      \"prtry\":\"TAZAMA_EID\"\r",
													"    }\r",
													"  },\r",
													"  \"forceCret\":true,\r",
													"  \"usr\":\"POSTMAN\"\r",
													"}\r",
													"\r",
													"// Set up body variables\r",
													"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
													"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
											"host": [
												"{{tazamaAdminUrl}}{{path-admin-api-version}}"
											],
											"path": [
												"{{path-entity-condition}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('debtorId');\r",
													"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
													"let cdtrId = pm.globals.get('creditorId');\r",
													"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
													"\r",
													"// Hacky workaround for testing the timeout of the submission of the pacs002 after this test\r",
													"pm.globals.set('responseTimedOut', true);\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ dbtrId,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ dbtrAcctId,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ 'fsp001',\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Post pacs.002 to TMS API - TIMEOUT EXPECTED",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"// Hacky workaround for testing the timeout of the submission of the pacs002\r",
													"pm.globals.set('responseTimedOut', false);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`No alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													"\r",
													"pm.test(`Request does not complete within specified timeout of ${pm.globals.get('timeoutLimit')}`, function () {\r",
													"    pm.expect(pm.response.responseTime).to.be.above(4000);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"NALT\";\r",
													"const expectedBlockingOutcome = \"override\";\r",
													"const expectedReviewFlag = false;\r",
													"const expectedTypologyAlert = false;\r",
													"const expectedTypologyInterdiction = false;\r",
													"const expectedResponseTimedOut = true;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });\r",
													"\r",
													"pm.test(`No response received at EFRuP interdiction service before timeout`, function () {\r",
													"        pm.expect(pm.globals.get('responseTimedOut')).to.be.eql(expectedResponseTimedOut);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('debtorId');\r",
													"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
													"let cdtrId = pm.globals.get('creditorId');\r",
													"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
													"\r",
													"// Hacky workaround for testing the timeout of the submission of the pacs002 after this test\r",
													"pm.globals.set('responseTimedOut', true);\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ dbtrId,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ dbtrAcctId,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ 'fsp001',\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Post pacs.002 to TMS API - TIMEOUT EXPECTED",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"// Hacky workaround for testing the timeout of the submission of the pacs002\r",
													"pm.globals.set('responseTimedOut', false);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`No alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													"\r",
													"pm.test(`Request does not complete within specified timeout of ${pm.globals.get('timeoutLimit')}`, function () {\r",
													"    pm.expect(pm.response.responseTime).to.be.above(4000);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"ALRT\";\r",
													"const expectedBlockingOutcome = \"override\";\r",
													"const expectedReviewFlag = true;\r",
													"const expectedTypologyAlert = true;\r",
													"const expectedTypologyInterdiction = false;\r",
													"const expectedResponseTimedOut = true;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });\r",
													"\r",
													"pm.test(`No response received at EFRuP interdiction service before timeout`, function () {\r",
													"        pm.expect(pm.globals.get('responseTimedOut')).to.be.eql(expectedResponseTimedOut);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('debtorId');\r",
													"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
													"let cdtrId = pm.globals.get('creditorId');\r",
													"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
													"\r",
													"// Hacky workaround for testing the timeout of the submission of the pacs002 after this test\r",
													"pm.globals.set('responseTimedOut', true);\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ dbtrId,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ dbtrAcctId,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ 'fsp001',\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Post pacs.002 to TMS API - TIMEOUT EXPECTED",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"// Hacky workaround for testing the timeout of the submission of the pacs002\r",
													"pm.globals.set('responseTimedOut', false);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`No alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													"\r",
													"pm.test(`Request does not complete within specified timeout of ${pm.globals.get('timeoutLimit')}`, function () {\r",
													"    pm.expect(pm.response.responseTime).to.be.above(4000);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"ALRT\";\r",
													"const expectedBlockingOutcome = \"override\";\r",
													"const expectedReviewFlag = true;\r",
													"const expectedTypologyAlert = true;\r",
													"const expectedTypologyInterdiction = true;\r",
													"const expectedResponseTimedOut = true;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });\r",
													"\r",
													"pm.test(`No response received at EFRuP interdiction service before timeout`, function () {\r",
													"        pm.expect(pm.globals.get('responseTimedOut')).to.be.eql(expectedResponseTimedOut);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "interdiction with override",
							"item": [
								{
									"name": "Before override",
									"item": [
										{
											"name": "Transaction 1 - Post pacs.008 to TMS API",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
															"\r",
															"let dbtrId = pm.globals.get('debtorId');\r",
															"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
															"let cdtrId = pm.globals.get('creditorId');\r",
															"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
															"\r",
															"// Hacky workaround for testing the timeout of the submission of the pacs002 after this test\r",
															"pm.globals.set('responseTimedOut', true);\r",
															"\r",
															"// ## Set up transaction eco-system\r",
															"\r",
															"messageSet = utils.createTransactionSetInMemory(\r",
															"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
															"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
															"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
															"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
															"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
															"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
															"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
															"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
															"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
															"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
															"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
															"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
															"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
															"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
															"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
															"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
															"    /* Description - null defaults random UUID ---------------------- */ null,\r",
															"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
															"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
															"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
															"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
															"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
															"    );\r",
															"\r",
															"let messageBody = pm.globals.get('pacs008');\r",
															"pm.globals.set('pacs008Stash', messageBody);\r",
															"pm.globals.set('messageBody', messageBody);"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{{messageBody}}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
													"host": [
														"{{tazamaTMSUrl}}{{path-tms-api-version}}"
													],
													"path": [
														"{{path-pacs008}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 1 - Post pacs.002 to TMS API",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"let messageBody = pm.globals.get('pacs002');\r",
															"pm.globals.set('messageBody', messageBody);"
														],
														"type": "text/javascript",
														"packages": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{{pacs002}}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs002}}",
													"host": [
														"{{tazamaTMSUrl}}{{path-tms-api-version}}"
													],
													"path": [
														"{{path-pacs002}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 1 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
														],
														"type": "text/javascript",
														"packages": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"const resJson = pm.response.json();\r",
															"\r",
															"const rulesPerTypologyCount = [3];\r",
															"const totalExpectedTypologies = 1;\r",
															"const expectedAlertStatus = \"NALT\";\r",
															"const expectedBlockingOutcome = \"none\";\r",
															"const expectedReviewFlag = false;\r",
															"const expectedTypologyAlert = false;\r",
															"const expectedTypologyInterdiction = false;\r",
															"\r",
															"const interdictionTypologies = [\r",
															"  \"999\"\r",
															"];\r",
															"const ruleDescriptions = {\r",
															"  \"901\": \"Number of outgoing transactions - debtor\",\r",
															"  \"902\": \"Number of incoming transactions - creditor\",\r",
															"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
															"}\r",
															"const typologyDescriptions = {\r",
															"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
															"}\r",
															"\r",
															"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
															"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
															"\r",
															"typologyCount = typologyResultsUnique.count();\r",
															"ruleCount = ruleResultsUnique.count();\r",
															"\r",
															"foundEFRuP = false;\r",
															"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
															"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
															"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
															"        foundEFRuP = true;\r",
															"    }\r",
															"}\r",
															"\r",
															"ruleWeightingTotal = 0;\r",
															"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
															"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
															"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
															"    }    \r",
															"}\r",
															"\r",
															"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
															"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
															"});\r",
															"\r",
															"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
															"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
															"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
															"    pm.expect(foundEFRuP).to.be.true;\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
															"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
															"});\r",
															"\r",
															"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedReviewFlag) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
															"    });\r",
															"} else {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
															"    });\r",
															"}\r",
															"\r",
															"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
															"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
															"    });"
														],
														"type": "text/javascript",
														"packages": {}
													}
												}
											],
											"request": {
												"auth": {
													"type": "bearer",
													"bearer": [
														{
															"key": "token",
															"value": "{{auth-token}}",
															"type": "string"
														}
													]
												},
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
													"host": [
														"{{arangoUrl}}"
													],
													"path": [
														"_db",
														"{{db_results}}",
														"_api",
														"cursor"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 2 - Post pacs.008 to TMS API",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
															"\r",
															"let dbtrId = pm.globals.get('debtorId');\r",
															"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
															"let cdtrId = pm.globals.get('creditorId');\r",
															"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
															"\r",
															"// Hacky workaround for testing the timeout of the submission of the pacs002 after this test\r",
															"pm.globals.set('responseTimedOut', true);\r",
															"\r",
															"// ## Set up transaction eco-system\r",
															"\r",
															"messageSet = utils.createTransactionSetInMemory(\r",
															"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
															"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
															"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
															"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
															"    /* Debtor ID - null defaults random UUID ------------------------ */ dbtrId,\r",
															"    /* Debtor Account ID - null defaults random UUID ---------------- */ dbtrAcctId,\r",
															"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ 'fsp001',\r",
															"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
															"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
															"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
															"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
															"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
															"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
															"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
															"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
															"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
															"    /* Description - null defaults random UUID ---------------------- */ null,\r",
															"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
															"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
															"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
															"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
															"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
															"    );\r",
															"\r",
															"let messageBody = pm.globals.get('pacs008');\r",
															"pm.globals.set('messageBody', messageBody);"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{{messageBody}}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
													"host": [
														"{{tazamaTMSUrl}}{{path-tms-api-version}}"
													],
													"path": [
														"{{path-pacs008}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 2 - Post pacs.002 to TMS API",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"let messageBody = pm.globals.get('pacs002');\r",
															"pm.globals.set('messageBody', messageBody);"
														],
														"type": "text/javascript",
														"packages": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{{pacs002}}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs002}}",
													"host": [
														"{{tazamaTMSUrl}}{{path-tms-api-version}}"
													],
													"path": [
														"{{path-pacs002}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 2 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
														],
														"type": "text/javascript",
														"packages": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"const resJson = pm.response.json();\r",
															"\r",
															"const rulesPerTypologyCount = [3];\r",
															"const totalExpectedTypologies = 1;\r",
															"const expectedAlertStatus = \"ALRT\";\r",
															"const expectedBlockingOutcome = \"none\";\r",
															"const expectedReviewFlag = true;\r",
															"const expectedTypologyAlert = true;\r",
															"const expectedTypologyInterdiction = false;\r",
															"\r",
															"const interdictionTypologies = [\r",
															"  \"999\"\r",
															"];\r",
															"const ruleDescriptions = {\r",
															"  \"901\": \"Number of outgoing transactions - debtor\",\r",
															"  \"902\": \"Number of incoming transactions - creditor\",\r",
															"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
															"}\r",
															"const typologyDescriptions = {\r",
															"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
															"}\r",
															"\r",
															"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
															"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
															"\r",
															"typologyCount = typologyResultsUnique.count();\r",
															"ruleCount = ruleResultsUnique.count();\r",
															"\r",
															"foundEFRuP = false;\r",
															"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
															"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
															"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
															"        foundEFRuP = true;\r",
															"    }\r",
															"}\r",
															"\r",
															"ruleWeightingTotal = 0;\r",
															"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
															"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
															"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
															"    }    \r",
															"}\r",
															"\r",
															"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
															"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
															"});\r",
															"\r",
															"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
															"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
															"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
															"    pm.expect(foundEFRuP).to.be.true;\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
															"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
															"});\r",
															"\r",
															"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedReviewFlag) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
															"    });\r",
															"} else {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
															"    });\r",
															"}\r",
															"\r",
															"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
															"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
															"    });"
														],
														"type": "text/javascript",
														"packages": {}
													}
												}
											],
											"request": {
												"auth": {
													"type": "bearer",
													"bearer": [
														{
															"key": "token",
															"value": "{{auth-token}}",
															"type": "string"
														}
													]
												},
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
													"host": [
														"{{arangoUrl}}"
													],
													"path": [
														"_db",
														"{{db_results}}",
														"_api",
														"cursor"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 3 - Post pacs.008 to TMS API",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
															"\r",
															"let dbtrId = pm.globals.get('debtorId');\r",
															"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
															"let cdtrId = pm.globals.get('creditorId');\r",
															"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
															"\r",
															"// Hacky workaround for testing the timeout of the submission of the pacs002 after this test\r",
															"pm.globals.set('responseTimedOut', true);\r",
															"\r",
															"// ## Set up transaction eco-system\r",
															"\r",
															"messageSet = utils.createTransactionSetInMemory(\r",
															"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
															"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
															"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
															"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
															"    /* Debtor ID - null defaults random UUID ------------------------ */ dbtrId,\r",
															"    /* Debtor Account ID - null defaults random UUID ---------------- */ dbtrAcctId,\r",
															"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ 'fsp001',\r",
															"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
															"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
															"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
															"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
															"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
															"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
															"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
															"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
															"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
															"    /* Description - null defaults random UUID ---------------------- */ null,\r",
															"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
															"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
															"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
															"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
															"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
															"    );\r",
															"\r",
															"let messageBody = pm.globals.get('pacs008');\r",
															"pm.globals.set('messageBody', messageBody);"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{{messageBody}}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
													"host": [
														"{{tazamaTMSUrl}}{{path-tms-api-version}}"
													],
													"path": [
														"{{path-pacs008}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 3 - Post pacs.002 to TMS API - NO TIMEOUT EXPECTED",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
															"const responseDestination = `interdiction-service-tp`; // The NATS subject for the output retrieval\r",
															"const awaitReply = true; // Hold the phone for a callback\r",
															"\r",
															"let messageBody = pm.globals.get('pacs002');\r",
															"pm.globals.set('messageBody', messageBody);\r",
															"pm.globals.set('endpoint', endpoint);\r",
															"pm.globals.set('responseDestination', responseDestination);\r",
															"pm.globals.set('awaitReply', awaitReply);\r",
															""
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"const resJson = pm.response.json();\r",
															"console.log(resJson);\r",
															"\r",
															"// Hacky workaround for testing the timeout of the submission of the pacs002\r",
															"pm.globals.set('responseTimedOut', false);\r",
															"\r",
															"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});\r",
															"\r",
															"pm.test(`Interdiction alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
															"    pm.expect(resJson.edResponse.typologyResult.review).to.be.true;\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
													"host": [
														"{{natsUrl}}"
													],
													"path": [
														"{{nats-path-tms-api}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 3 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
														],
														"type": "text/javascript",
														"packages": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"const resJson = pm.response.json();\r",
															"\r",
															"const rulesPerTypologyCount = [3];\r",
															"const totalExpectedTypologies = 1;\r",
															"const expectedAlertStatus = \"ALRT\";\r",
															"const expectedBlockingOutcome = \"none\";\r",
															"const expectedReviewFlag = true;\r",
															"const expectedTypologyAlert = true;\r",
															"const expectedTypologyInterdiction = true;\r",
															"const expectedResponseTimedOut = false;\r",
															"\r",
															"const interdictionTypologies = [\r",
															"  \"999\"\r",
															"];\r",
															"const ruleDescriptions = {\r",
															"  \"901\": \"Number of outgoing transactions - debtor\",\r",
															"  \"902\": \"Number of incoming transactions - creditor\",\r",
															"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
															"}\r",
															"const typologyDescriptions = {\r",
															"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
															"}\r",
															"\r",
															"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
															"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
															"\r",
															"typologyCount = typologyResultsUnique.count();\r",
															"ruleCount = ruleResultsUnique.count();\r",
															"\r",
															"foundEFRuP = false;\r",
															"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
															"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
															"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
															"        foundEFRuP = true;\r",
															"    }\r",
															"}\r",
															"\r",
															"ruleWeightingTotal = 0;\r",
															"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
															"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
															"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
															"    }    \r",
															"}\r",
															"\r",
															"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
															"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
															"});\r",
															"\r",
															"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
															"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
															"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
															"    pm.expect(foundEFRuP).to.be.true;\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
															"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
															"});\r",
															"\r",
															"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedReviewFlag) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
															"    });\r",
															"} else {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
															"    });\r",
															"}\r",
															"\r",
															"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
															"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
															"    });\r",
															"\r",
															"pm.test(`Response received at EFRuP interdiction service before timeout`, function () {\r",
															"        pm.expect(pm.globals.get('responseTimedOut')).to.be.eql(expectedResponseTimedOut);\r",
															"    });"
														],
														"type": "text/javascript",
														"packages": {}
													}
												}
											],
											"request": {
												"auth": {
													"type": "bearer",
													"bearer": [
														{
															"key": "token",
															"value": "{{auth-token}}",
															"type": "string"
														}
													]
												},
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
													"host": [
														"{{arangoUrl}}"
													],
													"path": [
														"_db",
														"{{db_results}}",
														"_api",
														"cursor"
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "After override",
									"item": [
										{
											"name": "Create New Entity Condition Manually - Existing debtor",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"responseJSON = pm.response.json();\r",
															"let conditionResult = responseJSON.result.conditions;\r",
															"let conditionEntity = responseJSON.result.ntty;\r",
															"let requestMessage = responseJSON.message;\r",
															"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
															"let nttyId = pm.globals.get(\"dbtrNttyId\");\r",
															"let nttyIdSchme = pm.globals.get(\"dbtrNttyIdSchmeNm\");\r",
															"let tenantId = pm.globals.get(\"tenantId\");\r",
															"let targetEntityId = nttyId + nttyIdSchme;\r",
															"\r",
															"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
															"targetRequestMessage = \"New condition was saved successfully.\"\r",
															"\r",
															"pm.test(\"Status code is 200\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});\r",
															"\r",
															"pm.test(\"Result message matches target result message\", function () {\r",
															"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
															"});\r",
															"\r",
															"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
															"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
															"});\r",
															"\r",
															"pm.test(\"Result conditions array only contains a single condition\", function () {\r",
															"    pm.expect(conditionResult.length).to.be.eql(1);\r",
															"});\r",
															"\r",
															"let firstElement = conditionResult[0];\r",
															"\r",
															"pm.test(\"Result condition has a non-empty condId\", function () {\r",
															"    pm.expect(firstElement.condId).to.exist.and.not.be.empty;\r",
															"});\r",
															"\r",
															"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
															"    pm.expect(firstElement.condTp).to.be.eql(targetConditionResult.condTp);\r",
															"});\r",
															"\r",
															"if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
															"    pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
															"        pm.expect(firstElement.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
															"    });\r",
															"} else {    // if not, one must have been defaulted\r",
															"    pm.test(\"Result condition has a non-empty incptnDtTm\", function () {\r",
															"        pm.expect(firstElement.incptnDtTm).to.exist.and.not.be.empty;\r",
															"    });\r",
															"}\r",
															"\r",
															"if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
															"    pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
															"        pm.expect(firstElement.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
															"    });\r",
															"} else {    // if not, one must not have been defaulted\r",
															"    pm.test(\"Result condition does not have an xprtnDtTm\", function () {\r",
															"        pm.expect(firstElement.xprtnDtTm).to.not.exist;\r",
															"    });\r",
															"}\r",
															"\r",
															"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
															"    pm.expect(firstElement.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
															"});\r",
															"\r",
															"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
															"    pm.expect(firstElement.usr).to.be.eql(targetConditionResult.usr);\r",
															"});\r",
															"\r",
															"pm.test(\"Result condition has a non-empty creDtTm\", function () {\r",
															"    pm.expect(firstElement.creDtTm).to.exist.and.not.be.empty;\r",
															"});\r",
															"\r",
															"// create an array that only includes the perspective descriptions so that we can evaluate them easily\r",
															"let perspectives = firstElement.prsptvs.map(({ prsptv }) => prsptv);\r",
															"\r",
															"if (targetConditionResult.prsptv === \"both\") {\r",
															"    pm.test(\"Result prsptv array contains only 2 perspectives\", function () {\r",
															"        pm.expect(firstElement.prsptvs.length).to.be.eql(2);\r",
															"    });\r",
															"\r",
															"    let targetPerspectives = [\"governed_as_creditor_by\", \"governed_as_debtor_by\"];\r",
															"\r",
															"    pm.test(`Result prsptv array contains both ${JSON.stringify(targetPerspectives)} perspectives`, function () {\r",
															"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
															"    });\r",
															"\r",
															"} else if (targetConditionResult.prsptv === \"debtor\") {\r",
															"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
															"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
															"    });\r",
															"\r",
															"    let targetPerspectives = [\"governed_as_debtor_by\"];\r",
															"\r",
															"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
															"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
															"    });\r",
															"\r",
															"} else if (targetConditionResult.prsptv === \"creditor\") {\r",
															"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
															"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
															"    });\r",
															"\r",
															"    let targetPerspectives = [\"governed_as_creditor_by\"];\r",
															"\r",
															"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
															"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
															"    });\r",
															"\r",
															"};\r",
															"\r",
															"for (let i = 0; i < firstElement.prsptvs.length; i++) {   // for each perspective\r",
															"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} contains a non-empty evtTp array`, function () {\r",
															"        pm.expect(firstElement.prsptvs[i].evtTp).to.be.an('array').and.not.be.empty;\r",
															"    });\r",
															"\r",
															"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} evtTp array matches submitted condition`, function () {\r",
															"        pm.expect(firstElement.prsptvs[i].evtTp).to.include.members(targetConditionResult.evtTp);\r",
															"    });\r",
															"\r",
															"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
															"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches submitted condition`, function () {\r",
															"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
															"        });\r",
															"    } else {    // if not, one must have been defaulted\r",
															"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches created condition incptDtTm`, function () {\r",
															"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.eql(firstElement.incptnDtTm);\r",
															"        });\r",
															"    }\r",
															"\r",
															"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
															"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} xprtnDtTm matches submitted condition`, function () {\r",
															"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
															"        });\r",
															"    } else {    // if not, one must not have been defaulted\r",
															"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} does not have an xprtnDtTm`, function () {\r",
															"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.not.exist;\r",
															"        });\r",
															"    }\r",
															"\r",
															"}\r",
															"\r",
															"pm.test(\"Result condition ntty.id matches submitted condition\", function () {\r",
															"    pm.expect(conditionEntity.id).to.be.eql(targetConditionResult.ntty.id);\r",
															"});\r",
															"\r",
															"pm.test(\"Result condition ntty.schmeNm.prtry matches submitted condition\", function () {\r",
															"    pm.expect(conditionEntity.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
															"});\r",
															"\r",
															"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetEntityId, false);;\r",
															"\r",
															"await pm.sendRequest(postRequest, (error, response) => {\r",
															"    if (utils.getLogLevel() === 'DEBUG') {\r",
															"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
															"    }\r",
															"    databaseConditionResult = response.json().data;\r",
															"\r",
															"    if (utils.getLogLevel() === 'DEBUG') {\r",
															"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
															"    }\r",
															"\r",
															"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
															"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
															"\r",
															"    pm.test(`Only one condition for entity [${targetEntityId}] exists in the database`, function () {\r",
															"        pm.expect(graphConditionList.length).to.eql(1);\r",
															"    });\r",
															"\r",
															"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
															"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
															"            pm.expect(conditionGraph.v[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
															"        });\r",
															"    }\r",
															"\r",
															"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
															"        pm.expect(conditionGraph.v[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
															"    });\r",
															"\r",
															"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
															"        pm.expect(conditionGraph.v[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
															"    });\r",
															"\r",
															"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
															"        pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
															"            pm.expect(conditionGraph.v[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
															"        });\r",
															"    } else {    // if not, one must have been defaulted\r",
															"        pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
															"            pm.expect(conditionGraph.v[0].incptnDtTm).to.exist.and.not.be.empty;\r",
															"        });\r",
															"    }\r",
															"\r",
															"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
															"        pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
															"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
															"        });\r",
															"    } else {    // if not, one must not have been defaulted\r",
															"        pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
															"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.not.exist;\r",
															"        });\r",
															"    }\r",
															"\r",
															"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
															"        pm.expect(conditionGraph.v[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
															"    });\r",
															"\r",
															"    pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
															"        pm.expect(conditionGraph.v[0].ntty.id).to.be.eql(targetConditionResult.ntty.id);\r",
															"    });\r",
															"\r",
															"    pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
															"        pm.expect(conditionGraph.v[0].ntty.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
															"    });\r",
															"\r",
															"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
															"        pm.expect(conditionGraph.v[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
															"    });\r",
															"\r",
															"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
															"        pm.expect(conditionGraph.v[0].usr).to.be.eql(targetConditionResult.usr);\r",
															"    });\r",
															"\r",
															"    let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, conditionGraph.v[0]._key);\r",
															"\r",
															"    pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
															"        pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
															"    });\r",
															"\r",
															"    pm.test(\"Database 'governed_as_creditor_by' edge exists\", function () {\r",
															"        pm.expect(edgeList).to.include.members([\"governed_as_creditor_by\"]);\r",
															"    });\r",
															"\r",
															"    pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
															"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
															"    });\r",
															"\r",
															"    pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
															"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
															"    });\r",
															"\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {}
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
															"\r",
															"// Obliterate the current contents of the global variables\r",
															"// Retrieve the created pacs.008 message\r",
															"\r",
															"const submittedPacs008Message = JSON.parse(pm.globals.get('pacs008Stash'));\r",
															"pm.globals.set('pacs008', pm.globals.get('pacs008Stash'));\r",
															"\r",
															"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
															"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
															"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
															"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
															"\r",
															"// Load deconstructued identifier variables into global variables\r",
															"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
															"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
															"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
															"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
															"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
															"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
															"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
															"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
															"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
															"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
															"\r",
															"xprtnDtTm = utils.timestampAtTMinus(-10, \"m\");\r",
															"\r",
															"// Set up the condition\r",
															"\r",
															"console.log(`Override incepts at ${utils.getTimestampNow()}`);\r",
															"\r",
															"messageBody = {\r",
															"  \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09\",\"pacs.008.001.10\",\"pacs.002.001.12\"],\r",
															"  \"condTp\":\"override\",\r",
															"  \"prsptv\":\"both\",\r",
															"  \"xprtnDtTm\": xprtnDtTm,\r",
															"  \"condRsn\":\"Default Test Condition\",\r",
															"  \"ntty\":\r",
															"  {\r",
															"    \"id\": `${dbtrNttyId.id}`,\r",
															"    \"schmeNm\":\r",
															"    {\r",
															"      \"prtry\":\"TAZAMA_EID\"\r",
															"    }\r",
															"  },\r",
															"  \"forceCret\":true,\r",
															"  \"usr\":\"POSTMAN\"\r",
															"}\r",
															"\r",
															"// Set up body variables\r",
															"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
															"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
														],
														"type": "text/javascript",
														"packages": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{{messageBody}}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
													"host": [
														"{{tazamaAdminUrl}}{{path-admin-api-version}}"
													],
													"path": [
														"{{path-entity-condition}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 4 - Post pacs.008 to TMS API",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
															"\r",
															"let dbtrId = pm.globals.get('debtorId');\r",
															"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
															"let cdtrId = pm.globals.get('creditorId');\r",
															"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
															"\r",
															"// Hacky workaround for testing the timeout of the submission of the pacs002 after this test\r",
															"pm.globals.set('responseTimedOut', true);\r",
															"\r",
															"// ## Set up transaction eco-system\r",
															"\r",
															"messageSet = utils.createTransactionSetInMemory(\r",
															"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
															"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
															"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
															"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
															"    /* Debtor ID - null defaults random UUID ------------------------ */ dbtrId,\r",
															"    /* Debtor Account ID - null defaults random UUID ---------------- */ dbtrAcctId,\r",
															"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ 'fsp001',\r",
															"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
															"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
															"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
															"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
															"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
															"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
															"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
															"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
															"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
															"    /* Description - null defaults random UUID ---------------------- */ null,\r",
															"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
															"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
															"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
															"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
															"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
															"    );\r",
															"\r",
															"let messageBody = pm.globals.get('pacs008');\r",
															"pm.globals.set('messageBody', messageBody);"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{{messageBody}}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
													"host": [
														"{{tazamaTMSUrl}}{{path-tms-api-version}}"
													],
													"path": [
														"{{path-pacs008}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 4 - Post pacs.002 to TMS API - TIMEOUT EXPECTED",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
															"const responseDestination = `interdiction-service-tp`; // The NATS subject for the output retrieval\r",
															"const awaitReply = true; // Hold the phone for a callback\r",
															"\r",
															"let messageBody = pm.globals.get('pacs002');\r",
															"pm.globals.set('messageBody', messageBody);\r",
															"pm.globals.set('endpoint', endpoint);\r",
															"pm.globals.set('responseDestination', responseDestination);\r",
															"pm.globals.set('awaitReply', awaitReply);\r",
															""
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"const resJson = pm.response.json();\r",
															"console.log(resJson);\r",
															"\r",
															"// Hacky workaround for testing the timeout of the submission of the pacs002\r",
															"pm.globals.set('responseTimedOut', false);\r",
															"\r",
															"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});\r",
															"\r",
															"pm.test(`No alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
															"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
															"});\r",
															"\r",
															"pm.test(`Request does not complete within specified timeout of ${pm.globals.get('timeoutLimit')}`, function () {\r",
															"    pm.expect(pm.response.responseTime).to.be.above(4000);\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
													"host": [
														"{{natsUrl}}"
													],
													"path": [
														"{{nats-path-tms-api}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 4 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
														],
														"type": "text/javascript",
														"packages": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"const resJson = pm.response.json();\r",
															"\r",
															"const rulesPerTypologyCount = [3];\r",
															"const totalExpectedTypologies = 1;\r",
															"const expectedAlertStatus = \"ALRT\";\r",
															"const expectedBlockingOutcome = \"override\";\r",
															"const expectedReviewFlag = true;\r",
															"const expectedTypologyAlert = true;\r",
															"const expectedTypologyInterdiction = true;\r",
															"const expectedResponseTimedOut = true;\r",
															"\r",
															"const interdictionTypologies = [\r",
															"  \"999\"\r",
															"];\r",
															"const ruleDescriptions = {\r",
															"  \"901\": \"Number of outgoing transactions - debtor\",\r",
															"  \"902\": \"Number of incoming transactions - creditor\",\r",
															"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
															"}\r",
															"const typologyDescriptions = {\r",
															"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
															"}\r",
															"\r",
															"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
															"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
															"\r",
															"typologyCount = typologyResultsUnique.count();\r",
															"ruleCount = ruleResultsUnique.count();\r",
															"\r",
															"foundEFRuP = false;\r",
															"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
															"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
															"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
															"        foundEFRuP = true;\r",
															"    }\r",
															"}\r",
															"\r",
															"ruleWeightingTotal = 0;\r",
															"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
															"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
															"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
															"    }    \r",
															"}\r",
															"\r",
															"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
															"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
															"});\r",
															"\r",
															"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
															"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
															"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
															"    pm.expect(foundEFRuP).to.be.true;\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
															"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
															"});\r",
															"\r",
															"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedReviewFlag) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
															"    });\r",
															"} else {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
															"    });\r",
															"}\r",
															"\r",
															"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
															"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
															"    });\r",
															"\r",
															"pm.test(`No response received at EFRuP interdiction service before timeout`, function () {\r",
															"        pm.expect(pm.globals.get('responseTimedOut')).to.be.eql(expectedResponseTimedOut);\r",
															"    });"
														],
														"type": "text/javascript",
														"packages": {}
													}
												}
											],
											"request": {
												"auth": {
													"type": "bearer",
													"bearer": [
														{
															"key": "token",
															"value": "{{auth-token}}",
															"type": "string"
														}
													]
												},
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
													"host": [
														"{{arangoUrl}}"
													],
													"path": [
														"_db",
														"{{db_results}}",
														"_api",
														"cursor"
													]
												}
											},
											"response": []
										}
									]
								}
							]
						}
					]
				},
				{
					"name": "dbtrId - perspective=debtor",
					"item": [
						{
							"name": "non-overridable block",
							"item": [
								{
									"name": "Create New Entity Condition Manually - Unknown debtor entity",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"responseJSON = pm.response.json();\r",
													"let conditionResult = responseJSON.result.conditions;\r",
													"let conditionEntity = responseJSON.result.ntty;\r",
													"let requestMessage = responseJSON.message;\r",
													"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
													"let nttyId = pm.globals.get(\"dbtrNttyId\");\r",
													"let nttyIdSchme = pm.globals.get(\"dbtrNttyIdSchmeNm\");\r",
													"let tenantId = pm.globals.get(\"tenantId\");\r",
													"let targetEntityId = nttyId + nttyIdSchme;\r",
													"\r",
													"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
													"targetRequestMessage = \"New condition was saved successfully.\"\r",
													"\r",
													"pm.test(\"Status code is 200\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(\"Result message matches target result message\", function () {\r",
													"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
													"});\r",
													"\r",
													"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
													"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
													"});\r",
													"\r",
													"pm.test(\"Result conditions array only contains a single condition\", function () {\r",
													"    pm.expect(conditionResult.length).to.be.eql(1);\r",
													"});\r",
													"\r",
													"let firstElement = conditionResult[0];\r",
													"\r",
													"pm.test(\"Result condition has a non-empty condId\", function () {\r",
													"    pm.expect(firstElement.condId).to.exist.and.not.be.empty;\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.condTp).to.be.eql(targetConditionResult.condTp);\r",
													"});\r",
													"\r",
													"if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"    pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
													"        pm.expect(firstElement.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"    });\r",
													"} else {    // if not, one must have been defaulted\r",
													"    pm.test(\"Result condition has a non-empty incptnDtTm\", function () {\r",
													"        pm.expect(firstElement.incptnDtTm).to.exist.and.not.be.empty;\r",
													"    });\r",
													"}\r",
													"\r",
													"if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"    pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
													"        pm.expect(firstElement.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"    });\r",
													"} else {    // if not, one must not have been defaulted\r",
													"    pm.test(\"Result condition does not have an xprtnDtTm\", function () {\r",
													"        pm.expect(firstElement.xprtnDtTm).to.not.exist;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.usr).to.be.eql(targetConditionResult.usr);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition has a non-empty creDtTm\", function () {\r",
													"    pm.expect(firstElement.creDtTm).to.exist.and.not.be.empty;\r",
													"});\r",
													"\r",
													"// create an array that only includes the perspective descriptions so that we can evaluate them easily\r",
													"let perspectives = firstElement.prsptvs.map(({ prsptv }) => prsptv);\r",
													"\r",
													"if (targetConditionResult.prsptv === \"both\") {\r",
													"    pm.test(\"Result prsptv array contains only 2 perspectives\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(2);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_creditor_by\", \"governed_as_debtor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains both ${JSON.stringify(targetPerspectives)} perspectives`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"} else if (targetConditionResult.prsptv === \"debtor\") {\r",
													"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_debtor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"} else if (targetConditionResult.prsptv === \"creditor\") {\r",
													"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_creditor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"};\r",
													"\r",
													"for (let i = 0; i < firstElement.prsptvs.length; i++) {   // for each perspective\r",
													"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} contains a non-empty evtTp array`, function () {\r",
													"        pm.expect(firstElement.prsptvs[i].evtTp).to.be.an('array').and.not.be.empty;\r",
													"    });\r",
													"\r",
													"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} evtTp array matches submitted condition`, function () {\r",
													"        pm.expect(firstElement.prsptvs[i].evtTp).to.include.members(targetConditionResult.evtTp);\r",
													"    });\r",
													"\r",
													"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches submitted condition`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must have been defaulted\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches created condition incptDtTm`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.eql(firstElement.incptnDtTm);\r",
													"        });\r",
													"    }\r",
													"\r",
													"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} xprtnDtTm matches submitted condition`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must not have been defaulted\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} does not have an xprtnDtTm`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.not.exist;\r",
													"        });\r",
													"    }\r",
													"\r",
													"}\r",
													"\r",
													"pm.test(\"Result condition ntty.id matches submitted condition\", function () {\r",
													"    pm.expect(conditionEntity.id).to.be.eql(targetConditionResult.ntty.id);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"    pm.expect(conditionEntity.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
													"});\r",
													"\r",
													"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetEntityId, false);;\r",
													"\r",
													"await pm.sendRequest(postRequest, (error, response) => {\r",
													"    if (utils.getLogLevel() === 'DEBUG') {\r",
													"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
													"    }\r",
													"    databaseConditionResult = response.json().data;\r",
													"\r",
													"    if (utils.getLogLevel() === 'DEBUG') {\r",
													"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
													"    }\r",
													"\r",
													"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
													"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
													"\r",
													"    pm.test(`Only one condition for entity [${targetEntityId}] exists in the database`, function () {\r",
													"        pm.expect(graphConditionList.length).to.eql(1);\r",
													"    });\r",
													"\r",
													"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
													"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
													"            pm.expect(conditionGraph.v[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
													"        });\r",
													"    }\r",
													"\r",
													"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
													"    });\r",
													"\r",
													"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"        pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
													"            pm.expect(conditionGraph.v[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must have been defaulted\r",
													"        pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
													"            pm.expect(conditionGraph.v[0].incptnDtTm).to.exist.and.not.be.empty;\r",
													"        });\r",
													"    }\r",
													"\r",
													"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"        pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
													"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must not have been defaulted\r",
													"        pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
													"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.not.exist;\r",
													"        });\r",
													"    }\r",
													"\r",
													"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].ntty.id).to.be.eql(targetConditionResult.ntty.id);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].ntty.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].usr).to.be.eql(targetConditionResult.usr);\r",
													"    });\r",
													"\r",
													"    let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, conditionGraph.v[0]._key);\r",
													"\r",
													"    pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
													"        pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database 'governed_as_creditor_by' edge does not exist\", function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
													"    });\r",
													"\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"// Obliterate the current contents of the global variables\r",
													"pm.globals.clear();\r",
													"\r",
													"// Set up the transaction (in memory)\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ 3600000,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"\r",
													"// Retrieve the created pacs.008 message\r",
													"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
													"\r",
													"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
													"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
													"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
													"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
													"\r",
													"// Load deconstructued identifier variables into global variables\r",
													"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
													"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
													"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
													"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
													"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
													"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
													"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
													"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
													"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
													"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
													"\r",
													"// Set up the condition\r",
													"\r",
													"messageBody = {\r",
													"  \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09\",\"pacs.008.001.10\",\"pacs.002.001.12\"],\r",
													"  \"condTp\":\"non-overridable-block\",\r",
													"  \"prsptv\":\"debtor\",\r",
													"  \"condRsn\":\"Blocking payments by debtor only\",\r",
													"  \"ntty\":\r",
													"  {\r",
													"    \"id\": `${dbtrNttyId.id}`,\r",
													"    \"schmeNm\":\r",
													"    {\r",
													"      \"prtry\":\"TAZAMA_EID\"\r",
													"    }\r",
													"  },\r",
													"  \"forceCret\":true,\r",
													"  \"usr\":\"POSTMAN\"\r",
													"}\r",
													"\r",
													"// Set up body variables\r",
													"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
													"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
											"host": [
												"{{tazamaAdminUrl}}{{path-admin-api-version}}"
											],
											"path": [
												"{{path-entity-condition}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('debtorId');\r",
													"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
													"let cdtrId = pm.globals.get('creditorId');\r",
													"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ dbtrId,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ dbtrAcctId,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ 'fsp001',\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Post pacs.002 to TMS API - NO TIMEOUT EXPECTED",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`Alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"ALRT\";\r",
													"const expectedBlockingOutcome = \"block\";\r",
													"const expectedReviewFlag = true;\r",
													"const expectedTypologyAlert = false;\r",
													"const expectedTypologyInterdiction = false;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('debtorId');\r",
													"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
													"let cdtrId = pm.globals.get('creditorId');\r",
													"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ dbtrId,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ dbtrAcctId,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ 'fsp001',\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Post pacs.002 to TMS API - NO TIMEOUT EXPECTED",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`Alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"ALRT\";\r",
													"const expectedBlockingOutcome = \"block\";\r",
													"const expectedReviewFlag = true;\r",
													"const expectedTypologyAlert = true;\r",
													"const expectedTypologyInterdiction = false;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('debtorId');\r",
													"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
													"let cdtrId = pm.globals.get('creditorId');\r",
													"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ dbtrId,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ dbtrAcctId,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ 'fsp001',\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Post pacs.002 to TMS API - NO TIMEOUT EXPECTED",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`Alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"ALRT\";\r",
													"const expectedBlockingOutcome = \"block\";\r",
													"const expectedReviewFlag = true;\r",
													"const expectedTypologyAlert = true;\r",
													"const expectedTypologyInterdiction = true;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "overridable block",
							"item": [
								{
									"name": "Create New Entity Condition Manually - Unknown debtor entity",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"responseJSON = pm.response.json();\r",
													"let conditionResult = responseJSON.result.conditions;\r",
													"let conditionEntity = responseJSON.result.ntty;\r",
													"let requestMessage = responseJSON.message;\r",
													"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
													"let nttyId = pm.globals.get(\"dbtrNttyId\");\r",
													"let nttyIdSchme = pm.globals.get(\"dbtrNttyIdSchmeNm\");\r",
													"let tenantId = pm.globals.get(\"tenantId\");\r",
													"let targetEntityId = nttyId + nttyIdSchme;\r",
													"\r",
													"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
													"targetRequestMessage = \"New condition was saved successfully.\"\r",
													"\r",
													"pm.test(\"Status code is 200\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(\"Result message matches target result message\", function () {\r",
													"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
													"});\r",
													"\r",
													"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
													"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
													"});\r",
													"\r",
													"pm.test(\"Result conditions array only contains a single condition\", function () {\r",
													"    pm.expect(conditionResult.length).to.be.eql(1);\r",
													"});\r",
													"\r",
													"let firstElement = conditionResult[0];\r",
													"\r",
													"pm.test(\"Result condition has a non-empty condId\", function () {\r",
													"    pm.expect(firstElement.condId).to.exist.and.not.be.empty;\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.condTp).to.be.eql(targetConditionResult.condTp);\r",
													"});\r",
													"\r",
													"if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"    pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
													"        pm.expect(firstElement.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"    });\r",
													"} else {    // if not, one must have been defaulted\r",
													"    pm.test(\"Result condition has a non-empty incptnDtTm\", function () {\r",
													"        pm.expect(firstElement.incptnDtTm).to.exist.and.not.be.empty;\r",
													"    });\r",
													"}\r",
													"\r",
													"if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"    pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
													"        pm.expect(firstElement.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"    });\r",
													"} else {    // if not, one must not have been defaulted\r",
													"    pm.test(\"Result condition does not have an xprtnDtTm\", function () {\r",
													"        pm.expect(firstElement.xprtnDtTm).to.not.exist;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.usr).to.be.eql(targetConditionResult.usr);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition has a non-empty creDtTm\", function () {\r",
													"    pm.expect(firstElement.creDtTm).to.exist.and.not.be.empty;\r",
													"});\r",
													"\r",
													"// create an array that only includes the perspective descriptions so that we can evaluate them easily\r",
													"let perspectives = firstElement.prsptvs.map(({ prsptv }) => prsptv);\r",
													"\r",
													"if (targetConditionResult.prsptv === \"both\") {\r",
													"    pm.test(\"Result prsptv array contains only 2 perspectives\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(2);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_creditor_by\", \"governed_as_debtor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains both ${JSON.stringify(targetPerspectives)} perspectives`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"} else if (targetConditionResult.prsptv === \"debtor\") {\r",
													"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_debtor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"} else if (targetConditionResult.prsptv === \"creditor\") {\r",
													"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_creditor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"};\r",
													"\r",
													"for (let i = 0; i < firstElement.prsptvs.length; i++) {   // for each perspective\r",
													"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} contains a non-empty evtTp array`, function () {\r",
													"        pm.expect(firstElement.prsptvs[i].evtTp).to.be.an('array').and.not.be.empty;\r",
													"    });\r",
													"\r",
													"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} evtTp array matches submitted condition`, function () {\r",
													"        pm.expect(firstElement.prsptvs[i].evtTp).to.include.members(targetConditionResult.evtTp);\r",
													"    });\r",
													"\r",
													"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches submitted condition`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must have been defaulted\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches created condition incptDtTm`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.eql(firstElement.incptnDtTm);\r",
													"        });\r",
													"    }\r",
													"\r",
													"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} xprtnDtTm matches submitted condition`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must not have been defaulted\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} does not have an xprtnDtTm`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.not.exist;\r",
													"        });\r",
													"    }\r",
													"\r",
													"}\r",
													"\r",
													"pm.test(\"Result condition ntty.id matches submitted condition\", function () {\r",
													"    pm.expect(conditionEntity.id).to.be.eql(targetConditionResult.ntty.id);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"    pm.expect(conditionEntity.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
													"});\r",
													"\r",
													"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetEntityId, false);;\r",
													"\r",
													"await pm.sendRequest(postRequest, (error, response) => {\r",
													"    if (utils.getLogLevel() === 'DEBUG') {\r",
													"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
													"    }\r",
													"    databaseConditionResult = response.json().data;\r",
													"\r",
													"    if (utils.getLogLevel() === 'DEBUG') {\r",
													"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
													"    }\r",
													"\r",
													"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
													"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
													"\r",
													"    pm.test(`Only one condition for entity [${targetEntityId}] exists in the database`, function () {\r",
													"        pm.expect(graphConditionList.length).to.eql(1);\r",
													"    });\r",
													"\r",
													"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
													"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
													"            pm.expect(conditionGraph.v[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
													"        });\r",
													"    }\r",
													"\r",
													"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
													"    });\r",
													"\r",
													"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"        pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
													"            pm.expect(conditionGraph.v[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must have been defaulted\r",
													"        pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
													"            pm.expect(conditionGraph.v[0].incptnDtTm).to.exist.and.not.be.empty;\r",
													"        });\r",
													"    }\r",
													"\r",
													"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"        pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
													"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must not have been defaulted\r",
													"        pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
													"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.not.exist;\r",
													"        });\r",
													"    }\r",
													"\r",
													"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].ntty.id).to.be.eql(targetConditionResult.ntty.id);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].ntty.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].usr).to.be.eql(targetConditionResult.usr);\r",
													"    });\r",
													"\r",
													"    let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, conditionGraph.v[0]._key);\r",
													"\r",
													"    pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
													"        pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database 'governed_as_creditor_by' edge does not exist\", function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
													"    });\r",
													"\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"// Obliterate the current contents of the global variables\r",
													"pm.globals.clear();\r",
													"\r",
													"// Set up the transaction (in memory)\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ 3600000,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"\r",
													"// Retrieve the created pacs.008 message\r",
													"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
													"\r",
													"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
													"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
													"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
													"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
													"\r",
													"// Load deconstructued identifier variables into global variables\r",
													"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
													"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
													"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
													"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
													"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
													"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
													"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
													"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
													"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
													"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
													"\r",
													"// Set up the condition\r",
													"\r",
													"messageBody = {\r",
													"  \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09\",\"pacs.008.001.10\",\"pacs.002.001.12\"],\r",
													"  \"condTp\":\"overridable-block\",\r",
													"  \"prsptv\":\"debtor\",\r",
													"  \"condRsn\":\"Default Test Condition\",\r",
													"  \"ntty\":\r",
													"  {\r",
													"    \"id\": `${dbtrNttyId.id}`,\r",
													"    \"schmeNm\":\r",
													"    {\r",
													"      \"prtry\":\"TAZAMA_EID\"\r",
													"    }\r",
													"  },\r",
													"  \"forceCret\":true,\r",
													"  \"usr\":\"POSTMAN\"\r",
													"}\r",
													"\r",
													"// Set up body variables\r",
													"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
													"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
											"host": [
												"{{tazamaAdminUrl}}{{path-admin-api-version}}"
											],
											"path": [
												"{{path-entity-condition}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('debtorId');\r",
													"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
													"let cdtrId = pm.globals.get('creditorId');\r",
													"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ dbtrId,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ dbtrAcctId,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ 'fsp001',\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Post pacs.002 to TMS API - NO TIMEOUT EXPECTED",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`Alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"ALRT\";\r",
													"const expectedBlockingOutcome = \"block\";\r",
													"const expectedReviewFlag = true;\r",
													"const expectedTypologyAlert = false;\r",
													"const expectedTypologyInterdiction = false;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('debtorId');\r",
													"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
													"let cdtrId = pm.globals.get('creditorId');\r",
													"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ dbtrId,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ dbtrAcctId,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ 'fsp001',\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Post pacs.002 to TMS API - NO TIMEOUT EXPECTED",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`Alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"ALRT\";\r",
													"const expectedBlockingOutcome = \"block\";\r",
													"const expectedReviewFlag = true;\r",
													"const expectedTypologyAlert = true;\r",
													"const expectedTypologyInterdiction = false;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('debtorId');\r",
													"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
													"let cdtrId = pm.globals.get('creditorId');\r",
													"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ dbtrId,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ dbtrAcctId,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ 'fsp001',\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Post pacs.002 to TMS API - NO TIMEOUT EXPECTED",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`Alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"ALRT\";\r",
													"const expectedBlockingOutcome = \"block\";\r",
													"const expectedReviewFlag = true;\r",
													"const expectedTypologyAlert = true;\r",
													"const expectedTypologyInterdiction = true;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "overridable block with override",
							"item": [
								{
									"name": "Create New Entity Condition Manually - Unknown debtor entity",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"responseJSON = pm.response.json();\r",
													"let conditionResult = responseJSON.result.conditions;\r",
													"let conditionEntity = responseJSON.result.ntty;\r",
													"let requestMessage = responseJSON.message;\r",
													"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
													"let nttyId = pm.globals.get(\"dbtrNttyId\");\r",
													"let nttyIdSchme = pm.globals.get(\"dbtrNttyIdSchmeNm\");\r",
													"let tenantId = pm.globals.get(\"tenantId\");\r",
													"let targetEntityId = nttyId + nttyIdSchme;\r",
													"\r",
													"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
													"targetRequestMessage = \"New condition was saved successfully.\"\r",
													"\r",
													"pm.test(\"Status code is 200\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(\"Result message matches target result message\", function () {\r",
													"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
													"});\r",
													"\r",
													"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
													"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
													"});\r",
													"\r",
													"pm.test(\"Result conditions array only contains a single condition\", function () {\r",
													"    pm.expect(conditionResult.length).to.be.eql(1);\r",
													"});\r",
													"\r",
													"let firstElement = conditionResult[0];\r",
													"\r",
													"pm.test(\"Result condition has a non-empty condId\", function () {\r",
													"    pm.expect(firstElement.condId).to.exist.and.not.be.empty;\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.condTp).to.be.eql(targetConditionResult.condTp);\r",
													"});\r",
													"\r",
													"if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"    pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
													"        pm.expect(firstElement.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"    });\r",
													"} else {    // if not, one must have been defaulted\r",
													"    pm.test(\"Result condition has a non-empty incptnDtTm\", function () {\r",
													"        pm.expect(firstElement.incptnDtTm).to.exist.and.not.be.empty;\r",
													"    });\r",
													"}\r",
													"\r",
													"if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"    pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
													"        pm.expect(firstElement.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"    });\r",
													"} else {    // if not, one must not have been defaulted\r",
													"    pm.test(\"Result condition does not have an xprtnDtTm\", function () {\r",
													"        pm.expect(firstElement.xprtnDtTm).to.not.exist;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.usr).to.be.eql(targetConditionResult.usr);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition has a non-empty creDtTm\", function () {\r",
													"    pm.expect(firstElement.creDtTm).to.exist.and.not.be.empty;\r",
													"});\r",
													"\r",
													"// create an array that only includes the perspective descriptions so that we can evaluate them easily\r",
													"let perspectives = firstElement.prsptvs.map(({ prsptv }) => prsptv);\r",
													"\r",
													"if (targetConditionResult.prsptv === \"both\") {\r",
													"    pm.test(\"Result prsptv array contains only 2 perspectives\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(2);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_creditor_by\", \"governed_as_debtor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains both ${JSON.stringify(targetPerspectives)} perspectives`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"} else if (targetConditionResult.prsptv === \"debtor\") {\r",
													"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_debtor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"} else if (targetConditionResult.prsptv === \"creditor\") {\r",
													"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_creditor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"};\r",
													"\r",
													"for (let i = 0; i < firstElement.prsptvs.length; i++) {   // for each perspective\r",
													"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} contains a non-empty evtTp array`, function () {\r",
													"        pm.expect(firstElement.prsptvs[i].evtTp).to.be.an('array').and.not.be.empty;\r",
													"    });\r",
													"\r",
													"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} evtTp array matches submitted condition`, function () {\r",
													"        pm.expect(firstElement.prsptvs[i].evtTp).to.include.members(targetConditionResult.evtTp);\r",
													"    });\r",
													"\r",
													"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches submitted condition`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must have been defaulted\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches created condition incptDtTm`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.eql(firstElement.incptnDtTm);\r",
													"        });\r",
													"    }\r",
													"\r",
													"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} xprtnDtTm matches submitted condition`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must not have been defaulted\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} does not have an xprtnDtTm`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.not.exist;\r",
													"        });\r",
													"    }\r",
													"\r",
													"}\r",
													"\r",
													"pm.test(\"Result condition ntty.id matches submitted condition\", function () {\r",
													"    pm.expect(conditionEntity.id).to.be.eql(targetConditionResult.ntty.id);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"    pm.expect(conditionEntity.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
													"});\r",
													"\r",
													"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetEntityId, false);;\r",
													"\r",
													"await pm.sendRequest(postRequest, (error, response) => {\r",
													"    if (utils.getLogLevel() === 'DEBUG') {\r",
													"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
													"    }\r",
													"    databaseConditionResult = response.json().data;\r",
													"\r",
													"    if (utils.getLogLevel() === 'DEBUG') {\r",
													"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
													"    }\r",
													"\r",
													"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
													"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
													"\r",
													"    pm.test(`Only one condition for entity [${targetEntityId}] exists in the database`, function () {\r",
													"        pm.expect(graphConditionList.length).to.eql(1);\r",
													"    });\r",
													"\r",
													"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
													"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
													"            pm.expect(conditionGraph.v[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
													"        });\r",
													"    }\r",
													"\r",
													"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
													"    });\r",
													"\r",
													"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"        pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
													"            pm.expect(conditionGraph.v[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must have been defaulted\r",
													"        pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
													"            pm.expect(conditionGraph.v[0].incptnDtTm).to.exist.and.not.be.empty;\r",
													"        });\r",
													"    }\r",
													"\r",
													"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"        pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
													"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must not have been defaulted\r",
													"        pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
													"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.not.exist;\r",
													"        });\r",
													"    }\r",
													"\r",
													"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].ntty.id).to.be.eql(targetConditionResult.ntty.id);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].ntty.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].usr).to.be.eql(targetConditionResult.usr);\r",
													"    });\r",
													"\r",
													"    let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, conditionGraph.v[0]._key);\r",
													"\r",
													"    pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
													"        pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database 'governed_as_creditor_by' edge does not exist\", function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
													"    });\r",
													"\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"// Obliterate the current contents of the global variables\r",
													"pm.globals.clear();\r",
													"\r",
													"// Set up the transaction (in memory)\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ 3600000,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"\r",
													"// Retrieve the created pacs.008 message\r",
													"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
													"\r",
													"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
													"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
													"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
													"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
													"\r",
													"// Load deconstructued identifier variables into global variables\r",
													"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
													"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
													"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
													"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
													"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
													"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
													"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
													"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
													"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
													"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
													"\r",
													"// Set up the condition\r",
													"\r",
													"console.log(`Overridable block incepts at ${utils.getTimestampNow()}`);\r",
													"\r",
													"messageBody = {\r",
													"  \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09\",\"pacs.008.001.10\",\"pacs.002.001.12\"],\r",
													"  \"condTp\":\"overridable-block\",\r",
													"  \"prsptv\":\"debtor\",\r",
													"  \"condRsn\":\"Default Test Condition\",\r",
													"  \"ntty\":\r",
													"  {\r",
													"    \"id\": `${dbtrNttyId.id}`,\r",
													"    \"schmeNm\":\r",
													"    {\r",
													"      \"prtry\":\"TAZAMA_EID\"\r",
													"    }\r",
													"  },\r",
													"  \"forceCret\":true,\r",
													"  \"usr\":\"POSTMAN\"\r",
													"}\r",
													"\r",
													"// Set up body variables\r",
													"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
													"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
											"host": [
												"{{tazamaAdminUrl}}{{path-admin-api-version}}"
											],
											"path": [
												"{{path-entity-condition}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Create New Entity Condition Manually - set override",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"responseJSON = pm.response.json();\r",
													"let conditionResult = responseJSON.result.conditions;\r",
													"let conditionEntity = responseJSON.result.ntty;\r",
													"let requestMessage = responseJSON.message;\r",
													"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
													"let nttyId = pm.globals.get(\"dbtrNttyId\");\r",
													"let nttyIdSchme = pm.globals.get(\"dbtrNttyIdSchmeNm\");\r",
													"let tenantId = pm.globals.get(\"tenantId\");\r",
													"let targetEntityId = nttyId + nttyIdSchme;\r",
													"\r",
													"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
													"targetRequestMessage = \"1 conditions already exist for the entity\"\r",
													"\r",
													"pm.test(\"Status code is 200\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(\"Result message matches target result message\", function () {\r",
													"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
													"});\r",
													"\r",
													"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
													"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
													"});\r",
													"\r",
													"pm.test(\"Result conditions array contains two conditions\", function () {\r",
													"    pm.expect(conditionResult.length).to.be.eql(2);\r",
													"});\r",
													"\r",
													"let newElement = conditionResult[conditionResult.length - 1];  // the last element is the newly submitted condition\r",
													"\r",
													"pm.test(\"Result condition has a non-empty condId\", function () {\r",
													"    pm.expect(newElement.condId).to.exist.and.not.be.empty;\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
													"    pm.expect(newElement.condTp).to.be.eql(targetConditionResult.condTp);\r",
													"});\r",
													"\r",
													"if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"    pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
													"        pm.expect(newElement.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"    });\r",
													"} else {    // if not, one must have been defaulted\r",
													"    pm.test(\"Result condition has a non-empty incptnDtTm\", function () {\r",
													"        pm.expect(newElement.incptnDtTm).to.exist.and.not.be.empty;\r",
													"    });\r",
													"}\r",
													"\r",
													"if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"    pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
													"        pm.expect(newElement.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"    });\r",
													"} else {    // if not, one must not have been defaulted\r",
													"    pm.test(\"Result condition does not have an xprtnDtTm\", function () {\r",
													"        pm.expect(newElement.xprtnDtTm).to.not.exist;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
													"    pm.expect(newElement.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
													"    pm.expect(newElement.usr).to.be.eql(targetConditionResult.usr);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition has a non-empty creDtTm\", function () {\r",
													"    pm.expect(newElement.creDtTm).to.exist.and.not.be.empty;\r",
													"});\r",
													"\r",
													"// create an array that only includes the perspective descriptions so that we can evaluate them easily\r",
													"let perspectives = newElement.prsptvs.map(({ prsptv }) => prsptv);\r",
													"\r",
													"if (targetConditionResult.prsptv === \"both\") {\r",
													"    pm.test(\"Result prsptv array contains only 2 perspectives\", function () {\r",
													"        pm.expect(newElement.prsptvs.length).to.be.eql(2);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_creditor_by\", \"governed_as_debtor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains both ${JSON.stringify(targetPerspectives)} perspectives`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"} else if (targetConditionResult.prsptv === \"debtor\") {\r",
													"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
													"        pm.expect(newElement.prsptvs.length).to.be.eql(1);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_debtor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"} else if (targetConditionResult.prsptv === \"creditor\") {\r",
													"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
													"        pm.expect(newElement.prsptvs.length).to.be.eql(1);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_creditor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"};\r",
													"\r",
													"for (let i = 0; i < newElement.prsptvs.length; i++) {   // for each perspective\r",
													"    pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} contains a non-empty evtTp array`, function () {\r",
													"        pm.expect(newElement.prsptvs[i].evtTp).to.be.an('array').and.not.be.empty;\r",
													"    });\r",
													"\r",
													"    pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} evtTp array matches submitted condition`, function () {\r",
													"        pm.expect(newElement.prsptvs[i].evtTp).to.include.members(targetConditionResult.evtTp);\r",
													"    });\r",
													"\r",
													"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"        pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} incptnDtTm matches submitted condition`, function () {\r",
													"            pm.expect(newElement.prsptvs[i].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must have been defaulted\r",
													"        pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} incptnDtTm matches created condition incptDtTm`, function () {\r",
													"            pm.expect(newElement.prsptvs[i].incptnDtTm).to.eql(newElement.incptnDtTm);\r",
													"        });\r",
													"    }\r",
													"\r",
													"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"        pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} xprtnDtTm matches submitted condition`, function () {\r",
													"            pm.expect(newElement.prsptvs[i].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must not have been defaulted\r",
													"        pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} does not have an xprtnDtTm`, function () {\r",
													"            pm.expect(newElement.prsptvs[i].xprtnDtTm).to.not.exist;\r",
													"        });\r",
													"    }\r",
													"\r",
													"}\r",
													"\r",
													"pm.test(\"Result condition ntty.id matches submitted condition\", function () {\r",
													"    pm.expect(conditionEntity.id).to.be.eql(targetConditionResult.ntty.id);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"    pm.expect(conditionEntity.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
													"});\r",
													"\r",
													"// Now we want to test that the data in the database matches the submitted data AND the response data\r",
													"\r",
													"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetEntityId, false);;\r",
													"\r",
													"await pm.sendRequest(postRequest, (error, response) => {\r",
													"    if (utils.getLogLevel() === 'DEBUG') {\r",
													"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
													"    }\r",
													"    databaseConditionResult = response.json().data;\r",
													"\r",
													"    if (utils.getLogLevel() === 'DEBUG') {\r",
													"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
													"    }\r",
													"\r",
													"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
													"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
													"\r",
													"    let submittedCondition = graphConditionList.filter(condition => condition._id === `conditions/${newElement.condId}`);\r",
													"\r",
													"    // First we check that the submitted condition matches the database version\r",
													"\r",
													"    pm.test(`Only two conditions for entity [${targetEntityId}] exists in the database`, function () {\r",
													"        pm.expect(graphConditionList.length).to.eql(2);\r",
													"    });\r",
													"\r",
													"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
													"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
													"            pm.expect(submittedCondition[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
													"        });\r",
													"    }\r",
													"\r",
													"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
													"        pm.expect(submittedCondition[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
													"        pm.expect(submittedCondition[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
													"    });\r",
													"\r",
													"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"        pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
													"            pm.expect(submittedCondition[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must have been defaulted\r",
													"        pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
													"            pm.expect(submittedCondition[0].incptnDtTm).to.exist.and.not.be.empty;\r",
													"        });\r",
													"    }\r",
													"\r",
													"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"        pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
													"            pm.expect(submittedCondition[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must not have been defaulted\r",
													"        pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
													"            pm.expect(submittedCondition[0].xprtnDtTm).to.not.exist;\r",
													"        });\r",
													"    }\r",
													"\r",
													"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
													"        pm.expect(submittedCondition[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
													"        pm.expect(submittedCondition[0].ntty.id).to.be.eql(targetConditionResult.ntty.id);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"        pm.expect(submittedCondition[0].ntty.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
													"        pm.expect(submittedCondition[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
													"        pm.expect(submittedCondition[0].usr).to.be.eql(targetConditionResult.usr);\r",
													"    });\r",
													"\r",
													"    let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, submittedCondition[0]._key);\r",
													"\r",
													"    pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
													"        pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database 'governed_as_creditor_by' edge does not exist\", function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
													"    });\r",
													"\r",
													"    // Then we check the previous conditions in the response one-by-one against the database version\r",
													"    let previousConditionsFromResponse = graphConditionList.filter(condition => condition._id != `conditions/${newElement.condId}`);\r",
													"    let previousResponseConditionIds = previousConditionsFromResponse.map(({ condId }) => condId);\r",
													"    let previousConditionsFromDatabase = graphConditionList.filter(condition => condition._id != `conditions/${newElement.condId}`);\r",
													"    let previousDatabaseConditionIds = previousConditionsFromDatabase.map(({ condId }) => condId);\r",
													"\r",
													"    pm.test(`List of previous conditions in response match list of conditions from database`, function () {\r",
													"        pm.expect(previousResponseConditionIds).to.have.members(previousDatabaseConditionIds);\r",
													"    });\r",
													"\r",
													"    pm.test(`Only one previous condition for entity [${targetEntityId}] exists in the reponse`, function () {\r",
													"        pm.expect(previousConditionsFromResponse.length).to.eql(1);\r",
													"    });\r",
													"\r",
													"    pm.test(`Only one previous condition for entity [${targetEntityId}] exists in the database`, function () {\r",
													"        pm.expect(previousConditionsFromDatabase.length).to.eql(1);\r",
													"    });\r",
													"\r",
													"    for (let j = 0; j < previousConditionsFromResponse.length; j++) {\r",
													"\r",
													"        let justOneConditionFromResponse = previousConditionsFromResponse.filter(condition => condition._id === `conditions/${conditionResult[j].condId}`);\r",
													"        let sameConditionFromDatabase = previousConditionsFromDatabase.filter(condition => condition._id === `conditions/${conditionResult[j].condId}`);\r",
													"\r",
													"        for (let i = 0; i < sameConditionFromDatabase[0].evtTp.length; i++) {\r",
													"            pm.test(`Database condition.evtTp contains ${sameConditionFromDatabase[0].evtTp[i]}`, function () {\r",
													"                pm.expect(justOneConditionFromResponse[0].evtTp).to.include.members([sameConditionFromDatabase[0].evtTp[i]]);\r",
													"            });\r",
													"        }\r",
													"\r",
													"        pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
													"            pm.expect(justOneConditionFromResponse[0].condTp).to.be.eql(sameConditionFromDatabase[0].condTp);\r",
													"        });\r",
													"\r",
													"        pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
													"            pm.expect(justOneConditionFromResponse[0].prsptv).to.be.eql(sameConditionFromDatabase[0].prsptv);\r",
													"        });\r",
													"\r",
													"        if (sameConditionFromDatabase[0].incptnDtTm) { // was an inception date specified?\r",
													"            pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
													"                pm.expect(justOneConditionFromResponse[0].incptnDtTm).to.be.eql(sameConditionFromDatabase[0].incptnDtTm);\r",
													"            });\r",
													"        } else {    // if not, one must have been defaulted\r",
													"            pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
													"                pm.expect(justOneConditionFromResponse[0].incptnDtTm).to.exist.and.not.be.empty;\r",
													"            });\r",
													"        }\r",
													"\r",
													"        if (sameConditionFromDatabase[0].xprtnDtTm) { // was an expiration date specified?\r",
													"            pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
													"                pm.expect(justOneConditionFromResponse[0].xprtnDtTm).to.be.eql(sameConditionFromDatabase[0].xprtnDtTm);\r",
													"            });\r",
													"        } else {    // if not, one must not have been defaulted\r",
													"            pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
													"                pm.expect(justOneConditionFromResponse[0].xprtnDtTm).to.not.exist;\r",
													"            });\r",
													"        }\r",
													"\r",
													"        pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
													"            pm.expect(justOneConditionFromResponse[0].condRsn).to.be.eql(sameConditionFromDatabase[0].condRsn);\r",
													"        });\r",
													"\r",
													"        pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
													"            pm.expect(justOneConditionFromResponse[0].ntty.id).to.be.eql(sameConditionFromDatabase[0].ntty.id);\r",
													"        });\r",
													"\r",
													"        pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"            pm.expect(justOneConditionFromResponse[0].ntty.schmeNm.prtry).to.be.eql(sameConditionFromDatabase[0].ntty.schmeNm.prtry);\r",
													"        });\r",
													"\r",
													"        pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
													"            pm.expect(justOneConditionFromResponse[0].forceCret).to.be.eql(sameConditionFromDatabase[0].forceCret);\r",
													"        });\r",
													"\r",
													"        pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
													"            pm.expect(justOneConditionFromResponse[0].usr).to.be.eql(sameConditionFromDatabase[0].usr);\r",
													"        });\r",
													"\r",
													"        let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, justOneConditionFromResponse[0]._key);\r",
													"\r",
													"        pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
													"            pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
													"        });\r",
													"\r",
													"        pm.test(\"Database 'governed_as_creditor_by' edge does not exist\", function () {\r",
													"            pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_by\"]);\r",
													"        });\r",
													"\r",
													"        pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
													"            pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
													"        });\r",
													"\r",
													"        pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
													"            pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
													"        });\r",
													"    }\r",
													"\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"// Retrieve the created pacs.008 message\r",
													"const submittedPacs008Message = utils.addTenantId(null, JSON.parse(pm.globals.get(\"pacs008\")));\r",
													"\r",
													"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
													"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
													"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
													"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
													"\r",
													"// Load deconstructued identifier variables into global variables\r",
													"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
													"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
													"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
													"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
													"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
													"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
													"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
													"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
													"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
													"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
													"\r",
													"xprtnDtTm = utils.timestampAtTMinus(-10, \"m\");\r",
													"\r",
													"// Set up the condition\r",
													"\r",
													"console.log(`Override incepts at ${utils.getTimestampNow()}`);\r",
													"\r",
													"messageBody = {\r",
													"  \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09\",\"pacs.008.001.10\",\"pacs.002.001.12\"],\r",
													"  \"condTp\":\"override\",\r",
													"  \"prsptv\":\"debtor\",\r",
													"  \"xprtnDtTm\": xprtnDtTm,\r",
													"  \"condRsn\":\"Default Test Condition\",\r",
													"  \"ntty\":\r",
													"  {\r",
													"    \"id\": `${dbtrNttyId.id}`,\r",
													"    \"schmeNm\":\r",
													"    {\r",
													"      \"prtry\":\"TAZAMA_EID\"\r",
													"    }\r",
													"  },\r",
													"  \"forceCret\":true,\r",
													"  \"usr\":\"POSTMAN\"\r",
													"}\r",
													"\r",
													"// Set up body variables\r",
													"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
													"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
											"host": [
												"{{tazamaAdminUrl}}{{path-admin-api-version}}"
											],
											"path": [
												"{{path-entity-condition}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('debtorId');\r",
													"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
													"let cdtrId = pm.globals.get('creditorId');\r",
													"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
													"\r",
													"// Hacky workaround for testing the timeout of the submission of the pacs002 after this test\r",
													"pm.globals.set('responseTimedOut', true);\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ dbtrId,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ dbtrAcctId,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ 'fsp001',\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Post pacs.002 to TMS API - TIMEOUT EXPECTED",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"// Hacky workaround for testing the timeout of the submission of the pacs002\r",
													"pm.globals.set('responseTimedOut', false);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`No alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													"\r",
													"pm.test(`Request does not complete within specified timeout of ${pm.globals.get('timeoutLimit')}`, function () {\r",
													"    pm.expect(pm.response.responseTime).to.be.above(4000);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"NALT\";\r",
													"const expectedBlockingOutcome = \"override\";\r",
													"const expectedReviewFlag = false;\r",
													"const expectedTypologyAlert = false;\r",
													"const expectedTypologyInterdiction = false;\r",
													"const expectedResponseTimedOut = true;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });\r",
													"\r",
													"pm.test(`No response received at EFRuP interdiction service before timeout`, function () {\r",
													"        pm.expect(pm.globals.get('responseTimedOut')).to.be.eql(expectedResponseTimedOut);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('debtorId');\r",
													"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
													"let cdtrId = pm.globals.get('creditorId');\r",
													"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
													"\r",
													"// Hacky workaround for testing the timeout of the submission of the pacs002 after this test\r",
													"pm.globals.set('responseTimedOut', true);\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ dbtrId,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ dbtrAcctId,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ 'fsp001',\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Post pacs.002 to TMS API - TIMEOUT EXPECTED",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"// Hacky workaround for testing the timeout of the submission of the pacs002\r",
													"pm.globals.set('responseTimedOut', false);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`No alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													"\r",
													"pm.test(`Request does not complete within specified timeout of ${pm.globals.get('timeoutLimit')}`, function () {\r",
													"    pm.expect(pm.response.responseTime).to.be.above(4000);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"ALRT\";\r",
													"const expectedBlockingOutcome = \"override\";\r",
													"const expectedReviewFlag = true;\r",
													"const expectedTypologyAlert = true;\r",
													"const expectedTypologyInterdiction = false;\r",
													"const expectedResponseTimedOut = true;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });\r",
													"\r",
													"pm.test(`No response received at EFRuP interdiction service before timeout`, function () {\r",
													"        pm.expect(pm.globals.get('responseTimedOut')).to.be.eql(expectedResponseTimedOut);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('debtorId');\r",
													"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
													"let cdtrId = pm.globals.get('creditorId');\r",
													"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
													"\r",
													"// Hacky workaround for testing the timeout of the submission of the pacs002 after this test\r",
													"pm.globals.set('responseTimedOut', true);\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ dbtrId,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ dbtrAcctId,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ 'fsp001',\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Post pacs.002 to TMS API - TIMEOUT EXPECTED",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"// Hacky workaround for testing the timeout of the submission of the pacs002\r",
													"pm.globals.set('responseTimedOut', false);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`No alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													"\r",
													"pm.test(`Request does not complete within specified timeout of ${pm.globals.get('timeoutLimit')}`, function () {\r",
													"    pm.expect(pm.response.responseTime).to.be.above(4000);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"ALRT\";\r",
													"const expectedBlockingOutcome = \"override\";\r",
													"const expectedReviewFlag = true;\r",
													"const expectedTypologyAlert = true;\r",
													"const expectedTypologyInterdiction = true;\r",
													"const expectedResponseTimedOut = true;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });\r",
													"\r",
													"pm.test(`No response received at EFRuP interdiction service before timeout`, function () {\r",
													"        pm.expect(pm.globals.get('responseTimedOut')).to.be.eql(expectedResponseTimedOut);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "interdiction with override",
							"item": [
								{
									"name": "Before override",
									"item": [
										{
											"name": "Transaction 1 - Post pacs.008 to TMS API",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
															"\r",
															"let dbtrId = pm.globals.get('debtorId');\r",
															"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
															"let cdtrId = pm.globals.get('creditorId');\r",
															"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
															"\r",
															"// Hacky workaround for testing the timeout of the submission of the pacs002 after this test\r",
															"pm.globals.set('responseTimedOut', true);\r",
															"\r",
															"// ## Set up transaction eco-system\r",
															"\r",
															"messageSet = utils.createTransactionSetInMemory(\r",
															"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
															"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
															"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
															"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
															"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
															"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
															"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
															"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
															"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
															"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
															"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
															"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
															"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
															"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
															"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
															"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
															"    /* Description - null defaults random UUID ---------------------- */ null,\r",
															"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
															"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
															"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
															"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
															"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
															"    );\r",
															"\r",
															"let messageBody = pm.globals.get('pacs008');\r",
															"pm.globals.set('pacs008Stash', messageBody);\r",
															"pm.globals.set('messageBody', messageBody);"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{{messageBody}}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
													"host": [
														"{{tazamaTMSUrl}}{{path-tms-api-version}}"
													],
													"path": [
														"{{path-pacs008}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 1 - Post pacs.002 to TMS API",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"let messageBody = pm.globals.get('pacs002');\r",
															"pm.globals.set('messageBody', messageBody);"
														],
														"type": "text/javascript",
														"packages": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{{pacs002}}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs002}}",
													"host": [
														"{{tazamaTMSUrl}}{{path-tms-api-version}}"
													],
													"path": [
														"{{path-pacs002}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 1 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
														],
														"type": "text/javascript",
														"packages": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"const resJson = pm.response.json();\r",
															"\r",
															"const rulesPerTypologyCount = [3];\r",
															"const totalExpectedTypologies = 1;\r",
															"const expectedAlertStatus = \"NALT\";\r",
															"const expectedBlockingOutcome = \"none\";\r",
															"const expectedReviewFlag = false;\r",
															"const expectedTypologyAlert = false;\r",
															"const expectedTypologyInterdiction = false;\r",
															"\r",
															"const interdictionTypologies = [\r",
															"  \"999\"\r",
															"];\r",
															"const ruleDescriptions = {\r",
															"  \"901\": \"Number of outgoing transactions - debtor\",\r",
															"  \"902\": \"Number of incoming transactions - creditor\",\r",
															"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
															"}\r",
															"const typologyDescriptions = {\r",
															"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
															"}\r",
															"\r",
															"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
															"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
															"\r",
															"typologyCount = typologyResultsUnique.count();\r",
															"ruleCount = ruleResultsUnique.count();\r",
															"\r",
															"foundEFRuP = false;\r",
															"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
															"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
															"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
															"        foundEFRuP = true;\r",
															"    }\r",
															"}\r",
															"\r",
															"ruleWeightingTotal = 0;\r",
															"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
															"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
															"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
															"    }    \r",
															"}\r",
															"\r",
															"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
															"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
															"});\r",
															"\r",
															"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
															"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
															"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
															"    pm.expect(foundEFRuP).to.be.true;\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
															"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
															"});\r",
															"\r",
															"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedReviewFlag) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
															"    });\r",
															"} else {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
															"    });\r",
															"}\r",
															"\r",
															"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
															"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
															"    });"
														],
														"type": "text/javascript",
														"packages": {}
													}
												}
											],
											"request": {
												"auth": {
													"type": "bearer",
													"bearer": [
														{
															"key": "token",
															"value": "{{auth-token}}",
															"type": "string"
														}
													]
												},
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
													"host": [
														"{{arangoUrl}}"
													],
													"path": [
														"_db",
														"{{db_results}}",
														"_api",
														"cursor"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 2 - Post pacs.008 to TMS API",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
															"\r",
															"let dbtrId = pm.globals.get('debtorId');\r",
															"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
															"let cdtrId = pm.globals.get('creditorId');\r",
															"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
															"\r",
															"// Hacky workaround for testing the timeout of the submission of the pacs002 after this test\r",
															"pm.globals.set('responseTimedOut', true);\r",
															"\r",
															"// ## Set up transaction eco-system\r",
															"\r",
															"messageSet = utils.createTransactionSetInMemory(\r",
															"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
															"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
															"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
															"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
															"    /* Debtor ID - null defaults random UUID ------------------------ */ dbtrId,\r",
															"    /* Debtor Account ID - null defaults random UUID ---------------- */ dbtrAcctId,\r",
															"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ 'fsp001',\r",
															"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
															"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
															"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
															"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
															"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
															"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
															"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
															"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
															"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
															"    /* Description - null defaults random UUID ---------------------- */ null,\r",
															"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
															"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
															"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
															"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
															"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
															"    );\r",
															"\r",
															"let messageBody = pm.globals.get('pacs008');\r",
															"pm.globals.set('messageBody', messageBody);"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{{messageBody}}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
													"host": [
														"{{tazamaTMSUrl}}{{path-tms-api-version}}"
													],
													"path": [
														"{{path-pacs008}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 2 - Post pacs.002 to TMS API",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"let messageBody = pm.globals.get('pacs002');\r",
															"pm.globals.set('messageBody', messageBody);"
														],
														"type": "text/javascript",
														"packages": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{{pacs002}}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs002}}",
													"host": [
														"{{tazamaTMSUrl}}{{path-tms-api-version}}"
													],
													"path": [
														"{{path-pacs002}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 2 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
														],
														"type": "text/javascript",
														"packages": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"const resJson = pm.response.json();\r",
															"\r",
															"const rulesPerTypologyCount = [3];\r",
															"const totalExpectedTypologies = 1;\r",
															"const expectedAlertStatus = \"ALRT\";\r",
															"const expectedBlockingOutcome = \"none\";\r",
															"const expectedReviewFlag = true;\r",
															"const expectedTypologyAlert = true;\r",
															"const expectedTypologyInterdiction = false;\r",
															"\r",
															"const interdictionTypologies = [\r",
															"  \"999\"\r",
															"];\r",
															"const ruleDescriptions = {\r",
															"  \"901\": \"Number of outgoing transactions - debtor\",\r",
															"  \"902\": \"Number of incoming transactions - creditor\",\r",
															"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
															"}\r",
															"const typologyDescriptions = {\r",
															"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
															"}\r",
															"\r",
															"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
															"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
															"\r",
															"typologyCount = typologyResultsUnique.count();\r",
															"ruleCount = ruleResultsUnique.count();\r",
															"\r",
															"foundEFRuP = false;\r",
															"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
															"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
															"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
															"        foundEFRuP = true;\r",
															"    }\r",
															"}\r",
															"\r",
															"ruleWeightingTotal = 0;\r",
															"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
															"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
															"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
															"    }    \r",
															"}\r",
															"\r",
															"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
															"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
															"});\r",
															"\r",
															"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
															"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
															"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
															"    pm.expect(foundEFRuP).to.be.true;\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
															"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
															"});\r",
															"\r",
															"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedReviewFlag) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
															"    });\r",
															"} else {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
															"    });\r",
															"}\r",
															"\r",
															"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
															"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
															"    });"
														],
														"type": "text/javascript",
														"packages": {}
													}
												}
											],
											"request": {
												"auth": {
													"type": "bearer",
													"bearer": [
														{
															"key": "token",
															"value": "{{auth-token}}",
															"type": "string"
														}
													]
												},
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
													"host": [
														"{{arangoUrl}}"
													],
													"path": [
														"_db",
														"{{db_results}}",
														"_api",
														"cursor"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 3 - Post pacs.008 to TMS API",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
															"\r",
															"let dbtrId = pm.globals.get('debtorId');\r",
															"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
															"let cdtrId = pm.globals.get('creditorId');\r",
															"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
															"\r",
															"// Hacky workaround for testing the timeout of the submission of the pacs002 after this test\r",
															"pm.globals.set('responseTimedOut', true);\r",
															"\r",
															"// ## Set up transaction eco-system\r",
															"\r",
															"messageSet = utils.createTransactionSetInMemory(\r",
															"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
															"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
															"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
															"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
															"    /* Debtor ID - null defaults random UUID ------------------------ */ dbtrId,\r",
															"    /* Debtor Account ID - null defaults random UUID ---------------- */ dbtrAcctId,\r",
															"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ 'fsp001',\r",
															"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
															"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
															"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
															"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
															"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
															"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
															"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
															"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
															"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
															"    /* Description - null defaults random UUID ---------------------- */ null,\r",
															"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
															"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
															"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
															"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
															"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
															"    );\r",
															"\r",
															"let messageBody = pm.globals.get('pacs008');\r",
															"pm.globals.set('messageBody', messageBody);"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{{messageBody}}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
													"host": [
														"{{tazamaTMSUrl}}{{path-tms-api-version}}"
													],
													"path": [
														"{{path-pacs008}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 3 - Post pacs.002 to TMS API - NO TIMEOUT EXPECTED",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
															"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
															"const awaitReply = true; // Hold the phone for a callback\r",
															"\r",
															"let messageBody = pm.globals.get('pacs002');\r",
															"pm.globals.set('messageBody', messageBody);\r",
															"pm.globals.set('endpoint', endpoint);\r",
															"pm.globals.set('responseDestination', responseDestination);\r",
															"pm.globals.set('awaitReply', awaitReply);\r",
															""
														],
														"type": "text/javascript",
														"packages": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"const resJson = pm.response.json();\r",
															"console.log(resJson);\r",
															"\r",
															"// Hacky workaround for testing the timeout of the submission of the pacs002\r",
															"pm.globals.set('responseTimedOut', false);\r",
															"\r",
															"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});\r",
															"\r",
															"pm.test(`Interdiction alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
															"    pm.expect(resJson.edResponse.typologyResult.review).to.be.true;\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
													"host": [
														"{{natsUrl}}"
													],
													"path": [
														"{{nats-path-tms-api}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 3 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
														],
														"type": "text/javascript",
														"packages": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"const resJson = pm.response.json();\r",
															"\r",
															"const rulesPerTypologyCount = [3];\r",
															"const totalExpectedTypologies = 1;\r",
															"const expectedAlertStatus = \"ALRT\";\r",
															"const expectedBlockingOutcome = \"none\";\r",
															"const expectedReviewFlag = true;\r",
															"const expectedTypologyAlert = true;\r",
															"const expectedTypologyInterdiction = true;\r",
															"const expectedResponseTimedOut = false;\r",
															"\r",
															"const interdictionTypologies = [\r",
															"  \"999\"\r",
															"];\r",
															"const ruleDescriptions = {\r",
															"  \"901\": \"Number of outgoing transactions - debtor\",\r",
															"  \"902\": \"Number of incoming transactions - creditor\",\r",
															"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
															"}\r",
															"const typologyDescriptions = {\r",
															"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
															"}\r",
															"\r",
															"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
															"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
															"\r",
															"typologyCount = typologyResultsUnique.count();\r",
															"ruleCount = ruleResultsUnique.count();\r",
															"\r",
															"foundEFRuP = false;\r",
															"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
															"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
															"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
															"        foundEFRuP = true;\r",
															"    }\r",
															"}\r",
															"\r",
															"ruleWeightingTotal = 0;\r",
															"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
															"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
															"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
															"    }    \r",
															"}\r",
															"\r",
															"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
															"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
															"});\r",
															"\r",
															"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
															"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
															"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
															"    pm.expect(foundEFRuP).to.be.true;\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
															"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
															"});\r",
															"\r",
															"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedReviewFlag) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
															"    });\r",
															"} else {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
															"    });\r",
															"}\r",
															"\r",
															"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
															"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
															"    });\r",
															"\r",
															"pm.test(`Response received at EFRuP interdiction service before timeout`, function () {\r",
															"        pm.expect(pm.globals.get('responseTimedOut')).to.be.eql(expectedResponseTimedOut);\r",
															"    });"
														],
														"type": "text/javascript",
														"packages": {}
													}
												}
											],
											"request": {
												"auth": {
													"type": "bearer",
													"bearer": [
														{
															"key": "token",
															"value": "{{auth-token}}",
															"type": "string"
														}
													]
												},
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
													"host": [
														"{{arangoUrl}}"
													],
													"path": [
														"_db",
														"{{db_results}}",
														"_api",
														"cursor"
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "After override",
									"item": [
										{
											"name": "Create New Entity Condition Manually - Existing debtor",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"responseJSON = pm.response.json();\r",
															"let conditionResult = responseJSON.result.conditions;\r",
															"let conditionEntity = responseJSON.result.ntty;\r",
															"let requestMessage = responseJSON.message;\r",
															"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
															"let nttyId = pm.globals.get(\"dbtrNttyId\");\r",
															"let nttyIdSchme = pm.globals.get(\"dbtrNttyIdSchmeNm\");\r",
															"let tenantId = pm.globals.get(\"tenantId\");\r",
															"let targetEntityId = nttyId + nttyIdSchme;\r",
															"\r",
															"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
															"targetRequestMessage = \"New condition was saved successfully.\"\r",
															"\r",
															"pm.test(\"Status code is 200\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});\r",
															"\r",
															"pm.test(\"Result message matches target result message\", function () {\r",
															"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
															"});\r",
															"\r",
															"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
															"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
															"});\r",
															"\r",
															"pm.test(\"Result conditions array only contains a single condition\", function () {\r",
															"    pm.expect(conditionResult.length).to.be.eql(1);\r",
															"});\r",
															"\r",
															"let firstElement = conditionResult[0];\r",
															"\r",
															"pm.test(\"Result condition has a non-empty condId\", function () {\r",
															"    pm.expect(firstElement.condId).to.exist.and.not.be.empty;\r",
															"});\r",
															"\r",
															"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
															"    pm.expect(firstElement.condTp).to.be.eql(targetConditionResult.condTp);\r",
															"});\r",
															"\r",
															"if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
															"    pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
															"        pm.expect(firstElement.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
															"    });\r",
															"} else {    // if not, one must have been defaulted\r",
															"    pm.test(\"Result condition has a non-empty incptnDtTm\", function () {\r",
															"        pm.expect(firstElement.incptnDtTm).to.exist.and.not.be.empty;\r",
															"    });\r",
															"}\r",
															"\r",
															"if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
															"    pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
															"        pm.expect(firstElement.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
															"    });\r",
															"} else {    // if not, one must not have been defaulted\r",
															"    pm.test(\"Result condition does not have an xprtnDtTm\", function () {\r",
															"        pm.expect(firstElement.xprtnDtTm).to.not.exist;\r",
															"    });\r",
															"}\r",
															"\r",
															"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
															"    pm.expect(firstElement.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
															"});\r",
															"\r",
															"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
															"    pm.expect(firstElement.usr).to.be.eql(targetConditionResult.usr);\r",
															"});\r",
															"\r",
															"pm.test(\"Result condition has a non-empty creDtTm\", function () {\r",
															"    pm.expect(firstElement.creDtTm).to.exist.and.not.be.empty;\r",
															"});\r",
															"\r",
															"// create an array that only includes the perspective descriptions so that we can evaluate them easily\r",
															"let perspectives = firstElement.prsptvs.map(({ prsptv }) => prsptv);\r",
															"\r",
															"if (targetConditionResult.prsptv === \"both\") {\r",
															"    pm.test(\"Result prsptv array contains only 2 perspectives\", function () {\r",
															"        pm.expect(firstElement.prsptvs.length).to.be.eql(2);\r",
															"    });\r",
															"\r",
															"    let targetPerspectives = [\"governed_as_creditor_by\", \"governed_as_debtor_by\"];\r",
															"\r",
															"    pm.test(`Result prsptv array contains both ${JSON.stringify(targetPerspectives)} perspectives`, function () {\r",
															"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
															"    });\r",
															"\r",
															"} else if (targetConditionResult.prsptv === \"debtor\") {\r",
															"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
															"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
															"    });\r",
															"\r",
															"    let targetPerspectives = [\"governed_as_debtor_by\"];\r",
															"\r",
															"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
															"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
															"    });\r",
															"\r",
															"} else if (targetConditionResult.prsptv === \"creditor\") {\r",
															"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
															"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
															"    });\r",
															"\r",
															"    let targetPerspectives = [\"governed_as_creditor_by\"];\r",
															"\r",
															"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
															"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
															"    });\r",
															"\r",
															"};\r",
															"\r",
															"for (let i = 0; i < firstElement.prsptvs.length; i++) {   // for each perspective\r",
															"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} contains a non-empty evtTp array`, function () {\r",
															"        pm.expect(firstElement.prsptvs[i].evtTp).to.be.an('array').and.not.be.empty;\r",
															"    });\r",
															"\r",
															"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} evtTp array matches submitted condition`, function () {\r",
															"        pm.expect(firstElement.prsptvs[i].evtTp).to.include.members(targetConditionResult.evtTp);\r",
															"    });\r",
															"\r",
															"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
															"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches submitted condition`, function () {\r",
															"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
															"        });\r",
															"    } else {    // if not, one must have been defaulted\r",
															"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches created condition incptDtTm`, function () {\r",
															"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.eql(firstElement.incptnDtTm);\r",
															"        });\r",
															"    }\r",
															"\r",
															"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
															"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} xprtnDtTm matches submitted condition`, function () {\r",
															"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
															"        });\r",
															"    } else {    // if not, one must not have been defaulted\r",
															"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} does not have an xprtnDtTm`, function () {\r",
															"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.not.exist;\r",
															"        });\r",
															"    }\r",
															"\r",
															"}\r",
															"\r",
															"pm.test(\"Result condition ntty.id matches submitted condition\", function () {\r",
															"    pm.expect(conditionEntity.id).to.be.eql(targetConditionResult.ntty.id);\r",
															"});\r",
															"\r",
															"pm.test(\"Result condition ntty.schmeNm.prtry matches submitted condition\", function () {\r",
															"    pm.expect(conditionEntity.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
															"});\r",
															"\r",
															"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetEntityId, false);;\r",
															"\r",
															"await pm.sendRequest(postRequest, (error, response) => {\r",
															"    if (utils.getLogLevel() === 'DEBUG') {\r",
															"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
															"    }\r",
															"    databaseConditionResult = response.json().data;\r",
															"\r",
															"    if (utils.getLogLevel() === 'DEBUG') {\r",
															"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
															"    }\r",
															"\r",
															"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
															"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
															"\r",
															"    pm.test(`Only one condition for entity [${targetEntityId}] exists in the database`, function () {\r",
															"        pm.expect(graphConditionList.length).to.eql(1);\r",
															"    });\r",
															"\r",
															"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
															"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
															"            pm.expect(conditionGraph.v[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
															"        });\r",
															"    }\r",
															"\r",
															"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
															"        pm.expect(conditionGraph.v[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
															"    });\r",
															"\r",
															"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
															"        pm.expect(conditionGraph.v[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
															"    });\r",
															"\r",
															"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
															"        pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
															"            pm.expect(conditionGraph.v[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
															"        });\r",
															"    } else {    // if not, one must have been defaulted\r",
															"        pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
															"            pm.expect(conditionGraph.v[0].incptnDtTm).to.exist.and.not.be.empty;\r",
															"        });\r",
															"    }\r",
															"\r",
															"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
															"        pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
															"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
															"        });\r",
															"    } else {    // if not, one must not have been defaulted\r",
															"        pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
															"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.not.exist;\r",
															"        });\r",
															"    }\r",
															"\r",
															"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
															"        pm.expect(conditionGraph.v[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
															"    });\r",
															"\r",
															"    pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
															"        pm.expect(conditionGraph.v[0].ntty.id).to.be.eql(targetConditionResult.ntty.id);\r",
															"    });\r",
															"\r",
															"    pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
															"        pm.expect(conditionGraph.v[0].ntty.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
															"    });\r",
															"\r",
															"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
															"        pm.expect(conditionGraph.v[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
															"    });\r",
															"\r",
															"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
															"        pm.expect(conditionGraph.v[0].usr).to.be.eql(targetConditionResult.usr);\r",
															"    });\r",
															"\r",
															"    let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, conditionGraph.v[0]._key);\r",
															"\r",
															"    pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
															"        pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
															"    });\r",
															"\r",
															"    pm.test(\"Database 'governed_as_creditor_by' edge does not exist\", function () {\r",
															"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_by\"]);\r",
															"    });\r",
															"\r",
															"    pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
															"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
															"    });\r",
															"\r",
															"    pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
															"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
															"    });\r",
															"\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {}
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
															"\r",
															"// Obliterate the current contents of the global variables\r",
															"// Retrieve the created pacs.008 message\r",
															"\r",
															"const submittedPacs008Message = JSON.parse(pm.globals.get('pacs008Stash'));\r",
															"pm.globals.set('pacs008', pm.globals.get('pacs008Stash'));\r",
															"\r",
															"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
															"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
															"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
															"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
															"\r",
															"// Load deconstructued identifier variables into global variables\r",
															"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
															"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
															"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
															"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
															"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
															"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
															"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
															"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
															"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
															"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
															"\r",
															"xprtnDtTm = utils.timestampAtTMinus(-10, \"m\");\r",
															"\r",
															"// Set up the condition\r",
															"\r",
															"console.log(`Override incepts at ${utils.getTimestampNow()}`);\r",
															"\r",
															"messageBody = {\r",
															"  \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09\",\"pacs.008.001.10\",\"pacs.002.001.12\"],\r",
															"  \"condTp\":\"override\",\r",
															"  \"prsptv\":\"debtor\",\r",
															"  \"xprtnDtTm\": xprtnDtTm,\r",
															"  \"condRsn\":\"Default Test Condition\",\r",
															"  \"ntty\":\r",
															"  {\r",
															"    \"id\": `${dbtrNttyId.id}`,\r",
															"    \"schmeNm\":\r",
															"    {\r",
															"      \"prtry\":\"TAZAMA_EID\"\r",
															"    }\r",
															"  },\r",
															"  \"forceCret\":true,\r",
															"  \"usr\":\"POSTMAN\"\r",
															"}\r",
															"\r",
															"// Set up body variables\r",
															"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
															"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
														],
														"type": "text/javascript",
														"packages": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{{messageBody}}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
													"host": [
														"{{tazamaAdminUrl}}{{path-admin-api-version}}"
													],
													"path": [
														"{{path-entity-condition}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 4 - Post pacs.008 to TMS API",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
															"\r",
															"let dbtrId = pm.globals.get('debtorId');\r",
															"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
															"let cdtrId = pm.globals.get('creditorId');\r",
															"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
															"\r",
															"// Hacky workaround for testing the timeout of the submission of the pacs002 after this test\r",
															"pm.globals.set('responseTimedOut', true);\r",
															"\r",
															"// ## Set up transaction eco-system\r",
															"\r",
															"messageSet = utils.createTransactionSetInMemory(\r",
															"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
															"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
															"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
															"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
															"    /* Debtor ID - null defaults random UUID ------------------------ */ dbtrId,\r",
															"    /* Debtor Account ID - null defaults random UUID ---------------- */ dbtrAcctId,\r",
															"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ 'fsp001',\r",
															"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
															"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
															"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
															"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
															"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
															"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
															"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
															"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
															"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
															"    /* Description - null defaults random UUID ---------------------- */ null,\r",
															"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
															"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
															"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
															"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
															"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
															"    );\r",
															"\r",
															"let messageBody = pm.globals.get('pacs008');\r",
															"pm.globals.set('messageBody', messageBody);"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{{messageBody}}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
													"host": [
														"{{tazamaTMSUrl}}{{path-tms-api-version}}"
													],
													"path": [
														"{{path-pacs008}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 4 - Post pacs.002 to TMS API - TIMEOUT EXPECTED",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
															"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
															"const awaitReply = true; // Hold the phone for a callback\r",
															"\r",
															"let messageBody = pm.globals.get('pacs002');\r",
															"pm.globals.set('messageBody', messageBody);\r",
															"pm.globals.set('endpoint', endpoint);\r",
															"pm.globals.set('responseDestination', responseDestination);\r",
															"pm.globals.set('awaitReply', awaitReply);\r",
															""
														],
														"type": "text/javascript",
														"packages": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"const resJson = pm.response.json();\r",
															"console.log(resJson);\r",
															"\r",
															"// Hacky workaround for testing the timeout of the submission of the pacs002\r",
															"pm.globals.set('responseTimedOut', false);\r",
															"\r",
															"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});\r",
															"\r",
															"pm.test(`No alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
															"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
															"});\r",
															"\r",
															"pm.test(`Request does not complete within specified timeout of ${pm.globals.get('timeoutLimit')}`, function () {\r",
															"    pm.expect(pm.response.responseTime).to.be.above(4000);\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
													"host": [
														"{{natsUrl}}"
													],
													"path": [
														"{{nats-path-tms-api}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 4 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
														],
														"type": "text/javascript",
														"packages": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"const resJson = pm.response.json();\r",
															"\r",
															"const rulesPerTypologyCount = [3];\r",
															"const totalExpectedTypologies = 1;\r",
															"const expectedAlertStatus = \"ALRT\";\r",
															"const expectedBlockingOutcome = \"override\";\r",
															"const expectedReviewFlag = true;\r",
															"const expectedTypologyAlert = true;\r",
															"const expectedTypologyInterdiction = true;\r",
															"const expectedResponseTimedOut = true;\r",
															"\r",
															"const interdictionTypologies = [\r",
															"  \"999\"\r",
															"];\r",
															"const ruleDescriptions = {\r",
															"  \"901\": \"Number of outgoing transactions - debtor\",\r",
															"  \"902\": \"Number of incoming transactions - creditor\",\r",
															"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
															"}\r",
															"const typologyDescriptions = {\r",
															"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
															"}\r",
															"\r",
															"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
															"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
															"\r",
															"typologyCount = typologyResultsUnique.count();\r",
															"ruleCount = ruleResultsUnique.count();\r",
															"\r",
															"foundEFRuP = false;\r",
															"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
															"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
															"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
															"        foundEFRuP = true;\r",
															"    }\r",
															"}\r",
															"\r",
															"ruleWeightingTotal = 0;\r",
															"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
															"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
															"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
															"    }    \r",
															"}\r",
															"\r",
															"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
															"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
															"});\r",
															"\r",
															"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
															"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
															"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
															"    pm.expect(foundEFRuP).to.be.true;\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
															"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
															"});\r",
															"\r",
															"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedReviewFlag) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
															"    });\r",
															"} else {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
															"    });\r",
															"}\r",
															"\r",
															"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
															"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
															"    });\r",
															"\r",
															"pm.test(`No response received at EFRuP interdiction service before timeout`, function () {\r",
															"        pm.expect(pm.globals.get('responseTimedOut')).to.be.eql(expectedResponseTimedOut);\r",
															"    });"
														],
														"type": "text/javascript",
														"packages": {}
													}
												}
											],
											"request": {
												"auth": {
													"type": "bearer",
													"bearer": [
														{
															"key": "token",
															"value": "{{auth-token}}",
															"type": "string"
														}
													]
												},
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
													"host": [
														"{{arangoUrl}}"
													],
													"path": [
														"_db",
														"{{db_results}}",
														"_api",
														"cursor"
													]
												}
											},
											"response": []
										}
									]
								}
							]
						}
					]
				},
				{
					"name": "dbtrId - perspective=creditor",
					"item": [
						{
							"name": "non-overridable block",
							"item": [
								{
									"name": "Create New Entity Condition Manually - Unknown debtor entity",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"responseJSON = pm.response.json();\r",
													"let conditionResult = responseJSON.result.conditions;\r",
													"let conditionEntity = responseJSON.result.ntty;\r",
													"let requestMessage = responseJSON.message;\r",
													"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
													"let nttyId = pm.globals.get(\"dbtrNttyId\");\r",
													"let nttyIdSchme = pm.globals.get(\"dbtrNttyIdSchmeNm\");\r",
													"let tenantId = pm.globals.get(\"tenantId\");\r",
													"let targetEntityId = nttyId + nttyIdSchme;\r",
													"\r",
													"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
													"targetRequestMessage = \"New condition was saved successfully.\"\r",
													"\r",
													"pm.test(\"Status code is 200\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(\"Result message matches target result message\", function () {\r",
													"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
													"});\r",
													"\r",
													"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
													"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
													"});\r",
													"\r",
													"pm.test(\"Result conditions array only contains a single condition\", function () {\r",
													"    pm.expect(conditionResult.length).to.be.eql(1);\r",
													"});\r",
													"\r",
													"let firstElement = conditionResult[0];\r",
													"\r",
													"pm.test(\"Result condition has a non-empty condId\", function () {\r",
													"    pm.expect(firstElement.condId).to.exist.and.not.be.empty;\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.condTp).to.be.eql(targetConditionResult.condTp);\r",
													"});\r",
													"\r",
													"if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"    pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
													"        pm.expect(firstElement.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"    });\r",
													"} else {    // if not, one must have been defaulted\r",
													"    pm.test(\"Result condition has a non-empty incptnDtTm\", function () {\r",
													"        pm.expect(firstElement.incptnDtTm).to.exist.and.not.be.empty;\r",
													"    });\r",
													"}\r",
													"\r",
													"if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"    pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
													"        pm.expect(firstElement.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"    });\r",
													"} else {    // if not, one must not have been defaulted\r",
													"    pm.test(\"Result condition does not have an xprtnDtTm\", function () {\r",
													"        pm.expect(firstElement.xprtnDtTm).to.not.exist;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.usr).to.be.eql(targetConditionResult.usr);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition has a non-empty creDtTm\", function () {\r",
													"    pm.expect(firstElement.creDtTm).to.exist.and.not.be.empty;\r",
													"});\r",
													"\r",
													"// create an array that only includes the perspective descriptions so that we can evaluate them easily\r",
													"let perspectives = firstElement.prsptvs.map(({ prsptv }) => prsptv);\r",
													"\r",
													"if (targetConditionResult.prsptv === \"both\") {\r",
													"    pm.test(\"Result prsptv array contains only 2 perspectives\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(2);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_creditor_by\", \"governed_as_debtor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains both ${JSON.stringify(targetPerspectives)} perspectives`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"} else if (targetConditionResult.prsptv === \"debtor\") {\r",
													"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_debtor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"} else if (targetConditionResult.prsptv === \"creditor\") {\r",
													"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_creditor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"};\r",
													"\r",
													"for (let i = 0; i < firstElement.prsptvs.length; i++) {   // for each perspective\r",
													"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} contains a non-empty evtTp array`, function () {\r",
													"        pm.expect(firstElement.prsptvs[i].evtTp).to.be.an('array').and.not.be.empty;\r",
													"    });\r",
													"\r",
													"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} evtTp array matches submitted condition`, function () {\r",
													"        pm.expect(firstElement.prsptvs[i].evtTp).to.include.members(targetConditionResult.evtTp);\r",
													"    });\r",
													"\r",
													"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches submitted condition`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must have been defaulted\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches created condition incptDtTm`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.eql(firstElement.incptnDtTm);\r",
													"        });\r",
													"    }\r",
													"\r",
													"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} xprtnDtTm matches submitted condition`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must not have been defaulted\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} does not have an xprtnDtTm`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.not.exist;\r",
													"        });\r",
													"    }\r",
													"\r",
													"}\r",
													"\r",
													"pm.test(\"Result condition ntty.id matches submitted condition\", function () {\r",
													"    pm.expect(conditionEntity.id).to.be.eql(targetConditionResult.ntty.id);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"    pm.expect(conditionEntity.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
													"});\r",
													"\r",
													"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetEntityId, false);;\r",
													"\r",
													"await pm.sendRequest(postRequest, (error, response) => {\r",
													"    if (utils.getLogLevel() === 'DEBUG') {\r",
													"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
													"    }\r",
													"    databaseConditionResult = response.json().data;\r",
													"\r",
													"    if (utils.getLogLevel() === 'DEBUG') {\r",
													"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
													"    }\r",
													"\r",
													"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
													"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
													"\r",
													"    pm.test(`Only one condition for entity [${targetEntityId}] exists in the database`, function () {\r",
													"        pm.expect(graphConditionList.length).to.eql(1);\r",
													"    });\r",
													"\r",
													"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
													"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
													"            pm.expect(conditionGraph.v[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
													"        });\r",
													"    }\r",
													"\r",
													"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
													"    });\r",
													"\r",
													"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"        pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
													"            pm.expect(conditionGraph.v[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must have been defaulted\r",
													"        pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
													"            pm.expect(conditionGraph.v[0].incptnDtTm).to.exist.and.not.be.empty;\r",
													"        });\r",
													"    }\r",
													"\r",
													"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"        pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
													"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must not have been defaulted\r",
													"        pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
													"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.not.exist;\r",
													"        });\r",
													"    }\r",
													"\r",
													"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].ntty.id).to.be.eql(targetConditionResult.ntty.id);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].ntty.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].usr).to.be.eql(targetConditionResult.usr);\r",
													"    });\r",
													"\r",
													"    let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, conditionGraph.v[0]._key);\r",
													"\r",
													"    pm.test(`Database \"governed_as_debtor_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database 'governed_as_creditor_by' edge exists\", function () {\r",
													"        pm.expect(edgeList).to.include.members([\"governed_as_creditor_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
													"    });\r",
													"\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"// Obliterate the current contents of the global variables\r",
													"pm.globals.clear();\r",
													"\r",
													"// Set up the transaction (in memory)\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ 3600000,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"\r",
													"// Retrieve the created pacs.008 message\r",
													"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
													"\r",
													"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
													"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
													"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
													"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
													"\r",
													"// Load deconstructued identifier variables into global variables\r",
													"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
													"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
													"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
													"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
													"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
													"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
													"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
													"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
													"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
													"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
													"\r",
													"// Set up the condition\r",
													"\r",
													"messageBody = {\r",
													"  \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09\",\"pacs.008.001.10\",\"pacs.002.001.12\"],\r",
													"  \"condTp\":\"non-overridable-block\",\r",
													"  \"prsptv\":\"creditor\",\r",
													"  \"condRsn\":\"Blocking payments to debtor only\",\r",
													"  \"ntty\":\r",
													"  {\r",
													"    \"id\": `${dbtrNttyId.id}`,\r",
													"    \"schmeNm\":\r",
													"    {\r",
													"      \"prtry\":\"TAZAMA_EID\"\r",
													"    }\r",
													"  },\r",
													"  \"forceCret\":true,\r",
													"  \"usr\":\"POSTMAN\"\r",
													"}\r",
													"\r",
													"// Set up body variables\r",
													"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
													"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
											"host": [
												"{{tazamaAdminUrl}}{{path-admin-api-version}}"
											],
											"path": [
												"{{path-entity-condition}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('dbtrNttyId');\r",
													"let dbtrAcctId = pm.globals.get('dbtrAcctId');\r",
													"let cdtrId = pm.globals.get('cdtrNttyId');\r",
													"let cdtrAcctId = pm.globals.get('cdtrAcctId');\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ dbtrId,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ dbtrAcctId,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ 'fsp001',\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Post pacs.002 to TMS API - NO TIMEOUT EXPECTED",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`Alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"ALRT\";\r",
													"const expectedBlockingOutcome = \"block\";\r",
													"const expectedReviewFlag = true;\r",
													"const expectedTypologyAlert = false;\r",
													"const expectedTypologyInterdiction = false;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('dbtrNttyId');\r",
													"let dbtrAcctId = pm.globals.get('dbtrAcctId');\r",
													"let cdtrId = pm.globals.get('cdtrNttyId');\r",
													"let cdtrAcctId = pm.globals.get('cdtrAcctId');\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ dbtrId,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ dbtrAcctId,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ 'fsp001',\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Post pacs.002 to TMS API - NO TIMEOUT EXPECTED",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`Alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"ALRT\";\r",
													"const expectedBlockingOutcome = \"block\";\r",
													"const expectedReviewFlag = true;\r",
													"const expectedTypologyAlert = false;\r",
													"const expectedTypologyInterdiction = false;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('dbtrNttyId');\r",
													"let dbtrAcctId = pm.globals.get('dbtrAcctId');\r",
													"let cdtrId = pm.globals.get('cdtrNttyId');\r",
													"let cdtrAcctId = pm.globals.get('cdtrAcctId');\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ dbtrId,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ dbtrAcctId,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ 'fsp001',\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Post pacs.002 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`Alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"ALRT\";\r",
													"const expectedBlockingOutcome = \"block\";\r",
													"const expectedReviewFlag = true;\r",
													"const expectedTypologyAlert = false;\r",
													"const expectedTypologyInterdiction = false;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "overridable block",
							"item": [
								{
									"name": "Create New Entity Condition Manually - Unknown debtor entity",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"responseJSON = pm.response.json();\r",
													"let conditionResult = responseJSON.result.conditions;\r",
													"let conditionEntity = responseJSON.result.ntty;\r",
													"let requestMessage = responseJSON.message;\r",
													"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
													"let nttyId = pm.globals.get(\"dbtrNttyId\");\r",
													"let nttyIdSchme = pm.globals.get(\"dbtrNttyIdSchmeNm\");\r",
													"let tenantId = pm.globals.get(\"tenantId\");\r",
													"let targetEntityId = nttyId + nttyIdSchme;\r",
													"\r",
													"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
													"targetRequestMessage = \"New condition was saved successfully.\"\r",
													"\r",
													"pm.test(\"Status code is 200\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(\"Result message matches target result message\", function () {\r",
													"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
													"});\r",
													"\r",
													"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
													"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
													"});\r",
													"\r",
													"pm.test(\"Result conditions array only contains a single condition\", function () {\r",
													"    pm.expect(conditionResult.length).to.be.eql(1);\r",
													"});\r",
													"\r",
													"let firstElement = conditionResult[0];\r",
													"\r",
													"pm.test(\"Result condition has a non-empty condId\", function () {\r",
													"    pm.expect(firstElement.condId).to.exist.and.not.be.empty;\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.condTp).to.be.eql(targetConditionResult.condTp);\r",
													"});\r",
													"\r",
													"if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"    pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
													"        pm.expect(firstElement.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"    });\r",
													"} else {    // if not, one must have been defaulted\r",
													"    pm.test(\"Result condition has a non-empty incptnDtTm\", function () {\r",
													"        pm.expect(firstElement.incptnDtTm).to.exist.and.not.be.empty;\r",
													"    });\r",
													"}\r",
													"\r",
													"if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"    pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
													"        pm.expect(firstElement.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"    });\r",
													"} else {    // if not, one must not have been defaulted\r",
													"    pm.test(\"Result condition does not have an xprtnDtTm\", function () {\r",
													"        pm.expect(firstElement.xprtnDtTm).to.not.exist;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.usr).to.be.eql(targetConditionResult.usr);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition has a non-empty creDtTm\", function () {\r",
													"    pm.expect(firstElement.creDtTm).to.exist.and.not.be.empty;\r",
													"});\r",
													"\r",
													"// create an array that only includes the perspective descriptions so that we can evaluate them easily\r",
													"let perspectives = firstElement.prsptvs.map(({ prsptv }) => prsptv);\r",
													"\r",
													"if (targetConditionResult.prsptv === \"both\") {\r",
													"    pm.test(\"Result prsptv array contains only 2 perspectives\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(2);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_creditor_by\", \"governed_as_debtor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains both ${JSON.stringify(targetPerspectives)} perspectives`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"} else if (targetConditionResult.prsptv === \"debtor\") {\r",
													"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_debtor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"} else if (targetConditionResult.prsptv === \"creditor\") {\r",
													"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_creditor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"};\r",
													"\r",
													"for (let i = 0; i < firstElement.prsptvs.length; i++) {   // for each perspective\r",
													"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} contains a non-empty evtTp array`, function () {\r",
													"        pm.expect(firstElement.prsptvs[i].evtTp).to.be.an('array').and.not.be.empty;\r",
													"    });\r",
													"\r",
													"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} evtTp array matches submitted condition`, function () {\r",
													"        pm.expect(firstElement.prsptvs[i].evtTp).to.include.members(targetConditionResult.evtTp);\r",
													"    });\r",
													"\r",
													"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches submitted condition`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must have been defaulted\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches created condition incptDtTm`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.eql(firstElement.incptnDtTm);\r",
													"        });\r",
													"    }\r",
													"\r",
													"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} xprtnDtTm matches submitted condition`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must not have been defaulted\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} does not have an xprtnDtTm`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.not.exist;\r",
													"        });\r",
													"    }\r",
													"\r",
													"}\r",
													"\r",
													"pm.test(\"Result condition ntty.id matches submitted condition\", function () {\r",
													"    pm.expect(conditionEntity.id).to.be.eql(targetConditionResult.ntty.id);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"    pm.expect(conditionEntity.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
													"});\r",
													"\r",
													"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetEntityId, false);;\r",
													"\r",
													"await pm.sendRequest(postRequest, (error, response) => {\r",
													"    if (utils.getLogLevel() === 'DEBUG') {\r",
													"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
													"    }\r",
													"    databaseConditionResult = response.json().data;\r",
													"\r",
													"    if (utils.getLogLevel() === 'DEBUG') {\r",
													"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
													"    }\r",
													"\r",
													"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
													"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
													"\r",
													"    pm.test(`Only one condition for entity [${targetEntityId}] exists in the database`, function () {\r",
													"        pm.expect(graphConditionList.length).to.eql(1);\r",
													"    });\r",
													"\r",
													"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
													"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
													"            pm.expect(conditionGraph.v[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
													"        });\r",
													"    }\r",
													"\r",
													"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
													"    });\r",
													"\r",
													"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"        pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
													"            pm.expect(conditionGraph.v[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must have been defaulted\r",
													"        pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
													"            pm.expect(conditionGraph.v[0].incptnDtTm).to.exist.and.not.be.empty;\r",
													"        });\r",
													"    }\r",
													"\r",
													"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"        pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
													"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must not have been defaulted\r",
													"        pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
													"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.not.exist;\r",
													"        });\r",
													"    }\r",
													"\r",
													"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].ntty.id).to.be.eql(targetConditionResult.ntty.id);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].ntty.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].usr).to.be.eql(targetConditionResult.usr);\r",
													"    });\r",
													"\r",
													"    let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, conditionGraph.v[0]._key);\r",
													"\r",
													"    pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
													"        pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database 'governed_as_creditor_by' edge does not exist\", function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
													"    });\r",
													"\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"// Obliterate the current contents of the global variables\r",
													"pm.globals.clear();\r",
													"\r",
													"// Set up the transaction (in memory)\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ 3600000,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"\r",
													"// Retrieve the created pacs.008 message\r",
													"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
													"\r",
													"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
													"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
													"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
													"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
													"\r",
													"// Load deconstructued identifier variables into global variables\r",
													"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
													"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
													"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
													"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
													"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
													"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
													"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
													"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
													"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
													"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
													"\r",
													"// Set up the condition\r",
													"\r",
													"messageBody = {\r",
													"  \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09\",\"pacs.008.001.10\",\"pacs.002.001.12\"],\r",
													"  \"condTp\":\"overridable-block\",\r",
													"  \"prsptv\":\"debtor\",\r",
													"  \"condRsn\":\"Default Test Condition\",\r",
													"  \"ntty\":\r",
													"  {\r",
													"    \"id\": `${dbtrNttyId.id}`,\r",
													"    \"schmeNm\":\r",
													"    {\r",
													"      \"prtry\":\"TAZAMA_EID\"\r",
													"    }\r",
													"  },\r",
													"  \"forceCret\":true,\r",
													"  \"usr\":\"POSTMAN\"\r",
													"}\r",
													"\r",
													"// Set up body variables\r",
													"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
													"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
											"host": [
												"{{tazamaAdminUrl}}{{path-admin-api-version}}"
											],
											"path": [
												"{{path-entity-condition}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('debtorId');\r",
													"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
													"let cdtrId = pm.globals.get('creditorId');\r",
													"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ dbtrId,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ dbtrAcctId,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ 'fsp001',\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Post pacs.002 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`Alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"ALRT\";\r",
													"const expectedBlockingOutcome = \"block\";\r",
													"const expectedReviewFlag = true;\r",
													"const expectedTypologyAlert = false;\r",
													"const expectedTypologyInterdiction = false;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('debtorId');\r",
													"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
													"let cdtrId = pm.globals.get('creditorId');\r",
													"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ dbtrId,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ dbtrAcctId,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ 'fsp001',\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Post pacs.002 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`Alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"ALRT\";\r",
													"const expectedBlockingOutcome = \"block\";\r",
													"const expectedReviewFlag = true;\r",
													"const expectedTypologyAlert = true;\r",
													"const expectedTypologyInterdiction = false;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('debtorId');\r",
													"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
													"let cdtrId = pm.globals.get('creditorId');\r",
													"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ dbtrId,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ dbtrAcctId,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ 'fsp001',\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Post pacs.002 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`Alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"ALRT\";\r",
													"const expectedBlockingOutcome = \"block\";\r",
													"const expectedReviewFlag = true;\r",
													"const expectedTypologyAlert = true;\r",
													"const expectedTypologyInterdiction = true;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "overridable block with override",
							"item": [
								{
									"name": "Create New Entity Condition Manually - Unknown debtor entity",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"responseJSON = pm.response.json();\r",
													"let conditionResult = responseJSON.result.conditions;\r",
													"let conditionEntity = responseJSON.result.ntty;\r",
													"let requestMessage = responseJSON.message;\r",
													"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
													"let nttyId = pm.globals.get(\"dbtrNttyId\");\r",
													"let nttyIdSchme = pm.globals.get(\"dbtrNttyIdSchmeNm\");\r",
													"let tenantId = pm.globals.get(\"tenantId\");\r",
													"let targetEntityId = nttyId + nttyIdSchme;\r",
													"\r",
													"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
													"targetRequestMessage = \"New condition was saved successfully.\"\r",
													"\r",
													"pm.test(\"Status code is 200\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(\"Result message matches target result message\", function () {\r",
													"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
													"});\r",
													"\r",
													"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
													"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
													"});\r",
													"\r",
													"pm.test(\"Result conditions array only contains a single condition\", function () {\r",
													"    pm.expect(conditionResult.length).to.be.eql(1);\r",
													"});\r",
													"\r",
													"let firstElement = conditionResult[0];\r",
													"\r",
													"pm.test(\"Result condition has a non-empty condId\", function () {\r",
													"    pm.expect(firstElement.condId).to.exist.and.not.be.empty;\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.condTp).to.be.eql(targetConditionResult.condTp);\r",
													"});\r",
													"\r",
													"if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"    pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
													"        pm.expect(firstElement.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"    });\r",
													"} else {    // if not, one must have been defaulted\r",
													"    pm.test(\"Result condition has a non-empty incptnDtTm\", function () {\r",
													"        pm.expect(firstElement.incptnDtTm).to.exist.and.not.be.empty;\r",
													"    });\r",
													"}\r",
													"\r",
													"if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"    pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
													"        pm.expect(firstElement.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"    });\r",
													"} else {    // if not, one must not have been defaulted\r",
													"    pm.test(\"Result condition does not have an xprtnDtTm\", function () {\r",
													"        pm.expect(firstElement.xprtnDtTm).to.not.exist;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.usr).to.be.eql(targetConditionResult.usr);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition has a non-empty creDtTm\", function () {\r",
													"    pm.expect(firstElement.creDtTm).to.exist.and.not.be.empty;\r",
													"});\r",
													"\r",
													"// create an array that only includes the perspective descriptions so that we can evaluate them easily\r",
													"let perspectives = firstElement.prsptvs.map(({ prsptv }) => prsptv);\r",
													"\r",
													"if (targetConditionResult.prsptv === \"both\") {\r",
													"    pm.test(\"Result prsptv array contains only 2 perspectives\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(2);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_creditor_by\", \"governed_as_debtor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains both ${JSON.stringify(targetPerspectives)} perspectives`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"} else if (targetConditionResult.prsptv === \"debtor\") {\r",
													"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_debtor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"} else if (targetConditionResult.prsptv === \"creditor\") {\r",
													"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_creditor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"};\r",
													"\r",
													"for (let i = 0; i < firstElement.prsptvs.length; i++) {   // for each perspective\r",
													"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} contains a non-empty evtTp array`, function () {\r",
													"        pm.expect(firstElement.prsptvs[i].evtTp).to.be.an('array').and.not.be.empty;\r",
													"    });\r",
													"\r",
													"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} evtTp array matches submitted condition`, function () {\r",
													"        pm.expect(firstElement.prsptvs[i].evtTp).to.include.members(targetConditionResult.evtTp);\r",
													"    });\r",
													"\r",
													"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches submitted condition`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must have been defaulted\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches created condition incptDtTm`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.eql(firstElement.incptnDtTm);\r",
													"        });\r",
													"    }\r",
													"\r",
													"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} xprtnDtTm matches submitted condition`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must not have been defaulted\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} does not have an xprtnDtTm`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.not.exist;\r",
													"        });\r",
													"    }\r",
													"\r",
													"}\r",
													"\r",
													"pm.test(\"Result condition ntty.id matches submitted condition\", function () {\r",
													"    pm.expect(conditionEntity.id).to.be.eql(targetConditionResult.ntty.id);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"    pm.expect(conditionEntity.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
													"});\r",
													"\r",
													"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetEntityId, false);;\r",
													"\r",
													"await pm.sendRequest(postRequest, (error, response) => {\r",
													"    if (utils.getLogLevel() === 'DEBUG') {\r",
													"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
													"    }\r",
													"    databaseConditionResult = response.json().data;\r",
													"\r",
													"    if (utils.getLogLevel() === 'DEBUG') {\r",
													"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
													"    }\r",
													"\r",
													"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
													"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
													"\r",
													"    pm.test(`Only one condition for entity [${targetEntityId}] exists in the database`, function () {\r",
													"        pm.expect(graphConditionList.length).to.eql(1);\r",
													"    });\r",
													"\r",
													"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
													"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
													"            pm.expect(conditionGraph.v[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
													"        });\r",
													"    }\r",
													"\r",
													"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
													"    });\r",
													"\r",
													"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"        pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
													"            pm.expect(conditionGraph.v[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must have been defaulted\r",
													"        pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
													"            pm.expect(conditionGraph.v[0].incptnDtTm).to.exist.and.not.be.empty;\r",
													"        });\r",
													"    }\r",
													"\r",
													"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"        pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
													"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must not have been defaulted\r",
													"        pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
													"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.not.exist;\r",
													"        });\r",
													"    }\r",
													"\r",
													"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].ntty.id).to.be.eql(targetConditionResult.ntty.id);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].ntty.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].usr).to.be.eql(targetConditionResult.usr);\r",
													"    });\r",
													"\r",
													"    let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, conditionGraph.v[0]._key);\r",
													"\r",
													"    pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
													"        pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database 'governed_as_creditor_by' edge does not exist\", function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
													"    });\r",
													"\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"// Obliterate the current contents of the global variables\r",
													"pm.globals.clear();\r",
													"\r",
													"// Set up the transaction (in memory)\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ 3600000,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"\r",
													"// Retrieve the created pacs.008 message\r",
													"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
													"\r",
													"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
													"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
													"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
													"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
													"\r",
													"// Load deconstructued identifier variables into global variables\r",
													"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
													"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
													"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
													"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
													"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
													"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
													"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
													"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
													"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
													"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
													"\r",
													"// Set up the condition\r",
													"\r",
													"console.log(`Overridable block incepts at ${utils.getTimestampNow()}`);\r",
													"\r",
													"messageBody = {\r",
													"  \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09\",\"pacs.008.001.10\",\"pacs.002.001.12\"],\r",
													"  \"condTp\":\"overridable-block\",\r",
													"  \"prsptv\":\"debtor\",\r",
													"  \"condRsn\":\"Default Test Condition\",\r",
													"  \"ntty\":\r",
													"  {\r",
													"    \"id\": `${dbtrNttyId.id}`,\r",
													"    \"schmeNm\":\r",
													"    {\r",
													"      \"prtry\":\"TAZAMA_EID\"\r",
													"    }\r",
													"  },\r",
													"  \"forceCret\":true,\r",
													"  \"usr\":\"POSTMAN\"\r",
													"}\r",
													"\r",
													"// Set up body variables\r",
													"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
													"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
											"host": [
												"{{tazamaAdminUrl}}{{path-admin-api-version}}"
											],
											"path": [
												"{{path-entity-condition}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Create New Entity Condition Manually - set override",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"responseJSON = pm.response.json();\r",
													"let conditionResult = responseJSON.result.conditions;\r",
													"let conditionEntity = responseJSON.result.ntty;\r",
													"let requestMessage = responseJSON.message;\r",
													"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
													"let nttyId = pm.globals.get(\"dbtrNttyId\");\r",
													"let nttyIdSchme = pm.globals.get(\"dbtrNttyIdSchmeNm\");\r",
													"let tenantId = pm.globals.get(\"tenantId\");\r",
													"let targetEntityId = nttyId + nttyIdSchme;\r",
													"\r",
													"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
													"targetRequestMessage = \"1 conditions already exist for the entity\"\r",
													"\r",
													"pm.test(\"Status code is 200\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(\"Result message matches target result message\", function () {\r",
													"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
													"});\r",
													"\r",
													"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
													"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
													"});\r",
													"\r",
													"pm.test(\"Result conditions array contains two conditions\", function () {\r",
													"    pm.expect(conditionResult.length).to.be.eql(2);\r",
													"});\r",
													"\r",
													"let newElement = conditionResult[conditionResult.length - 1];  // the last element is the newly submitted condition\r",
													"\r",
													"pm.test(\"Result condition has a non-empty condId\", function () {\r",
													"    pm.expect(newElement.condId).to.exist.and.not.be.empty;\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
													"    pm.expect(newElement.condTp).to.be.eql(targetConditionResult.condTp);\r",
													"});\r",
													"\r",
													"if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"    pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
													"        pm.expect(newElement.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"    });\r",
													"} else {    // if not, one must have been defaulted\r",
													"    pm.test(\"Result condition has a non-empty incptnDtTm\", function () {\r",
													"        pm.expect(newElement.incptnDtTm).to.exist.and.not.be.empty;\r",
													"    });\r",
													"}\r",
													"\r",
													"if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"    pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
													"        pm.expect(newElement.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"    });\r",
													"} else {    // if not, one must not have been defaulted\r",
													"    pm.test(\"Result condition does not have an xprtnDtTm\", function () {\r",
													"        pm.expect(newElement.xprtnDtTm).to.not.exist;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
													"    pm.expect(newElement.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
													"    pm.expect(newElement.usr).to.be.eql(targetConditionResult.usr);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition has a non-empty creDtTm\", function () {\r",
													"    pm.expect(newElement.creDtTm).to.exist.and.not.be.empty;\r",
													"});\r",
													"\r",
													"// create an array that only includes the perspective descriptions so that we can evaluate them easily\r",
													"let perspectives = newElement.prsptvs.map(({ prsptv }) => prsptv);\r",
													"\r",
													"if (targetConditionResult.prsptv === \"both\") {\r",
													"    pm.test(\"Result prsptv array contains only 2 perspectives\", function () {\r",
													"        pm.expect(newElement.prsptvs.length).to.be.eql(2);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_creditor_by\", \"governed_as_debtor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains both ${JSON.stringify(targetPerspectives)} perspectives`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"} else if (targetConditionResult.prsptv === \"debtor\") {\r",
													"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
													"        pm.expect(newElement.prsptvs.length).to.be.eql(1);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_debtor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"} else if (targetConditionResult.prsptv === \"creditor\") {\r",
													"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
													"        pm.expect(newElement.prsptvs.length).to.be.eql(1);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_creditor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"};\r",
													"\r",
													"for (let i = 0; i < newElement.prsptvs.length; i++) {   // for each perspective\r",
													"    pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} contains a non-empty evtTp array`, function () {\r",
													"        pm.expect(newElement.prsptvs[i].evtTp).to.be.an('array').and.not.be.empty;\r",
													"    });\r",
													"\r",
													"    pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} evtTp array matches submitted condition`, function () {\r",
													"        pm.expect(newElement.prsptvs[i].evtTp).to.include.members(targetConditionResult.evtTp);\r",
													"    });\r",
													"\r",
													"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"        pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} incptnDtTm matches submitted condition`, function () {\r",
													"            pm.expect(newElement.prsptvs[i].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must have been defaulted\r",
													"        pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} incptnDtTm matches created condition incptDtTm`, function () {\r",
													"            pm.expect(newElement.prsptvs[i].incptnDtTm).to.eql(newElement.incptnDtTm);\r",
													"        });\r",
													"    }\r",
													"\r",
													"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"        pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} xprtnDtTm matches submitted condition`, function () {\r",
													"            pm.expect(newElement.prsptvs[i].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must not have been defaulted\r",
													"        pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} does not have an xprtnDtTm`, function () {\r",
													"            pm.expect(newElement.prsptvs[i].xprtnDtTm).to.not.exist;\r",
													"        });\r",
													"    }\r",
													"\r",
													"}\r",
													"\r",
													"pm.test(\"Result condition ntty.id matches submitted condition\", function () {\r",
													"    pm.expect(conditionEntity.id).to.be.eql(targetConditionResult.ntty.id);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"    pm.expect(conditionEntity.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
													"});\r",
													"\r",
													"// Now we want to test that the data in the database matches the submitted data AND the response data\r",
													"\r",
													"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetEntityId, false);;\r",
													"\r",
													"await pm.sendRequest(postRequest, (error, response) => {\r",
													"    if (utils.getLogLevel() === 'DEBUG') {\r",
													"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
													"    }\r",
													"    databaseConditionResult = response.json().data;\r",
													"\r",
													"    if (utils.getLogLevel() === 'DEBUG') {\r",
													"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
													"    }\r",
													"\r",
													"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
													"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
													"\r",
													"    let submittedCondition = graphConditionList.filter(condition => condition._id === `conditions/${newElement.condId}`);\r",
													"\r",
													"    // First we check that the submitted condition matches the database version\r",
													"\r",
													"    pm.test(`Only two conditions for entity [${targetEntityId}] exists in the database`, function () {\r",
													"        pm.expect(graphConditionList.length).to.eql(2);\r",
													"    });\r",
													"\r",
													"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
													"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
													"            pm.expect(submittedCondition[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
													"        });\r",
													"    }\r",
													"\r",
													"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
													"        pm.expect(submittedCondition[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
													"        pm.expect(submittedCondition[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
													"    });\r",
													"\r",
													"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"        pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
													"            pm.expect(submittedCondition[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must have been defaulted\r",
													"        pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
													"            pm.expect(submittedCondition[0].incptnDtTm).to.exist.and.not.be.empty;\r",
													"        });\r",
													"    }\r",
													"\r",
													"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"        pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
													"            pm.expect(submittedCondition[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must not have been defaulted\r",
													"        pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
													"            pm.expect(submittedCondition[0].xprtnDtTm).to.not.exist;\r",
													"        });\r",
													"    }\r",
													"\r",
													"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
													"        pm.expect(submittedCondition[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
													"        pm.expect(submittedCondition[0].ntty.id).to.be.eql(targetConditionResult.ntty.id);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"        pm.expect(submittedCondition[0].ntty.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
													"        pm.expect(submittedCondition[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
													"        pm.expect(submittedCondition[0].usr).to.be.eql(targetConditionResult.usr);\r",
													"    });\r",
													"\r",
													"    let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, submittedCondition[0]._key);\r",
													"\r",
													"    pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
													"        pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database 'governed_as_creditor_by' edge does not exist\", function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
													"    });\r",
													"\r",
													"    // Then we check the previous conditions in the response one-by-one against the database version\r",
													"    let previousConditionsFromResponse = graphConditionList.filter(condition => condition._id != `conditions/${newElement.condId}`);\r",
													"    let previousResponseConditionIds = previousConditionsFromResponse.map(({ condId }) => condId);\r",
													"    let previousConditionsFromDatabase = graphConditionList.filter(condition => condition._id != `conditions/${newElement.condId}`);\r",
													"    let previousDatabaseConditionIds = previousConditionsFromDatabase.map(({ condId }) => condId);\r",
													"\r",
													"    pm.test(`List of previous conditions in response match list of conditions from database`, function () {\r",
													"        pm.expect(previousResponseConditionIds).to.have.members(previousDatabaseConditionIds);\r",
													"    });\r",
													"\r",
													"    pm.test(`Only one previous condition for entity [${targetEntityId}] exists in the reponse`, function () {\r",
													"        pm.expect(previousConditionsFromResponse.length).to.eql(1);\r",
													"    });\r",
													"\r",
													"    pm.test(`Only one previous condition for entity [${targetEntityId}] exists in the database`, function () {\r",
													"        pm.expect(previousConditionsFromDatabase.length).to.eql(1);\r",
													"    });\r",
													"\r",
													"    for (let j = 0; j < previousConditionsFromResponse.length; j++) {\r",
													"\r",
													"        let justOneConditionFromResponse = previousConditionsFromResponse.filter(condition => condition._id === `conditions/${conditionResult[j].condId}`);\r",
													"        let sameConditionFromDatabase = previousConditionsFromDatabase.filter(condition => condition._id === `conditions/${conditionResult[j].condId}`);\r",
													"\r",
													"        for (let i = 0; i < sameConditionFromDatabase[0].evtTp.length; i++) {\r",
													"            pm.test(`Database condition.evtTp contains ${sameConditionFromDatabase[0].evtTp[i]}`, function () {\r",
													"                pm.expect(justOneConditionFromResponse[0].evtTp).to.include.members([sameConditionFromDatabase[0].evtTp[i]]);\r",
													"            });\r",
													"        }\r",
													"\r",
													"        pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
													"            pm.expect(justOneConditionFromResponse[0].condTp).to.be.eql(sameConditionFromDatabase[0].condTp);\r",
													"        });\r",
													"\r",
													"        pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
													"            pm.expect(justOneConditionFromResponse[0].prsptv).to.be.eql(sameConditionFromDatabase[0].prsptv);\r",
													"        });\r",
													"\r",
													"        if (sameConditionFromDatabase[0].incptnDtTm) { // was an inception date specified?\r",
													"            pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
													"                pm.expect(justOneConditionFromResponse[0].incptnDtTm).to.be.eql(sameConditionFromDatabase[0].incptnDtTm);\r",
													"            });\r",
													"        } else {    // if not, one must have been defaulted\r",
													"            pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
													"                pm.expect(justOneConditionFromResponse[0].incptnDtTm).to.exist.and.not.be.empty;\r",
													"            });\r",
													"        }\r",
													"\r",
													"        if (sameConditionFromDatabase[0].xprtnDtTm) { // was an expiration date specified?\r",
													"            pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
													"                pm.expect(justOneConditionFromResponse[0].xprtnDtTm).to.be.eql(sameConditionFromDatabase[0].xprtnDtTm);\r",
													"            });\r",
													"        } else {    // if not, one must not have been defaulted\r",
													"            pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
													"                pm.expect(justOneConditionFromResponse[0].xprtnDtTm).to.not.exist;\r",
													"            });\r",
													"        }\r",
													"\r",
													"        pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
													"            pm.expect(justOneConditionFromResponse[0].condRsn).to.be.eql(sameConditionFromDatabase[0].condRsn);\r",
													"        });\r",
													"\r",
													"        pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
													"            pm.expect(justOneConditionFromResponse[0].ntty.id).to.be.eql(sameConditionFromDatabase[0].ntty.id);\r",
													"        });\r",
													"\r",
													"        pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"            pm.expect(justOneConditionFromResponse[0].ntty.schmeNm.prtry).to.be.eql(sameConditionFromDatabase[0].ntty.schmeNm.prtry);\r",
													"        });\r",
													"\r",
													"        pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
													"            pm.expect(justOneConditionFromResponse[0].forceCret).to.be.eql(sameConditionFromDatabase[0].forceCret);\r",
													"        });\r",
													"\r",
													"        pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
													"            pm.expect(justOneConditionFromResponse[0].usr).to.be.eql(sameConditionFromDatabase[0].usr);\r",
													"        });\r",
													"\r",
													"        let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, justOneConditionFromResponse[0]._key);\r",
													"\r",
													"        pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
													"            pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
													"        });\r",
													"\r",
													"        pm.test(\"Database 'governed_as_creditor_by' edge does not exist\", function () {\r",
													"            pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_by\"]);\r",
													"        });\r",
													"\r",
													"        pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
													"            pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
													"        });\r",
													"\r",
													"        pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
													"            pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
													"        });\r",
													"    }\r",
													"\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"// Retrieve the created pacs.008 message\r",
													"const submittedPacs008Message = utils.addTenantId(null, JSON.parse(pm.globals.get(\"pacs008\")));\r",
													"\r",
													"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
													"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
													"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
													"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
													"\r",
													"// Load deconstructued identifier variables into global variables\r",
													"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
													"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
													"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
													"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
													"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
													"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
													"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
													"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
													"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
													"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
													"\r",
													"xprtnDtTm = utils.timestampAtTMinus(-10, \"m\");\r",
													"\r",
													"// Set up the condition\r",
													"\r",
													"console.log(`Override incepts at ${utils.getTimestampNow()}`);\r",
													"\r",
													"messageBody = {\r",
													"  \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09\",\"pacs.008.001.10\",\"pacs.002.001.12\"],\r",
													"  \"condTp\":\"override\",\r",
													"  \"prsptv\":\"debtor\",\r",
													"  \"xprtnDtTm\": xprtnDtTm,\r",
													"  \"condRsn\":\"Default Test Condition\",\r",
													"  \"ntty\":\r",
													"  {\r",
													"    \"id\": `${dbtrNttyId.id}`,\r",
													"    \"schmeNm\":\r",
													"    {\r",
													"      \"prtry\":\"TAZAMA_EID\"\r",
													"    }\r",
													"  },\r",
													"  \"forceCret\":true,\r",
													"  \"usr\":\"POSTMAN\"\r",
													"}\r",
													"\r",
													"// Set up body variables\r",
													"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
													"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
											"host": [
												"{{tazamaAdminUrl}}{{path-admin-api-version}}"
											],
											"path": [
												"{{path-entity-condition}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('debtorId');\r",
													"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
													"let cdtrId = pm.globals.get('creditorId');\r",
													"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
													"\r",
													"// Hacky workaround for testing the timeout of the submission of the pacs002 after this test\r",
													"pm.globals.set('responseTimedOut', true);\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ dbtrId,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ dbtrAcctId,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ 'fsp001',\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Post pacs.002 to TMS API - EXPECTED TIMEOUT",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"// Hacky workaround for testing the timeout of the submission of the pacs002\r",
													"pm.globals.set('responseTimedOut', false);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`No alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													"\r",
													"pm.test(`Request does not complete within specified timeout of ${pm.globals.get('timeoutLimit')}`, function () {\r",
													"    pm.expect(pm.response.responseTime).to.be.above(4000);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"NALT\";\r",
													"const expectedBlockingOutcome = \"override\";\r",
													"const expectedReviewFlag = false;\r",
													"const expectedTypologyAlert = false;\r",
													"const expectedTypologyInterdiction = false;\r",
													"const expectedResponseTimedOut = true;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });\r",
													"\r",
													"pm.test(`No response received at EFRuP interdiction service before timeout`, function () {\r",
													"        pm.expect(pm.globals.get('responseTimedOut')).to.be.eql(expectedResponseTimedOut);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('debtorId');\r",
													"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
													"let cdtrId = pm.globals.get('creditorId');\r",
													"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
													"\r",
													"// Hacky workaround for testing the timeout of the submission of the pacs002 after this test\r",
													"pm.globals.set('responseTimedOut', true);\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ dbtrId,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ dbtrAcctId,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ 'fsp001',\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Post pacs.002 to TMS API - EXPECTED TIMEOUT",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"// Hacky workaround for testing the timeout of the submission of the pacs002\r",
													"pm.globals.set('responseTimedOut', false);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`No alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													"\r",
													"pm.test(`Request does not complete within specified timeout of ${pm.globals.get('timeoutLimit')}`, function () {\r",
													"    pm.expect(pm.response.responseTime).to.be.above(4000);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"ALRT\";\r",
													"const expectedBlockingOutcome = \"override\";\r",
													"const expectedReviewFlag = true;\r",
													"const expectedTypologyAlert = true;\r",
													"const expectedTypologyInterdiction = false;\r",
													"const expectedResponseTimedOut = true;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });\r",
													"\r",
													"pm.test(`No response received at EFRuP interdiction service before timeout`, function () {\r",
													"        pm.expect(pm.globals.get('responseTimedOut')).to.be.eql(expectedResponseTimedOut);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('debtorId');\r",
													"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
													"let cdtrId = pm.globals.get('creditorId');\r",
													"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
													"\r",
													"// Hacky workaround for testing the timeout of the submission of the pacs002 after this test\r",
													"pm.globals.set('responseTimedOut', true);\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ dbtrId,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ dbtrAcctId,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ 'fsp001',\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Post pacs.002 to TMS API - EXPECTED TIMEOUT",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"// Hacky workaround for testing the timeout of the submission of the pacs002\r",
													"pm.globals.set('responseTimedOut', false);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`No alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													"\r",
													"pm.test(`Request does not complete within specified timeout of ${pm.globals.get('timeoutLimit')}`, function () {\r",
													"    pm.expect(pm.response.responseTime).to.be.above(4000);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"ALRT\";\r",
													"const expectedBlockingOutcome = \"override\";\r",
													"const expectedReviewFlag = true;\r",
													"const expectedTypologyAlert = true;\r",
													"const expectedTypologyInterdiction = true;\r",
													"const expectedResponseTimedOut = true;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });\r",
													"\r",
													"pm.test(`No response received at EFRuP interdiction service before timeout`, function () {\r",
													"        pm.expect(pm.globals.get('responseTimedOut')).to.be.eql(expectedResponseTimedOut);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "interdiction with override",
							"item": [
								{
									"name": "Before override",
									"item": [
										{
											"name": "Transaction 1 - Post pacs.008 to TMS API",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
															"\r",
															"let dbtrId = pm.globals.get('debtorId');\r",
															"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
															"let cdtrId = pm.globals.get('creditorId');\r",
															"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
															"\r",
															"// Hacky workaround for testing the timeout of the submission of the pacs002 after this test\r",
															"pm.globals.set('responseTimedOut', true);\r",
															"\r",
															"// ## Set up transaction eco-system\r",
															"\r",
															"messageSet = utils.createTransactionSetInMemory(\r",
															"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
															"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
															"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
															"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
															"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
															"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
															"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
															"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
															"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
															"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
															"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
															"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
															"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
															"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
															"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
															"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
															"    /* Description - null defaults random UUID ---------------------- */ null,\r",
															"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
															"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
															"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
															"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
															"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
															"    );\r",
															"\r",
															"let messageBody = pm.globals.get('pacs008');\r",
															"pm.globals.set('pacs008Stash', messageBody);\r",
															"pm.globals.set('messageBody', messageBody);"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{{messageBody}}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
													"host": [
														"{{tazamaTMSUrl}}{{path-tms-api-version}}"
													],
													"path": [
														"{{path-pacs008}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 1 - Post pacs.002 to TMS API",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"let messageBody = pm.globals.get('pacs002');\r",
															"pm.globals.set('messageBody', messageBody);"
														],
														"type": "text/javascript",
														"packages": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{{pacs002}}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs002}}",
													"host": [
														"{{tazamaTMSUrl}}{{path-tms-api-version}}"
													],
													"path": [
														"{{path-pacs002}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 1 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
														],
														"type": "text/javascript",
														"packages": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"const resJson = pm.response.json();\r",
															"\r",
															"const rulesPerTypologyCount = [3];\r",
															"const totalExpectedTypologies = 1;\r",
															"const expectedAlertStatus = \"NALT\";\r",
															"const expectedBlockingOutcome = \"none\";\r",
															"const expectedReviewFlag = false;\r",
															"const expectedTypologyAlert = false;\r",
															"const expectedTypologyInterdiction = false;\r",
															"\r",
															"const interdictionTypologies = [\r",
															"  \"999\"\r",
															"];\r",
															"const ruleDescriptions = {\r",
															"  \"901\": \"Number of outgoing transactions - debtor\",\r",
															"  \"902\": \"Number of incoming transactions - creditor\",\r",
															"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
															"}\r",
															"const typologyDescriptions = {\r",
															"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
															"}\r",
															"\r",
															"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
															"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
															"\r",
															"typologyCount = typologyResultsUnique.count();\r",
															"ruleCount = ruleResultsUnique.count();\r",
															"\r",
															"foundEFRuP = false;\r",
															"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
															"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
															"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
															"        foundEFRuP = true;\r",
															"    }\r",
															"}\r",
															"\r",
															"ruleWeightingTotal = 0;\r",
															"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
															"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
															"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
															"    }    \r",
															"}\r",
															"\r",
															"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
															"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
															"});\r",
															"\r",
															"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
															"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
															"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
															"    pm.expect(foundEFRuP).to.be.true;\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
															"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
															"});\r",
															"\r",
															"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedReviewFlag) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
															"    });\r",
															"} else {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
															"    });\r",
															"}\r",
															"\r",
															"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
															"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
															"    });"
														],
														"type": "text/javascript",
														"packages": {}
													}
												}
											],
											"request": {
												"auth": {
													"type": "bearer",
													"bearer": [
														{
															"key": "token",
															"value": "{{auth-token}}",
															"type": "string"
														}
													]
												},
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
													"host": [
														"{{arangoUrl}}"
													],
													"path": [
														"_db",
														"{{db_results}}",
														"_api",
														"cursor"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 2 - Post pacs.008 to TMS API",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
															"\r",
															"let dbtrId = pm.globals.get('debtorId');\r",
															"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
															"let cdtrId = pm.globals.get('creditorId');\r",
															"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
															"\r",
															"// Hacky workaround for testing the timeout of the submission of the pacs002 after this test\r",
															"pm.globals.set('responseTimedOut', true);\r",
															"\r",
															"// ## Set up transaction eco-system\r",
															"\r",
															"messageSet = utils.createTransactionSetInMemory(\r",
															"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
															"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
															"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
															"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
															"    /* Debtor ID - null defaults random UUID ------------------------ */ dbtrId,\r",
															"    /* Debtor Account ID - null defaults random UUID ---------------- */ dbtrAcctId,\r",
															"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ 'fsp001',\r",
															"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
															"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
															"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
															"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
															"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
															"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
															"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
															"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
															"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
															"    /* Description - null defaults random UUID ---------------------- */ null,\r",
															"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
															"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
															"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
															"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
															"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
															"    );\r",
															"\r",
															"let messageBody = pm.globals.get('pacs008');\r",
															"pm.globals.set('messageBody', messageBody);"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{{messageBody}}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
													"host": [
														"{{tazamaTMSUrl}}{{path-tms-api-version}}"
													],
													"path": [
														"{{path-pacs008}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 2 - Post pacs.002 to TMS API",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"let messageBody = pm.globals.get('pacs002');\r",
															"pm.globals.set('messageBody', messageBody);"
														],
														"type": "text/javascript",
														"packages": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{{pacs002}}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs002}}",
													"host": [
														"{{tazamaTMSUrl}}{{path-tms-api-version}}"
													],
													"path": [
														"{{path-pacs002}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 2 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
														],
														"type": "text/javascript",
														"packages": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"const resJson = pm.response.json();\r",
															"\r",
															"const rulesPerTypologyCount = [3];\r",
															"const totalExpectedTypologies = 1;\r",
															"const expectedAlertStatus = \"ALRT\";\r",
															"const expectedBlockingOutcome = \"none\";\r",
															"const expectedReviewFlag = true;\r",
															"const expectedTypologyAlert = true;\r",
															"const expectedTypologyInterdiction = false;\r",
															"\r",
															"const interdictionTypologies = [\r",
															"  \"999\"\r",
															"];\r",
															"const ruleDescriptions = {\r",
															"  \"901\": \"Number of outgoing transactions - debtor\",\r",
															"  \"902\": \"Number of incoming transactions - creditor\",\r",
															"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
															"}\r",
															"const typologyDescriptions = {\r",
															"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
															"}\r",
															"\r",
															"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
															"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
															"\r",
															"typologyCount = typologyResultsUnique.count();\r",
															"ruleCount = ruleResultsUnique.count();\r",
															"\r",
															"foundEFRuP = false;\r",
															"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
															"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
															"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
															"        foundEFRuP = true;\r",
															"    }\r",
															"}\r",
															"\r",
															"ruleWeightingTotal = 0;\r",
															"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
															"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
															"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
															"    }    \r",
															"}\r",
															"\r",
															"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
															"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
															"});\r",
															"\r",
															"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
															"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
															"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
															"    pm.expect(foundEFRuP).to.be.true;\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
															"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
															"});\r",
															"\r",
															"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedReviewFlag) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
															"    });\r",
															"} else {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
															"    });\r",
															"}\r",
															"\r",
															"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
															"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
															"    });"
														],
														"type": "text/javascript",
														"packages": {}
													}
												}
											],
											"request": {
												"auth": {
													"type": "bearer",
													"bearer": [
														{
															"key": "token",
															"value": "{{auth-token}}",
															"type": "string"
														}
													]
												},
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
													"host": [
														"{{arangoUrl}}"
													],
													"path": [
														"_db",
														"{{db_results}}",
														"_api",
														"cursor"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 3 - Post pacs.008 to TMS API",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
															"\r",
															"let dbtrId = pm.globals.get('debtorId');\r",
															"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
															"let cdtrId = pm.globals.get('creditorId');\r",
															"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
															"\r",
															"// Hacky workaround for testing the timeout of the submission of the pacs002 after this test\r",
															"pm.globals.set('responseTimedOut', true);\r",
															"\r",
															"// ## Set up transaction eco-system\r",
															"\r",
															"messageSet = utils.createTransactionSetInMemory(\r",
															"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
															"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
															"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
															"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
															"    /* Debtor ID - null defaults random UUID ------------------------ */ dbtrId,\r",
															"    /* Debtor Account ID - null defaults random UUID ---------------- */ dbtrAcctId,\r",
															"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ 'fsp001',\r",
															"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
															"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
															"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
															"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
															"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
															"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
															"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
															"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
															"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
															"    /* Description - null defaults random UUID ---------------------- */ null,\r",
															"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
															"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
															"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
															"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
															"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
															"    );\r",
															"\r",
															"let messageBody = pm.globals.get('pacs008');\r",
															"pm.globals.set('messageBody', messageBody);"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{{messageBody}}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
													"host": [
														"{{tazamaTMSUrl}}{{path-tms-api-version}}"
													],
													"path": [
														"{{path-pacs008}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 3 - Post pacs.002 to TMS API - NO EXPECTED TIMEOUT",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
															"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
															"const awaitReply = true; // Hold the phone for a callback\r",
															"\r",
															"let messageBody = pm.globals.get('pacs002');\r",
															"pm.globals.set('messageBody', messageBody);\r",
															"pm.globals.set('endpoint', endpoint);\r",
															"pm.globals.set('responseDestination', responseDestination);\r",
															"pm.globals.set('awaitReply', awaitReply);\r",
															""
														],
														"type": "text/javascript",
														"packages": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"const resJson = pm.response.json();\r",
															"console.log(resJson);\r",
															"\r",
															"// Hacky workaround for testing the timeout of the submission of the pacs002\r",
															"pm.globals.set('responseTimedOut', false);\r",
															"\r",
															"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});\r",
															"\r",
															"pm.test(`Interdiction alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
															"    pm.expect(resJson.edResponse.typologyResult.review).to.be.true;\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
													"host": [
														"{{natsUrl}}"
													],
													"path": [
														"{{nats-path-tms-api}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 3 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
														],
														"type": "text/javascript",
														"packages": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"const resJson = pm.response.json();\r",
															"\r",
															"const rulesPerTypologyCount = [3];\r",
															"const totalExpectedTypologies = 1;\r",
															"const expectedAlertStatus = \"ALRT\";\r",
															"const expectedBlockingOutcome = \"none\";\r",
															"const expectedReviewFlag = true;\r",
															"const expectedTypologyAlert = true;\r",
															"const expectedTypologyInterdiction = true;\r",
															"const expectedResponseTimedOut = false;\r",
															"\r",
															"const interdictionTypologies = [\r",
															"  \"999\"\r",
															"];\r",
															"const ruleDescriptions = {\r",
															"  \"901\": \"Number of outgoing transactions - debtor\",\r",
															"  \"902\": \"Number of incoming transactions - creditor\",\r",
															"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
															"}\r",
															"const typologyDescriptions = {\r",
															"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
															"}\r",
															"\r",
															"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
															"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
															"\r",
															"typologyCount = typologyResultsUnique.count();\r",
															"ruleCount = ruleResultsUnique.count();\r",
															"\r",
															"foundEFRuP = false;\r",
															"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
															"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
															"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
															"        foundEFRuP = true;\r",
															"    }\r",
															"}\r",
															"\r",
															"ruleWeightingTotal = 0;\r",
															"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
															"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
															"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
															"    }    \r",
															"}\r",
															"\r",
															"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
															"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
															"});\r",
															"\r",
															"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
															"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
															"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
															"    pm.expect(foundEFRuP).to.be.true;\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
															"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
															"});\r",
															"\r",
															"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedReviewFlag) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
															"    });\r",
															"} else {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
															"    });\r",
															"}\r",
															"\r",
															"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
															"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
															"    });\r",
															"\r",
															"pm.test(`Response received at EFRuP interdiction service before timeout`, function () {\r",
															"        pm.expect(pm.globals.get('responseTimedOut')).to.be.eql(expectedResponseTimedOut);\r",
															"    });"
														],
														"type": "text/javascript",
														"packages": {}
													}
												}
											],
											"request": {
												"auth": {
													"type": "bearer",
													"bearer": [
														{
															"key": "token",
															"value": "{{auth-token}}",
															"type": "string"
														}
													]
												},
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
													"host": [
														"{{arangoUrl}}"
													],
													"path": [
														"_db",
														"{{db_results}}",
														"_api",
														"cursor"
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "After override",
									"item": [
										{
											"name": "Create New Entity Condition Manually - Existing debtor",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"responseJSON = pm.response.json();\r",
															"let conditionResult = responseJSON.result.conditions;\r",
															"let conditionEntity = responseJSON.result.ntty;\r",
															"let requestMessage = responseJSON.message;\r",
															"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
															"let nttyId = pm.globals.get(\"dbtrNttyId\");\r",
															"let nttyIdSchme = pm.globals.get(\"dbtrNttyIdSchmeNm\");\r",
															"let tenantId = pm.globals.get(\"tenantId\");\r",
															"let targetEntityId = nttyId + nttyIdSchme;\r",
															"\r",
															"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
															"targetRequestMessage = \"New condition was saved successfully.\"\r",
															"\r",
															"pm.test(\"Status code is 200\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});\r",
															"\r",
															"pm.test(\"Result message matches target result message\", function () {\r",
															"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
															"});\r",
															"\r",
															"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
															"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
															"});\r",
															"\r",
															"pm.test(\"Result conditions array only contains a single condition\", function () {\r",
															"    pm.expect(conditionResult.length).to.be.eql(1);\r",
															"});\r",
															"\r",
															"let firstElement = conditionResult[0];\r",
															"\r",
															"pm.test(\"Result condition has a non-empty condId\", function () {\r",
															"    pm.expect(firstElement.condId).to.exist.and.not.be.empty;\r",
															"});\r",
															"\r",
															"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
															"    pm.expect(firstElement.condTp).to.be.eql(targetConditionResult.condTp);\r",
															"});\r",
															"\r",
															"if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
															"    pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
															"        pm.expect(firstElement.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
															"    });\r",
															"} else {    // if not, one must have been defaulted\r",
															"    pm.test(\"Result condition has a non-empty incptnDtTm\", function () {\r",
															"        pm.expect(firstElement.incptnDtTm).to.exist.and.not.be.empty;\r",
															"    });\r",
															"}\r",
															"\r",
															"if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
															"    pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
															"        pm.expect(firstElement.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
															"    });\r",
															"} else {    // if not, one must not have been defaulted\r",
															"    pm.test(\"Result condition does not have an xprtnDtTm\", function () {\r",
															"        pm.expect(firstElement.xprtnDtTm).to.not.exist;\r",
															"    });\r",
															"}\r",
															"\r",
															"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
															"    pm.expect(firstElement.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
															"});\r",
															"\r",
															"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
															"    pm.expect(firstElement.usr).to.be.eql(targetConditionResult.usr);\r",
															"});\r",
															"\r",
															"pm.test(\"Result condition has a non-empty creDtTm\", function () {\r",
															"    pm.expect(firstElement.creDtTm).to.exist.and.not.be.empty;\r",
															"});\r",
															"\r",
															"// create an array that only includes the perspective descriptions so that we can evaluate them easily\r",
															"let perspectives = firstElement.prsptvs.map(({ prsptv }) => prsptv);\r",
															"\r",
															"if (targetConditionResult.prsptv === \"both\") {\r",
															"    pm.test(\"Result prsptv array contains only 2 perspectives\", function () {\r",
															"        pm.expect(firstElement.prsptvs.length).to.be.eql(2);\r",
															"    });\r",
															"\r",
															"    let targetPerspectives = [\"governed_as_creditor_by\", \"governed_as_debtor_by\"];\r",
															"\r",
															"    pm.test(`Result prsptv array contains both ${JSON.stringify(targetPerspectives)} perspectives`, function () {\r",
															"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
															"    });\r",
															"\r",
															"} else if (targetConditionResult.prsptv === \"debtor\") {\r",
															"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
															"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
															"    });\r",
															"\r",
															"    let targetPerspectives = [\"governed_as_debtor_by\"];\r",
															"\r",
															"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
															"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
															"    });\r",
															"\r",
															"} else if (targetConditionResult.prsptv === \"creditor\") {\r",
															"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
															"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
															"    });\r",
															"\r",
															"    let targetPerspectives = [\"governed_as_creditor_by\"];\r",
															"\r",
															"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
															"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
															"    });\r",
															"\r",
															"};\r",
															"\r",
															"for (let i = 0; i < firstElement.prsptvs.length; i++) {   // for each perspective\r",
															"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} contains a non-empty evtTp array`, function () {\r",
															"        pm.expect(firstElement.prsptvs[i].evtTp).to.be.an('array').and.not.be.empty;\r",
															"    });\r",
															"\r",
															"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} evtTp array matches submitted condition`, function () {\r",
															"        pm.expect(firstElement.prsptvs[i].evtTp).to.include.members(targetConditionResult.evtTp);\r",
															"    });\r",
															"\r",
															"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
															"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches submitted condition`, function () {\r",
															"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
															"        });\r",
															"    } else {    // if not, one must have been defaulted\r",
															"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches created condition incptDtTm`, function () {\r",
															"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.eql(firstElement.incptnDtTm);\r",
															"        });\r",
															"    }\r",
															"\r",
															"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
															"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} xprtnDtTm matches submitted condition`, function () {\r",
															"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
															"        });\r",
															"    } else {    // if not, one must not have been defaulted\r",
															"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} does not have an xprtnDtTm`, function () {\r",
															"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.not.exist;\r",
															"        });\r",
															"    }\r",
															"\r",
															"}\r",
															"\r",
															"pm.test(\"Result condition ntty.id matches submitted condition\", function () {\r",
															"    pm.expect(conditionEntity.id).to.be.eql(targetConditionResult.ntty.id);\r",
															"});\r",
															"\r",
															"pm.test(\"Result condition ntty.schmeNm.prtry matches submitted condition\", function () {\r",
															"    pm.expect(conditionEntity.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
															"});\r",
															"\r",
															"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetEntityId, false);;\r",
															"\r",
															"await pm.sendRequest(postRequest, (error, response) => {\r",
															"    if (utils.getLogLevel() === 'DEBUG') {\r",
															"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
															"    }\r",
															"    databaseConditionResult = response.json().data;\r",
															"\r",
															"    if (utils.getLogLevel() === 'DEBUG') {\r",
															"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
															"    }\r",
															"\r",
															"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
															"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
															"\r",
															"    pm.test(`Only one condition for entity [${targetEntityId}] exists in the database`, function () {\r",
															"        pm.expect(graphConditionList.length).to.eql(1);\r",
															"    });\r",
															"\r",
															"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
															"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
															"            pm.expect(conditionGraph.v[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
															"        });\r",
															"    }\r",
															"\r",
															"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
															"        pm.expect(conditionGraph.v[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
															"    });\r",
															"\r",
															"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
															"        pm.expect(conditionGraph.v[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
															"    });\r",
															"\r",
															"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
															"        pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
															"            pm.expect(conditionGraph.v[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
															"        });\r",
															"    } else {    // if not, one must have been defaulted\r",
															"        pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
															"            pm.expect(conditionGraph.v[0].incptnDtTm).to.exist.and.not.be.empty;\r",
															"        });\r",
															"    }\r",
															"\r",
															"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
															"        pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
															"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
															"        });\r",
															"    } else {    // if not, one must not have been defaulted\r",
															"        pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
															"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.not.exist;\r",
															"        });\r",
															"    }\r",
															"\r",
															"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
															"        pm.expect(conditionGraph.v[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
															"    });\r",
															"\r",
															"    pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
															"        pm.expect(conditionGraph.v[0].ntty.id).to.be.eql(targetConditionResult.ntty.id);\r",
															"    });\r",
															"\r",
															"    pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
															"        pm.expect(conditionGraph.v[0].ntty.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
															"    });\r",
															"\r",
															"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
															"        pm.expect(conditionGraph.v[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
															"    });\r",
															"\r",
															"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
															"        pm.expect(conditionGraph.v[0].usr).to.be.eql(targetConditionResult.usr);\r",
															"    });\r",
															"\r",
															"    let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, conditionGraph.v[0]._key);\r",
															"\r",
															"    pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
															"        pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
															"    });\r",
															"\r",
															"    pm.test(\"Database 'governed_as_creditor_by' edge does not exist\", function () {\r",
															"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_by\"]);\r",
															"    });\r",
															"\r",
															"    pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
															"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
															"    });\r",
															"\r",
															"    pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
															"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
															"    });\r",
															"\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {}
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
															"\r",
															"// Obliterate the current contents of the global variables\r",
															"// Retrieve the created pacs.008 message\r",
															"\r",
															"const submittedPacs008Message = JSON.parse(pm.globals.get('pacs008Stash'));\r",
															"pm.globals.set('pacs008', pm.globals.get('pacs008Stash'));\r",
															"\r",
															"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
															"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
															"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
															"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
															"\r",
															"// Load deconstructued identifier variables into global variables\r",
															"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
															"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
															"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
															"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
															"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
															"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
															"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
															"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
															"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
															"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
															"\r",
															"xprtnDtTm = utils.timestampAtTMinus(-10, \"m\");\r",
															"\r",
															"// Set up the condition\r",
															"\r",
															"console.log(`Override incepts at ${utils.getTimestampNow()}`);\r",
															"\r",
															"messageBody = {\r",
															"  \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09\",\"pacs.008.001.10\",\"pacs.002.001.12\"],\r",
															"  \"condTp\":\"override\",\r",
															"  \"prsptv\":\"debtor\",\r",
															"  \"xprtnDtTm\": xprtnDtTm,\r",
															"  \"condRsn\":\"Default Test Condition\",\r",
															"  \"ntty\":\r",
															"  {\r",
															"    \"id\": `${dbtrNttyId.id}`,\r",
															"    \"schmeNm\":\r",
															"    {\r",
															"      \"prtry\":\"TAZAMA_EID\"\r",
															"    }\r",
															"  },\r",
															"  \"forceCret\":true,\r",
															"  \"usr\":\"POSTMAN\"\r",
															"}\r",
															"\r",
															"// Set up body variables\r",
															"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
															"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
														],
														"type": "text/javascript",
														"packages": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{{messageBody}}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
													"host": [
														"{{tazamaAdminUrl}}{{path-admin-api-version}}"
													],
													"path": [
														"{{path-entity-condition}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 4 - Post pacs.008 to TMS API",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
															"\r",
															"let dbtrId = pm.globals.get('debtorId');\r",
															"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
															"let cdtrId = pm.globals.get('creditorId');\r",
															"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
															"\r",
															"// Hacky workaround for testing the timeout of the submission of the pacs002 after this test\r",
															"pm.globals.set('responseTimedOut', true);\r",
															"\r",
															"// ## Set up transaction eco-system\r",
															"\r",
															"messageSet = utils.createTransactionSetInMemory(\r",
															"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
															"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
															"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
															"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
															"    /* Debtor ID - null defaults random UUID ------------------------ */ dbtrId,\r",
															"    /* Debtor Account ID - null defaults random UUID ---------------- */ dbtrAcctId,\r",
															"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ 'fsp001',\r",
															"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
															"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
															"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
															"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
															"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
															"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
															"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
															"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
															"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
															"    /* Description - null defaults random UUID ---------------------- */ null,\r",
															"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
															"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
															"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
															"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
															"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
															"    );\r",
															"\r",
															"let messageBody = pm.globals.get('pacs008');\r",
															"pm.globals.set('messageBody', messageBody);"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{{messageBody}}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
													"host": [
														"{{tazamaTMSUrl}}{{path-tms-api-version}}"
													],
													"path": [
														"{{path-pacs008}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 4 - Post pacs.002 to TMS API - EXPECTED TIMEOUT",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
															"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
															"const awaitReply = true; // Hold the phone for a callback\r",
															"\r",
															"let messageBody = pm.globals.get('pacs002');\r",
															"pm.globals.set('messageBody', messageBody);\r",
															"pm.globals.set('endpoint', endpoint);\r",
															"pm.globals.set('responseDestination', responseDestination);\r",
															"pm.globals.set('awaitReply', awaitReply);\r",
															""
														],
														"type": "text/javascript",
														"packages": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"const resJson = pm.response.json();\r",
															"console.log(resJson);\r",
															"\r",
															"// Hacky workaround for testing the timeout of the submission of the pacs002\r",
															"pm.globals.set('responseTimedOut', false);\r",
															"\r",
															"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});\r",
															"\r",
															"pm.test(`No alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
															"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
															"});\r",
															"\r",
															"pm.test(`Request does not complete within specified timeout of ${pm.globals.get('timeoutLimit')}`, function () {\r",
															"    pm.expect(pm.response.responseTime).to.be.above(4000);\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
													"host": [
														"{{natsUrl}}"
													],
													"path": [
														"{{nats-path-tms-api}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 4 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
														],
														"type": "text/javascript",
														"packages": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"const resJson = pm.response.json();\r",
															"\r",
															"const rulesPerTypologyCount = [3];\r",
															"const totalExpectedTypologies = 1;\r",
															"const expectedAlertStatus = \"ALRT\";\r",
															"const expectedBlockingOutcome = \"override\";\r",
															"const expectedReviewFlag = true;\r",
															"const expectedTypologyAlert = true;\r",
															"const expectedTypologyInterdiction = true;\r",
															"const expectedResponseTimedOut = true;\r",
															"\r",
															"const interdictionTypologies = [\r",
															"  \"999\"\r",
															"];\r",
															"const ruleDescriptions = {\r",
															"  \"901\": \"Number of outgoing transactions - debtor\",\r",
															"  \"902\": \"Number of incoming transactions - creditor\",\r",
															"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
															"}\r",
															"const typologyDescriptions = {\r",
															"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
															"}\r",
															"\r",
															"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
															"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
															"\r",
															"typologyCount = typologyResultsUnique.count();\r",
															"ruleCount = ruleResultsUnique.count();\r",
															"\r",
															"foundEFRuP = false;\r",
															"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
															"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
															"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
															"        foundEFRuP = true;\r",
															"    }\r",
															"}\r",
															"\r",
															"ruleWeightingTotal = 0;\r",
															"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
															"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
															"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
															"    }    \r",
															"}\r",
															"\r",
															"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
															"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
															"});\r",
															"\r",
															"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
															"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
															"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
															"    pm.expect(foundEFRuP).to.be.true;\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
															"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
															"});\r",
															"\r",
															"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedReviewFlag) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
															"    });\r",
															"} else {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
															"    });\r",
															"}\r",
															"\r",
															"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
															"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
															"    });\r",
															"\r",
															"pm.test(`No response received at EFRuP interdiction service before timeout`, function () {\r",
															"        pm.expect(pm.globals.get('responseTimedOut')).to.be.eql(expectedResponseTimedOut);\r",
															"    });"
														],
														"type": "text/javascript",
														"packages": {}
													}
												}
											],
											"request": {
												"auth": {
													"type": "bearer",
													"bearer": [
														{
															"key": "token",
															"value": "{{auth-token}}",
															"type": "string"
														}
													]
												},
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
													"host": [
														"{{arangoUrl}}"
													],
													"path": [
														"_db",
														"{{db_results}}",
														"_api",
														"cursor"
													]
												}
											},
											"response": []
										}
									]
								}
							]
						}
					]
				},
				{
					"name": "cdtrId - perspective=both",
					"item": [
						{
							"name": "non-overridable block",
							"item": [
								{
									"name": "Create New Entity Condition Manually - Unknown creditor entity",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"responseJSON = pm.response.json();\r",
													"let conditionResult = responseJSON.result.conditions;\r",
													"let conditionEntity = responseJSON.result.ntty;\r",
													"let requestMessage = responseJSON.message;\r",
													"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
													"let nttyId = pm.globals.get(\"cdtrNttyId\");\r",
													"let nttyIdSchme = pm.globals.get(\"cdtrNttyIdSchmeNm\");\r",
													"let tenantId = pm.globals.get(\"tenantId\");\r",
													"let targetEntityId = nttyId + nttyIdSchme;\r",
													"\r",
													"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
													"targetRequestMessage = \"New condition was saved successfully.\"\r",
													"\r",
													"pm.test(\"Status code is 200\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(\"Result message matches target result message\", function () {\r",
													"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
													"});\r",
													"\r",
													"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
													"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
													"});\r",
													"\r",
													"pm.test(\"Result conditions array only contains a single condition\", function () {\r",
													"    pm.expect(conditionResult.length).to.be.eql(1);\r",
													"});\r",
													"\r",
													"let firstElement = conditionResult[0];\r",
													"\r",
													"pm.test(\"Result condition has a non-empty condId\", function () {\r",
													"    pm.expect(firstElement.condId).to.exist.and.not.be.empty;\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.condTp).to.be.eql(targetConditionResult.condTp);\r",
													"});\r",
													"\r",
													"if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"    pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
													"        pm.expect(firstElement.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"    });\r",
													"} else {    // if not, one must have been defaulted\r",
													"    pm.test(\"Result condition has a non-empty incptnDtTm\", function () {\r",
													"        pm.expect(firstElement.incptnDtTm).to.exist.and.not.be.empty;\r",
													"    });\r",
													"}\r",
													"\r",
													"if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"    pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
													"        pm.expect(firstElement.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"    });\r",
													"} else {    // if not, one must not have been defaulted\r",
													"    pm.test(\"Result condition does not have an xprtnDtTm\", function () {\r",
													"        pm.expect(firstElement.xprtnDtTm).to.not.exist;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.usr).to.be.eql(targetConditionResult.usr);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition has a non-empty creDtTm\", function () {\r",
													"    pm.expect(firstElement.creDtTm).to.exist.and.not.be.empty;\r",
													"});\r",
													"\r",
													"// create an array that only includes the perspective descriptions so that we can evaluate them easily\r",
													"let perspectives = firstElement.prsptvs.map(({ prsptv }) => prsptv);\r",
													"\r",
													"if (targetConditionResult.prsptv === \"both\") {\r",
													"    pm.test(\"Result prsptv array contains only 2 perspectives\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(2);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_creditor_by\", \"governed_as_debtor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains both ${JSON.stringify(targetPerspectives)} perspectives`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"} else if (targetConditionResult.prsptv === \"debtor\") {\r",
													"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_debtor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"} else if (targetConditionResult.prsptv === \"creditor\") {\r",
													"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_creditor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"};\r",
													"\r",
													"for (let i = 0; i < firstElement.prsptvs.length; i++) {   // for each perspective\r",
													"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} contains a non-empty evtTp array`, function () {\r",
													"        pm.expect(firstElement.prsptvs[i].evtTp).to.be.an('array').and.not.be.empty;\r",
													"    });\r",
													"\r",
													"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} evtTp array matches submitted condition`, function () {\r",
													"        pm.expect(firstElement.prsptvs[i].evtTp).to.include.members(targetConditionResult.evtTp);\r",
													"    });\r",
													"\r",
													"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches submitted condition`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must have been defaulted\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches created condition incptDtTm`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.eql(firstElement.incptnDtTm);\r",
													"        });\r",
													"    }\r",
													"\r",
													"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} xprtnDtTm matches submitted condition`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must not have been defaulted\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} does not have an xprtnDtTm`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.not.exist;\r",
													"        });\r",
													"    }\r",
													"\r",
													"}\r",
													"\r",
													"pm.test(\"Result condition ntty.id matches submitted condition\", function () {\r",
													"    pm.expect(conditionEntity.id).to.be.eql(targetConditionResult.ntty.id);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"    pm.expect(conditionEntity.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
													"});\r",
													"\r",
													"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetEntityId, false);;\r",
													"\r",
													"await pm.sendRequest(postRequest, (error, response) => {\r",
													"    if (utils.getLogLevel() === 'DEBUG') {\r",
													"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
													"    }\r",
													"    databaseConditionResult = response.json().data;\r",
													"\r",
													"    if (utils.getLogLevel() === 'DEBUG') {\r",
													"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
													"    }\r",
													"\r",
													"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
													"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
													"\r",
													"    pm.test(`Only one condition for entity [${targetEntityId}] exists in the database`, function () {\r",
													"        pm.expect(graphConditionList.length).to.eql(1);\r",
													"    });\r",
													"\r",
													"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
													"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
													"            pm.expect(conditionGraph.v[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
													"        });\r",
													"    }\r",
													"\r",
													"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
													"    });\r",
													"\r",
													"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"        pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
													"            pm.expect(conditionGraph.v[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must have been defaulted\r",
													"        pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
													"            pm.expect(conditionGraph.v[0].incptnDtTm).to.exist.and.not.be.empty;\r",
													"        });\r",
													"    }\r",
													"\r",
													"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"        pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
													"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must not have been defaulted\r",
													"        pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
													"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.not.exist;\r",
													"        });\r",
													"    }\r",
													"\r",
													"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].ntty.id).to.be.eql(targetConditionResult.ntty.id);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].ntty.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].usr).to.be.eql(targetConditionResult.usr);\r",
													"    });\r",
													"\r",
													"    let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, conditionGraph.v[0]._key);\r",
													"\r",
													"    pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
													"        pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database 'governed_as_creditor_by' edge exists\", function () {\r",
													"        pm.expect(edgeList).to.include.members([\"governed_as_creditor_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
													"    });\r",
													"\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"// Obliterate the current contents of the global variables\r",
													"pm.globals.clear();\r",
													"\r",
													"// Set up the transaction (in memory)\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ 3600000,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"\r",
													"// Retrieve the created pacs.008 message\r",
													"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
													"\r",
													"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
													"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
													"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
													"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
													"\r",
													"// Load deconstructued identifier variables into global variables\r",
													"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
													"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
													"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
													"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
													"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
													"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
													"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
													"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
													"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
													"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
													"pm.globals.set(\"tenantId\", submittedPacs008Message.TenantId);\r",
													"\r",
													"// Set up the condition\r",
													"\r",
													"messageBody = {\r",
													"  \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09\",\"pacs.008.001.10\",\"pacs.002.001.12\"],\r",
													"  \"condTp\":\"non-overridable-block\",\r",
													"  \"prsptv\":\"both\",\r",
													"  \"condRsn\":\"Default Test Condition\",\r",
													"  \"ntty\":\r",
													"  {\r",
													"    \"id\": `${cdtrNttyId.id}`,\r",
													"    \"schmeNm\":\r",
													"    {\r",
													"      \"prtry\":\"TAZAMA_EID\"\r",
													"    }\r",
													"  },\r",
													"  \"forceCret\":true,\r",
													"  \"usr\":\"POSTMAN\"\r",
													"}\r",
													"\r",
													"// Set up body variables\r",
													"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
													"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
											"host": [
												"{{tazamaAdminUrl}}{{path-admin-api-version}}"
											],
											"path": [
												"{{path-entity-condition}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('dbtrNttyId');\r",
													"let dbtrAcctId = pm.globals.get('dbtrAcctId');\r",
													"let cdtrId = pm.globals.get('cdtrNttyId');\r",
													"let cdtrAcctId = pm.globals.get('cdtrAcctId');\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ cdtrId,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ cdtrAcctId,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ 'fsp001',\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Post pacs.002 to TMS API - NO TIMEOUT EXPECTED",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`Alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"ALRT\";\r",
													"const expectedBlockingOutcome = \"block\";\r",
													"const expectedReviewFlag = true;\r",
													"const expectedTypologyAlert = false;\r",
													"const expectedTypologyInterdiction = false;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('dbtrNttyId');\r",
													"let dbtrAcctId = pm.globals.get('dbtrAcctId');\r",
													"let cdtrId = pm.globals.get('cdtrNttyId');\r",
													"let cdtrAcctId = pm.globals.get('cdtrAcctId');\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ cdtrId,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ cdtrAcctId,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ 'fsp001',\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Post pacs.002 to TMS API - NO TIMEOUT EXPECTED",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`Alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"ALRT\";\r",
													"const expectedBlockingOutcome = \"block\";\r",
													"const expectedReviewFlag = true;\r",
													"const expectedTypologyAlert = true;\r",
													"const expectedTypologyInterdiction = false;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Post pacs.002 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`Alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"ALRT\";\r",
													"const expectedBlockingOutcome = \"block\";\r",
													"const expectedReviewFlag = true;\r",
													"const expectedTypologyAlert = true;\r",
													"const expectedTypologyInterdiction = true;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('dbtrNttyId');\r",
													"let dbtrAcctId = pm.globals.get('dbtrAcctId');\r",
													"let cdtrId = pm.globals.get('cdtrNttyId');\r",
													"let cdtrAcctId = pm.globals.get('cdtrAcctId');\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ cdtrId,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ cdtrAcctId,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ 'fsp001',\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Post pacs.002 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`Alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"ALRT\";\r",
													"const expectedBlockingOutcome = \"block\";\r",
													"const expectedReviewFlag = true;\r",
													"const expectedTypologyAlert = true;\r",
													"const expectedTypologyInterdiction = true;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "overridable block",
							"item": [
								{
									"name": "Create New Entity Condition Manually - Unknown debtor entity",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"responseJSON = pm.response.json();\r",
													"let conditionResult = responseJSON.result.conditions;\r",
													"let conditionEntity = responseJSON.result.ntty;\r",
													"let requestMessage = responseJSON.message;\r",
													"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
													"let nttyId = pm.globals.get(\"cdtrNttyId\");\r",
													"let nttyIdSchme = pm.globals.get(\"cdtrNttyIdSchmeNm\");\r",
													"let tenantId = pm.globals.get(\"tenantId\");\r",
													"let targetEntityId = nttyId + nttyIdSchme;\r",
													"\r",
													"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
													"targetRequestMessage = \"New condition was saved successfully.\"\r",
													"\r",
													"pm.test(\"Status code is 200\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(\"Result message matches target result message\", function () {\r",
													"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
													"});\r",
													"\r",
													"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
													"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
													"});\r",
													"\r",
													"pm.test(\"Result conditions array only contains a single condition\", function () {\r",
													"    pm.expect(conditionResult.length).to.be.eql(1);\r",
													"});\r",
													"\r",
													"let firstElement = conditionResult[0];\r",
													"\r",
													"pm.test(\"Result condition has a non-empty condId\", function () {\r",
													"    pm.expect(firstElement.condId).to.exist.and.not.be.empty;\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.condTp).to.be.eql(targetConditionResult.condTp);\r",
													"});\r",
													"\r",
													"if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"    pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
													"        pm.expect(firstElement.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"    });\r",
													"} else {    // if not, one must have been defaulted\r",
													"    pm.test(\"Result condition has a non-empty incptnDtTm\", function () {\r",
													"        pm.expect(firstElement.incptnDtTm).to.exist.and.not.be.empty;\r",
													"    });\r",
													"}\r",
													"\r",
													"if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"    pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
													"        pm.expect(firstElement.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"    });\r",
													"} else {    // if not, one must not have been defaulted\r",
													"    pm.test(\"Result condition does not have an xprtnDtTm\", function () {\r",
													"        pm.expect(firstElement.xprtnDtTm).to.not.exist;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.usr).to.be.eql(targetConditionResult.usr);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition has a non-empty creDtTm\", function () {\r",
													"    pm.expect(firstElement.creDtTm).to.exist.and.not.be.empty;\r",
													"});\r",
													"\r",
													"// create an array that only includes the perspective descriptions so that we can evaluate them easily\r",
													"let perspectives = firstElement.prsptvs.map(({ prsptv }) => prsptv);\r",
													"\r",
													"if (targetConditionResult.prsptv === \"both\") {\r",
													"    pm.test(\"Result prsptv array contains only 2 perspectives\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(2);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_creditor_by\", \"governed_as_debtor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains both ${JSON.stringify(targetPerspectives)} perspectives`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"} else if (targetConditionResult.prsptv === \"debtor\") {\r",
													"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_debtor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"} else if (targetConditionResult.prsptv === \"creditor\") {\r",
													"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_creditor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"};\r",
													"\r",
													"for (let i = 0; i < firstElement.prsptvs.length; i++) {   // for each perspective\r",
													"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} contains a non-empty evtTp array`, function () {\r",
													"        pm.expect(firstElement.prsptvs[i].evtTp).to.be.an('array').and.not.be.empty;\r",
													"    });\r",
													"\r",
													"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} evtTp array matches submitted condition`, function () {\r",
													"        pm.expect(firstElement.prsptvs[i].evtTp).to.include.members(targetConditionResult.evtTp);\r",
													"    });\r",
													"\r",
													"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches submitted condition`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must have been defaulted\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches created condition incptDtTm`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.eql(firstElement.incptnDtTm);\r",
													"        });\r",
													"    }\r",
													"\r",
													"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} xprtnDtTm matches submitted condition`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must not have been defaulted\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} does not have an xprtnDtTm`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.not.exist;\r",
													"        });\r",
													"    }\r",
													"\r",
													"}\r",
													"\r",
													"pm.test(\"Result condition ntty.id matches submitted condition\", function () {\r",
													"    pm.expect(conditionEntity.id).to.be.eql(targetConditionResult.ntty.id);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"    pm.expect(conditionEntity.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
													"});\r",
													"\r",
													"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetEntityId, false);;\r",
													"\r",
													"await pm.sendRequest(postRequest, (error, response) => {\r",
													"    if (utils.getLogLevel() === 'DEBUG') {\r",
													"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
													"    }\r",
													"    databaseConditionResult = response.json().data;\r",
													"\r",
													"    if (utils.getLogLevel() === 'DEBUG') {\r",
													"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
													"    }\r",
													"\r",
													"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
													"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
													"\r",
													"    pm.test(`Only one condition for entity [${targetEntityId}] exists in the database`, function () {\r",
													"        pm.expect(graphConditionList.length).to.eql(1);\r",
													"    });\r",
													"\r",
													"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
													"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
													"            pm.expect(conditionGraph.v[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
													"        });\r",
													"    }\r",
													"\r",
													"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
													"    });\r",
													"\r",
													"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"        pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
													"            pm.expect(conditionGraph.v[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must have been defaulted\r",
													"        pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
													"            pm.expect(conditionGraph.v[0].incptnDtTm).to.exist.and.not.be.empty;\r",
													"        });\r",
													"    }\r",
													"\r",
													"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"        pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
													"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must not have been defaulted\r",
													"        pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
													"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.not.exist;\r",
													"        });\r",
													"    }\r",
													"\r",
													"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].ntty.id).to.be.eql(targetConditionResult.ntty.id);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].ntty.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].usr).to.be.eql(targetConditionResult.usr);\r",
													"    });\r",
													"\r",
													"    let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, conditionGraph.v[0]._key);\r",
													"\r",
													"    pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
													"        pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database 'governed_as_creditor_by' edge exists\", function () {\r",
													"        pm.expect(edgeList).to.include.members([\"governed_as_creditor_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
													"    });\r",
													"\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"// Obliterate the current contents of the global variables\r",
													"pm.globals.clear();\r",
													"\r",
													"// Set up the transaction (in memory)\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ 3600000,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"\r",
													"// Retrieve the created pacs.008 message\r",
													"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
													"\r",
													"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
													"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
													"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
													"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
													"\r",
													"// Load deconstructued identifier variables into global variables\r",
													"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
													"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
													"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
													"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
													"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
													"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
													"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
													"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
													"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
													"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
													"\r",
													"// Set up the condition\r",
													"\r",
													"messageBody = {\r",
													"  \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09\",\"pacs.008.001.10\",\"pacs.002.001.12\"],\r",
													"  \"condTp\":\"overridable-block\",\r",
													"  \"prsptv\":\"both\",\r",
													"  \"condRsn\":\"Default Test Condition\",\r",
													"  \"ntty\":\r",
													"  {\r",
													"    \"id\": `${cdtrNttyId.id}`,\r",
													"    \"schmeNm\":\r",
													"    {\r",
													"      \"prtry\":\"TAZAMA_EID\"\r",
													"    }\r",
													"  },\r",
													"  \"forceCret\":true,\r",
													"  \"usr\":\"POSTMAN\"\r",
													"}\r",
													"\r",
													"// Set up body variables\r",
													"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
													"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
											"host": [
												"{{tazamaAdminUrl}}{{path-admin-api-version}}"
											],
											"path": [
												"{{path-entity-condition}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('debtorId');\r",
													"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
													"let cdtrId = pm.globals.get('creditorId');\r",
													"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ cdtrId,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ cdtrAcctId,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ 'fsp001',\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Post pacs.002 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`Alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"ALRT\";\r",
													"const expectedBlockingOutcome = \"block\";\r",
													"const expectedReviewFlag = true;\r",
													"const expectedTypologyAlert = false;\r",
													"const expectedTypologyInterdiction = false;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('debtorId');\r",
													"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
													"let cdtrId = pm.globals.get('creditorId');\r",
													"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ cdtrId,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ cdtrAcctId,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ 'fsp001',\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Post pacs.002 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`Alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"ALRT\";\r",
													"const expectedBlockingOutcome = \"block\";\r",
													"const expectedReviewFlag = true;\r",
													"const expectedTypologyAlert = true;\r",
													"const expectedTypologyInterdiction = false;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('debtorId');\r",
													"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
													"let cdtrId = pm.globals.get('creditorId');\r",
													"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ cdtrId,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ cdtrAcctId,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ 'fsp001',\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Post pacs.002 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`Alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"ALRT\";\r",
													"const expectedBlockingOutcome = \"block\";\r",
													"const expectedReviewFlag = true;\r",
													"const expectedTypologyAlert = true;\r",
													"const expectedTypologyInterdiction = true;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "overridable block with override",
							"item": [
								{
									"name": "Create New Entity Condition Manually - Unknown debtor entity",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"responseJSON = pm.response.json();\r",
													"let conditionResult = responseJSON.result.conditions;\r",
													"let conditionEntity = responseJSON.result.ntty;\r",
													"let requestMessage = responseJSON.message;\r",
													"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
													"let nttyId = pm.globals.get(\"cdtrNttyId\");\r",
													"let nttyIdSchme = pm.globals.get(\"cdtrNttyIdSchmeNm\");\r",
													"let tenantId = pm.globals.get(\"tenantId\");\r",
													"let targetEntityId = nttyId + nttyIdSchme;\r",
													"\r",
													"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
													"targetRequestMessage = \"New condition was saved successfully.\"\r",
													"\r",
													"pm.test(\"Status code is 200\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(\"Result message matches target result message\", function () {\r",
													"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
													"});\r",
													"\r",
													"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
													"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
													"});\r",
													"\r",
													"pm.test(\"Result conditions array only contains a single condition\", function () {\r",
													"    pm.expect(conditionResult.length).to.be.eql(1);\r",
													"});\r",
													"\r",
													"let firstElement = conditionResult[0];\r",
													"\r",
													"pm.test(\"Result condition has a non-empty condId\", function () {\r",
													"    pm.expect(firstElement.condId).to.exist.and.not.be.empty;\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.condTp).to.be.eql(targetConditionResult.condTp);\r",
													"});\r",
													"\r",
													"if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"    pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
													"        pm.expect(firstElement.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"    });\r",
													"} else {    // if not, one must have been defaulted\r",
													"    pm.test(\"Result condition has a non-empty incptnDtTm\", function () {\r",
													"        pm.expect(firstElement.incptnDtTm).to.exist.and.not.be.empty;\r",
													"    });\r",
													"}\r",
													"\r",
													"if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"    pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
													"        pm.expect(firstElement.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"    });\r",
													"} else {    // if not, one must not have been defaulted\r",
													"    pm.test(\"Result condition does not have an xprtnDtTm\", function () {\r",
													"        pm.expect(firstElement.xprtnDtTm).to.not.exist;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.usr).to.be.eql(targetConditionResult.usr);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition has a non-empty creDtTm\", function () {\r",
													"    pm.expect(firstElement.creDtTm).to.exist.and.not.be.empty;\r",
													"});\r",
													"\r",
													"// create an array that only includes the perspective descriptions so that we can evaluate them easily\r",
													"let perspectives = firstElement.prsptvs.map(({ prsptv }) => prsptv);\r",
													"\r",
													"if (targetConditionResult.prsptv === \"both\") {\r",
													"    pm.test(\"Result prsptv array contains only 2 perspectives\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(2);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_creditor_by\", \"governed_as_debtor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains both ${JSON.stringify(targetPerspectives)} perspectives`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"} else if (targetConditionResult.prsptv === \"debtor\") {\r",
													"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_debtor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"} else if (targetConditionResult.prsptv === \"creditor\") {\r",
													"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_creditor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"};\r",
													"\r",
													"for (let i = 0; i < firstElement.prsptvs.length; i++) {   // for each perspective\r",
													"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} contains a non-empty evtTp array`, function () {\r",
													"        pm.expect(firstElement.prsptvs[i].evtTp).to.be.an('array').and.not.be.empty;\r",
													"    });\r",
													"\r",
													"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} evtTp array matches submitted condition`, function () {\r",
													"        pm.expect(firstElement.prsptvs[i].evtTp).to.include.members(targetConditionResult.evtTp);\r",
													"    });\r",
													"\r",
													"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches submitted condition`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must have been defaulted\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches created condition incptDtTm`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.eql(firstElement.incptnDtTm);\r",
													"        });\r",
													"    }\r",
													"\r",
													"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} xprtnDtTm matches submitted condition`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must not have been defaulted\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} does not have an xprtnDtTm`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.not.exist;\r",
													"        });\r",
													"    }\r",
													"\r",
													"}\r",
													"\r",
													"pm.test(\"Result condition ntty.id matches submitted condition\", function () {\r",
													"    pm.expect(conditionEntity.id).to.be.eql(targetConditionResult.ntty.id);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"    pm.expect(conditionEntity.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
													"});\r",
													"\r",
													"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetEntityId, false);;\r",
													"\r",
													"await pm.sendRequest(postRequest, (error, response) => {\r",
													"    if (utils.getLogLevel() === 'DEBUG') {\r",
													"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
													"    }\r",
													"    databaseConditionResult = response.json().data;\r",
													"\r",
													"    if (utils.getLogLevel() === 'DEBUG') {\r",
													"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
													"    }\r",
													"\r",
													"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
													"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
													"\r",
													"    pm.test(`Only one condition for entity [${targetEntityId}] exists in the database`, function () {\r",
													"        pm.expect(graphConditionList.length).to.eql(1);\r",
													"    });\r",
													"\r",
													"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
													"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
													"            pm.expect(conditionGraph.v[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
													"        });\r",
													"    }\r",
													"\r",
													"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
													"    });\r",
													"\r",
													"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"        pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
													"            pm.expect(conditionGraph.v[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must have been defaulted\r",
													"        pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
													"            pm.expect(conditionGraph.v[0].incptnDtTm).to.exist.and.not.be.empty;\r",
													"        });\r",
													"    }\r",
													"\r",
													"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"        pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
													"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must not have been defaulted\r",
													"        pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
													"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.not.exist;\r",
													"        });\r",
													"    }\r",
													"\r",
													"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].ntty.id).to.be.eql(targetConditionResult.ntty.id);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].ntty.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].usr).to.be.eql(targetConditionResult.usr);\r",
													"    });\r",
													"\r",
													"    let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, conditionGraph.v[0]._key);\r",
													"\r",
													"    pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
													"        pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database 'governed_as_creditor_by' edge exists\", function () {\r",
													"        pm.expect(edgeList).to.include.members([\"governed_as_creditor_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
													"    });\r",
													"\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"// Obliterate the current contents of the global variables\r",
													"pm.globals.clear();\r",
													"\r",
													"// Set up the transaction (in memory)\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ 3600000,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"\r",
													"// Retrieve the created pacs.008 message\r",
													"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
													"\r",
													"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
													"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
													"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
													"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
													"\r",
													"// Load deconstructued identifier variables into global variables\r",
													"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
													"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
													"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
													"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
													"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
													"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
													"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
													"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
													"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
													"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
													"\r",
													"// Set up the condition\r",
													"\r",
													"console.log(`Overridable block incepts at ${utils.getTimestampNow()}`);\r",
													"\r",
													"messageBody = {\r",
													"  \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09\",\"pacs.008.001.10\",\"pacs.002.001.12\"],\r",
													"  \"condTp\":\"overridable-block\",\r",
													"  \"prsptv\":\"both\",\r",
													"  \"condRsn\":\"Default Test Condition\",\r",
													"  \"ntty\":\r",
													"  {\r",
													"    \"id\": `${cdtrNttyId.id}`,\r",
													"    \"schmeNm\":\r",
													"    {\r",
													"      \"prtry\":\"TAZAMA_EID\"\r",
													"    }\r",
													"  },\r",
													"  \"forceCret\":true,\r",
													"  \"usr\":\"POSTMAN\"\r",
													"}\r",
													"\r",
													"// Set up body variables\r",
													"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
													"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
											"host": [
												"{{tazamaAdminUrl}}{{path-admin-api-version}}"
											],
											"path": [
												"{{path-entity-condition}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Create New Entity Condition Manually - set override",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"responseJSON = pm.response.json();\r",
													"let conditionResult = responseJSON.result.conditions;\r",
													"let conditionEntity = responseJSON.result.ntty;\r",
													"let requestMessage = responseJSON.message;\r",
													"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
													"let nttyId = pm.globals.get(\"cdtrNttyId\");\r",
													"let nttyIdSchme = pm.globals.get(\"cdtrNttyIdSchmeNm\");\r",
													"let tenantId = pm.globals.get(\"tenantId\");\r",
													"let targetEntityId = nttyId + nttyIdSchme;\r",
													"\r",
													"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
													"targetRequestMessage = \"1 conditions already exist for the entity\"\r",
													"\r",
													"pm.test(\"Status code is 200\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(\"Result message matches target result message\", function () {\r",
													"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
													"});\r",
													"\r",
													"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
													"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
													"});\r",
													"\r",
													"pm.test(\"Result conditions array contains two conditions\", function () {\r",
													"    pm.expect(conditionResult.length).to.be.eql(2);\r",
													"});\r",
													"\r",
													"let newElement = conditionResult[conditionResult.length - 1];  // the last element is the newly submitted condition\r",
													"\r",
													"pm.test(\"Result condition has a non-empty condId\", function () {\r",
													"    pm.expect(newElement.condId).to.exist.and.not.be.empty;\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
													"    pm.expect(newElement.condTp).to.be.eql(targetConditionResult.condTp);\r",
													"});\r",
													"\r",
													"if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"    pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
													"        pm.expect(newElement.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"    });\r",
													"} else {    // if not, one must have been defaulted\r",
													"    pm.test(\"Result condition has a non-empty incptnDtTm\", function () {\r",
													"        pm.expect(newElement.incptnDtTm).to.exist.and.not.be.empty;\r",
													"    });\r",
													"}\r",
													"\r",
													"if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"    pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
													"        pm.expect(newElement.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"    });\r",
													"} else {    // if not, one must not have been defaulted\r",
													"    pm.test(\"Result condition does not have an xprtnDtTm\", function () {\r",
													"        pm.expect(newElement.xprtnDtTm).to.not.exist;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
													"    pm.expect(newElement.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
													"    pm.expect(newElement.usr).to.be.eql(targetConditionResult.usr);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition has a non-empty creDtTm\", function () {\r",
													"    pm.expect(newElement.creDtTm).to.exist.and.not.be.empty;\r",
													"});\r",
													"\r",
													"// create an array that only includes the perspective descriptions so that we can evaluate them easily\r",
													"let perspectives = newElement.prsptvs.map(({ prsptv }) => prsptv);\r",
													"\r",
													"if (targetConditionResult.prsptv === \"both\") {\r",
													"    pm.test(\"Result prsptv array contains only 2 perspectives\", function () {\r",
													"        pm.expect(newElement.prsptvs.length).to.be.eql(2);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_creditor_by\", \"governed_as_debtor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains both ${JSON.stringify(targetPerspectives)} perspectives`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"} else if (targetConditionResult.prsptv === \"debtor\") {\r",
													"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
													"        pm.expect(newElement.prsptvs.length).to.be.eql(1);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_debtor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"} else if (targetConditionResult.prsptv === \"creditor\") {\r",
													"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
													"        pm.expect(newElement.prsptvs.length).to.be.eql(1);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_creditor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"};\r",
													"\r",
													"for (let i = 0; i < newElement.prsptvs.length; i++) {   // for each perspective\r",
													"    pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} contains a non-empty evtTp array`, function () {\r",
													"        pm.expect(newElement.prsptvs[i].evtTp).to.be.an('array').and.not.be.empty;\r",
													"    });\r",
													"\r",
													"    pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} evtTp array matches submitted condition`, function () {\r",
													"        pm.expect(newElement.prsptvs[i].evtTp).to.include.members(targetConditionResult.evtTp);\r",
													"    });\r",
													"\r",
													"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"        pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} incptnDtTm matches submitted condition`, function () {\r",
													"            pm.expect(newElement.prsptvs[i].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must have been defaulted\r",
													"        pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} incptnDtTm matches created condition incptDtTm`, function () {\r",
													"            pm.expect(newElement.prsptvs[i].incptnDtTm).to.eql(newElement.incptnDtTm);\r",
													"        });\r",
													"    }\r",
													"\r",
													"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"        pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} xprtnDtTm matches submitted condition`, function () {\r",
													"            pm.expect(newElement.prsptvs[i].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must not have been defaulted\r",
													"        pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} does not have an xprtnDtTm`, function () {\r",
													"            pm.expect(newElement.prsptvs[i].xprtnDtTm).to.not.exist;\r",
													"        });\r",
													"    }\r",
													"\r",
													"}\r",
													"\r",
													"pm.test(\"Result condition ntty.id matches submitted condition\", function () {\r",
													"    pm.expect(conditionEntity.id).to.be.eql(targetConditionResult.ntty.id);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"    pm.expect(conditionEntity.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
													"});\r",
													"\r",
													"// Now we want to test that the data in the database matches the submitted data AND the response data\r",
													"\r",
													"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetEntityId, false);;\r",
													"\r",
													"await pm.sendRequest(postRequest, (error, response) => {\r",
													"    if (utils.getLogLevel() === 'DEBUG') {\r",
													"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
													"    }\r",
													"    databaseConditionResult = response.json().data;\r",
													"\r",
													"    if (utils.getLogLevel() === 'DEBUG') {\r",
													"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
													"    }\r",
													"\r",
													"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
													"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
													"\r",
													"    let submittedCondition = graphConditionList.filter(condition => condition._id === `conditions/${newElement.condId}`);\r",
													"\r",
													"    // First we check that the submitted condition matches the database version\r",
													"\r",
													"    pm.test(`Only two conditions for entity [${targetEntityId}] exists in the database`, function () {\r",
													"        pm.expect(graphConditionList.length).to.eql(2);\r",
													"    });\r",
													"\r",
													"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
													"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
													"            pm.expect(submittedCondition[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
													"        });\r",
													"    }\r",
													"\r",
													"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
													"        pm.expect(submittedCondition[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
													"        pm.expect(submittedCondition[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
													"    });\r",
													"\r",
													"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"        pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
													"            pm.expect(submittedCondition[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must have been defaulted\r",
													"        pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
													"            pm.expect(submittedCondition[0].incptnDtTm).to.exist.and.not.be.empty;\r",
													"        });\r",
													"    }\r",
													"\r",
													"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"        pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
													"            pm.expect(submittedCondition[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must not have been defaulted\r",
													"        pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
													"            pm.expect(submittedCondition[0].xprtnDtTm).to.not.exist;\r",
													"        });\r",
													"    }\r",
													"\r",
													"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
													"        pm.expect(submittedCondition[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
													"        pm.expect(submittedCondition[0].ntty.id).to.be.eql(targetConditionResult.ntty.id);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"        pm.expect(submittedCondition[0].ntty.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
													"        pm.expect(submittedCondition[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
													"        pm.expect(submittedCondition[0].usr).to.be.eql(targetConditionResult.usr);\r",
													"    });\r",
													"\r",
													"    let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, submittedCondition[0]._key);\r",
													"\r",
													"    pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
													"        pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database 'governed_as_creditor_by' edge exists\", function () {\r",
													"        pm.expect(edgeList).to.include.members([\"governed_as_creditor_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
													"    });\r",
													"\r",
													"    // Then we check the previous conditions in the response one-by-one against the database version\r",
													"    let previousConditionsFromResponse = graphConditionList.filter(condition => condition._id != `conditions/${newElement.condId}`);\r",
													"    let previousResponseConditionIds = previousConditionsFromResponse.map(({ condId }) => condId);\r",
													"    let previousConditionsFromDatabase = graphConditionList.filter(condition => condition._id != `conditions/${newElement.condId}`);\r",
													"    let previousDatabaseConditionIds = previousConditionsFromDatabase.map(({ condId }) => condId);\r",
													"\r",
													"    pm.test(`List of previous conditions in response match list of conditions from database`, function () {\r",
													"        pm.expect(previousResponseConditionIds).to.have.members(previousDatabaseConditionIds);\r",
													"    });\r",
													"\r",
													"    pm.test(`Only one previous condition for entity [${targetEntityId}] exists in the reponse`, function () {\r",
													"        pm.expect(previousConditionsFromResponse.length).to.eql(1);\r",
													"    });\r",
													"\r",
													"    pm.test(`Only one previous condition for entity [${targetEntityId}] exists in the database`, function () {\r",
													"        pm.expect(previousConditionsFromDatabase.length).to.eql(1);\r",
													"    });\r",
													"\r",
													"    for (let j = 0; j < previousConditionsFromResponse.length; j++) {\r",
													"\r",
													"        let justOneConditionFromResponse = previousConditionsFromResponse.filter(condition => condition._id === `conditions/${conditionResult[j].condId}`);\r",
													"        let sameConditionFromDatabase = previousConditionsFromDatabase.filter(condition => condition._id === `conditions/${conditionResult[j].condId}`);\r",
													"\r",
													"        for (let i = 0; i < sameConditionFromDatabase[0].evtTp.length; i++) {\r",
													"            pm.test(`Database condition.evtTp contains ${sameConditionFromDatabase[0].evtTp[i]}`, function () {\r",
													"                pm.expect(justOneConditionFromResponse[0].evtTp).to.include.members([sameConditionFromDatabase[0].evtTp[i]]);\r",
													"            });\r",
													"        }\r",
													"\r",
													"        pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
													"            pm.expect(justOneConditionFromResponse[0].condTp).to.be.eql(sameConditionFromDatabase[0].condTp);\r",
													"        });\r",
													"\r",
													"        pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
													"            pm.expect(justOneConditionFromResponse[0].prsptv).to.be.eql(sameConditionFromDatabase[0].prsptv);\r",
													"        });\r",
													"\r",
													"        if (sameConditionFromDatabase[0].incptnDtTm) { // was an inception date specified?\r",
													"            pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
													"                pm.expect(justOneConditionFromResponse[0].incptnDtTm).to.be.eql(sameConditionFromDatabase[0].incptnDtTm);\r",
													"            });\r",
													"        } else {    // if not, one must have been defaulted\r",
													"            pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
													"                pm.expect(justOneConditionFromResponse[0].incptnDtTm).to.exist.and.not.be.empty;\r",
													"            });\r",
													"        }\r",
													"\r",
													"        if (sameConditionFromDatabase[0].xprtnDtTm) { // was an expiration date specified?\r",
													"            pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
													"                pm.expect(justOneConditionFromResponse[0].xprtnDtTm).to.be.eql(sameConditionFromDatabase[0].xprtnDtTm);\r",
													"            });\r",
													"        } else {    // if not, one must not have been defaulted\r",
													"            pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
													"                pm.expect(justOneConditionFromResponse[0].xprtnDtTm).to.not.exist;\r",
													"            });\r",
													"        }\r",
													"\r",
													"        pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
													"            pm.expect(justOneConditionFromResponse[0].condRsn).to.be.eql(sameConditionFromDatabase[0].condRsn);\r",
													"        });\r",
													"\r",
													"        pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
													"            pm.expect(justOneConditionFromResponse[0].ntty.id).to.be.eql(sameConditionFromDatabase[0].ntty.id);\r",
													"        });\r",
													"\r",
													"        pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"            pm.expect(justOneConditionFromResponse[0].ntty.schmeNm.prtry).to.be.eql(sameConditionFromDatabase[0].ntty.schmeNm.prtry);\r",
													"        });\r",
													"\r",
													"        pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
													"            pm.expect(justOneConditionFromResponse[0].forceCret).to.be.eql(sameConditionFromDatabase[0].forceCret);\r",
													"        });\r",
													"\r",
													"        pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
													"            pm.expect(justOneConditionFromResponse[0].usr).to.be.eql(sameConditionFromDatabase[0].usr);\r",
													"        });\r",
													"\r",
													"        let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, justOneConditionFromResponse[0]._key);\r",
													"\r",
													"        pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
													"            pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
													"        });\r",
													"\r",
													"        pm.test(\"Database 'governed_as_creditor_by' edge exists\", function () {\r",
													"            pm.expect(edgeList).to.include.members([\"governed_as_creditor_by\"]);\r",
													"        });\r",
													"\r",
													"        pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
													"            pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
													"        });\r",
													"\r",
													"        pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
													"            pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
													"        });\r",
													"    }\r",
													"\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"// Retrieve the created pacs.008 message\r",
													"const submittedPacs008Message = utils.addTenantId(null, JSON.parse(pm.globals.get(\"pacs008\")));\r",
													"\r",
													"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
													"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
													"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
													"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
													"\r",
													"// Load deconstructued identifier variables into global variables\r",
													"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
													"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
													"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
													"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
													"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
													"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
													"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
													"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
													"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
													"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
													"\r",
													"xprtnDtTm = utils.timestampAtTMinus(-10, \"m\");\r",
													"\r",
													"// Set up the condition\r",
													"\r",
													"console.log(`Override incepts at ${utils.getTimestampNow()}`);\r",
													"\r",
													"messageBody = {\r",
													"  \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09\",\"pacs.008.001.10\",\"pacs.002.001.12\"],\r",
													"  \"condTp\":\"override\",\r",
													"  \"prsptv\":\"both\",\r",
													"  \"xprtnDtTm\": xprtnDtTm,\r",
													"  \"condRsn\":\"Default Test Condition\",\r",
													"  \"ntty\":\r",
													"  {\r",
													"    \"id\": `${cdtrNttyId.id}`,\r",
													"    \"schmeNm\":\r",
													"    {\r",
													"      \"prtry\":\"TAZAMA_EID\"\r",
													"    }\r",
													"  },\r",
													"  \"forceCret\":true,\r",
													"  \"usr\":\"POSTMAN\"\r",
													"}\r",
													"\r",
													"// Set up body variables\r",
													"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
													"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
											"host": [
												"{{tazamaAdminUrl}}{{path-admin-api-version}}"
											],
											"path": [
												"{{path-entity-condition}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('debtorId');\r",
													"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
													"let cdtrId = pm.globals.get('creditorId');\r",
													"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
													"\r",
													"// Hacky workaround for testing the timeout of the submission of the pacs002 after this test\r",
													"pm.globals.set('responseTimedOut', true);\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ cdtrId,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ cdtrAcctId,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ 'fsp001',\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Post pacs.002 to TMS API - TIMEOUT EXPECTED",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"// Hacky workaround for testing the timeout of the submission of the pacs002\r",
													"pm.globals.set('responseTimedOut', false);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`No alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													"\r",
													"pm.test(`Request does not complete within specified timeout of ${pm.globals.get('timeoutLimit')}`, function () {\r",
													"    pm.expect(pm.response.responseTime).to.be.above(4000);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"NALT\";\r",
													"const expectedBlockingOutcome = \"override\";\r",
													"const expectedReviewFlag = false;\r",
													"const expectedTypologyAlert = false;\r",
													"const expectedTypologyInterdiction = false;\r",
													"const expectedResponseTimedOut = true;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });\r",
													"\r",
													"pm.test(`No response received at EFRuP interdiction service before timeout`, function () {\r",
													"        pm.expect(pm.globals.get('responseTimedOut')).to.be.eql(expectedResponseTimedOut);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('debtorId');\r",
													"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
													"let cdtrId = pm.globals.get('creditorId');\r",
													"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
													"\r",
													"// Hacky workaround for testing the timeout of the submission of the pacs002 after this test\r",
													"pm.globals.set('responseTimedOut', true);\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ cdtrId,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ cdtrAcctId,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ 'fsp001',\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Post pacs.002 to TMS API - TIMEOUT EXPECTED",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"// Hacky workaround for testing the timeout of the submission of the pacs002\r",
													"pm.globals.set('responseTimedOut', false);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`Alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													"\r",
													"pm.test(`Request does not complete within specified timeout of ${pm.globals.get('timeoutLimit')}`, function () {\r",
													"    pm.expect(pm.response.responseTime).to.be.above(4000);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"ALRT\";\r",
													"const expectedBlockingOutcome = \"override\";\r",
													"const expectedReviewFlag = true;\r",
													"const expectedTypologyAlert = true;\r",
													"const expectedTypologyInterdiction = false;\r",
													"const expectedResponseTimedOut = true;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });\r",
													"\r",
													"pm.test(`No response received at EFRuP interdiction service before timeout`, function () {\r",
													"        pm.expect(pm.globals.get('responseTimedOut')).to.be.eql(expectedResponseTimedOut);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('debtorId');\r",
													"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
													"let cdtrId = pm.globals.get('creditorId');\r",
													"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
													"\r",
													"// Hacky workaround for testing the timeout of the submission of the pacs002 after this test\r",
													"pm.globals.set('responseTimedOut', true);\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ cdtrId,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ cdtrAcctId,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ 'fsp001',\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Post pacs.002 to TMS API - TIMEOUT EXPECTED",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"// Hacky workaround for testing the timeout of the submission of the pacs002\r",
													"pm.globals.set('responseTimedOut', false);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`No alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													"\r",
													"pm.test(`Request does not complete within specified timeout of ${pm.globals.get('timeoutLimit')}`, function () {\r",
													"    pm.expect(pm.response.responseTime).to.be.above(4000);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"ALRT\";\r",
													"const expectedBlockingOutcome = \"override\";\r",
													"const expectedReviewFlag = true;\r",
													"const expectedTypologyAlert = true;\r",
													"const expectedTypologyInterdiction = true;\r",
													"const expectedResponseTimedOut = true;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });\r",
													"\r",
													"pm.test(`No response received at EFRuP interdiction service before timeout`, function () {\r",
													"        pm.expect(pm.globals.get('responseTimedOut')).to.be.eql(expectedResponseTimedOut);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "interdiction with override",
							"item": [
								{
									"name": "Before override",
									"item": [
										{
											"name": "Transaction 1 - Post pacs.008 to TMS API",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
															"\r",
															"let dbtrId = pm.globals.get('debtorId');\r",
															"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
															"let cdtrId = pm.globals.get('creditorId');\r",
															"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
															"\r",
															"// Hacky workaround for testing the timeout of the submission of the pacs002 after this test\r",
															"pm.globals.set('responseTimedOut', true);\r",
															"\r",
															"// ## Set up transaction eco-system\r",
															"\r",
															"messageSet = utils.createTransactionSetInMemory(\r",
															"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
															"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
															"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
															"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
															"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
															"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
															"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
															"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
															"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
															"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
															"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
															"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
															"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
															"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
															"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
															"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
															"    /* Description - null defaults random UUID ---------------------- */ null,\r",
															"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
															"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
															"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
															"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
															"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
															"    );\r",
															"\r",
															"let messageBody = pm.globals.get('pacs008');\r",
															"pm.globals.set('pacs008Stash', messageBody);\r",
															"pm.globals.set('messageBody', messageBody);"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{{messageBody}}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
													"host": [
														"{{tazamaTMSUrl}}{{path-tms-api-version}}"
													],
													"path": [
														"{{path-pacs008}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 1 - Post pacs.002 to TMS API",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"let messageBody = pm.globals.get('pacs002');\r",
															"pm.globals.set('messageBody', messageBody);"
														],
														"type": "text/javascript",
														"packages": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{{pacs002}}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs002}}",
													"host": [
														"{{tazamaTMSUrl}}{{path-tms-api-version}}"
													],
													"path": [
														"{{path-pacs002}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 1 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
														],
														"type": "text/javascript",
														"packages": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"const resJson = pm.response.json();\r",
															"\r",
															"const rulesPerTypologyCount = [3];\r",
															"const totalExpectedTypologies = 1;\r",
															"const expectedAlertStatus = \"NALT\";\r",
															"const expectedBlockingOutcome = \"none\";\r",
															"const expectedReviewFlag = false;\r",
															"const expectedTypologyAlert = false;\r",
															"const expectedTypologyInterdiction = false;\r",
															"\r",
															"const interdictionTypologies = [\r",
															"  \"999\"\r",
															"];\r",
															"const ruleDescriptions = {\r",
															"  \"901\": \"Number of outgoing transactions - debtor\",\r",
															"  \"902\": \"Number of incoming transactions - creditor\",\r",
															"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
															"}\r",
															"const typologyDescriptions = {\r",
															"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
															"}\r",
															"\r",
															"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
															"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
															"\r",
															"typologyCount = typologyResultsUnique.count();\r",
															"ruleCount = ruleResultsUnique.count();\r",
															"\r",
															"foundEFRuP = false;\r",
															"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
															"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
															"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
															"        foundEFRuP = true;\r",
															"    }\r",
															"}\r",
															"\r",
															"ruleWeightingTotal = 0;\r",
															"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
															"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
															"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
															"    }    \r",
															"}\r",
															"\r",
															"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
															"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
															"});\r",
															"\r",
															"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
															"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
															"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
															"    pm.expect(foundEFRuP).to.be.true;\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
															"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
															"});\r",
															"\r",
															"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedReviewFlag) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
															"    });\r",
															"} else {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
															"    });\r",
															"}\r",
															"\r",
															"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
															"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
															"    });"
														],
														"type": "text/javascript",
														"packages": {}
													}
												}
											],
											"request": {
												"auth": {
													"type": "bearer",
													"bearer": [
														{
															"key": "token",
															"value": "{{auth-token}}",
															"type": "string"
														}
													]
												},
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
													"host": [
														"{{arangoUrl}}"
													],
													"path": [
														"_db",
														"{{db_results}}",
														"_api",
														"cursor"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 2 - Post pacs.008 to TMS API",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
															"\r",
															"let dbtrId = pm.globals.get('debtorId');\r",
															"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
															"let cdtrId = pm.globals.get('creditorId');\r",
															"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
															"\r",
															"// Hacky workaround for testing the timeout of the submission of the pacs002 after this test\r",
															"pm.globals.set('responseTimedOut', true);\r",
															"\r",
															"// ## Set up transaction eco-system\r",
															"\r",
															"messageSet = utils.createTransactionSetInMemory(\r",
															"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
															"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
															"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
															"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
															"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
															"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
															"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
															"    /* Creditor ID - null defaults random UUID ---------------------- */ cdtrId,\r",
															"    /* Creditor Account ID - null defaults random UUID -------------- */ cdtrAcctId,\r",
															"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
															"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
															"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
															"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
															"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
															"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
															"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
															"    /* Description - null defaults random UUID ---------------------- */ null,\r",
															"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
															"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
															"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
															"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
															"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
															"    );\r",
															"\r",
															"let messageBody = pm.globals.get('pacs008');\r",
															"pm.globals.set('messageBody', messageBody);"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{{messageBody}}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
													"host": [
														"{{tazamaTMSUrl}}{{path-tms-api-version}}"
													],
													"path": [
														"{{path-pacs008}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 2 - Post pacs.002 to TMS API - TIMEOUT EXPECTED",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
															"const responseDestination = `relay-service-nats-tp`; // The NATS subject for the output retrieval\r",
															"const awaitReply = true; // Hold the phone for a callback\r",
															"\r",
															"let messageBody = pm.globals.get('pacs002');\r",
															"pm.globals.set('messageBody', messageBody);\r",
															"pm.globals.set('endpoint', endpoint);\r",
															"pm.globals.set('responseDestination', responseDestination);\r",
															"pm.globals.set('awaitReply', awaitReply);"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"const resJson = pm.response.json();\r",
															"console.log(resJson);\r",
															"\r",
															"// Hacky workaround for testing the timeout of the submission of the pacs002\r",
															"pm.globals.set('responseTimedOut', false);\r",
															"\r",
															"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});\r",
															"\r",
															"pm.test(`Interdiction alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
															"    pm.expect(resJson.edResponse.report.status).to.be.eql('ALRT');\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
													"host": [
														"{{natsUrl}}"
													],
													"path": [
														"{{nats-path-tms-api}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 2 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"const resJson = pm.response.json();\r",
															"\r",
															"const rulesPerTypologyCount = [3];\r",
															"const totalExpectedTypologies = 1;\r",
															"const expectedAlertStatus = \"ALRT\";\r",
															"const expectedBlockingOutcome = \"none\";\r",
															"const expectedReviewFlag = true;\r",
															"const expectedTypologyAlert = true;\r",
															"const expectedTypologyInterdiction = false;\r",
															"const expectedResponseTimedOut = true;\r",
															"\r",
															"const interdictionTypologies = [\r",
															"  \"999\"\r",
															"];\r",
															"const ruleDescriptions = {\r",
															"  \"901\": \"Number of outgoing transactions - debtor\",\r",
															"  \"902\": \"Number of incoming transactions - creditor\",\r",
															"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
															"}\r",
															"const typologyDescriptions = {\r",
															"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
															"}\r",
															"\r",
															"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
															"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
															"\r",
															"typologyCount = typologyResultsUnique.count();\r",
															"ruleCount = ruleResultsUnique.count();\r",
															"\r",
															"foundEFRuP = false;\r",
															"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
															"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
															"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
															"        foundEFRuP = true;\r",
															"    }\r",
															"}\r",
															"\r",
															"ruleWeightingTotal = 0;\r",
															"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
															"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
															"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
															"    }    \r",
															"}\r",
															"\r",
															"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
															"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
															"});\r",
															"\r",
															"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
															"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
															"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
															"    pm.expect(foundEFRuP).to.be.true;\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
															"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
															"});\r",
															"\r",
															"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedReviewFlag) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
															"    });\r",
															"} else {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
															"    });\r",
															"}\r",
															"\r",
															"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
															"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
															"    });\r",
															"\r",
															"pm.test(`No response received at EFRuP interdiction service before timeout`, function () {\r",
															"        pm.expect(pm.globals.get('responseTimedOut')).to.be.eql(expectedResponseTimedOut);\r",
															"    });"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"auth": {
													"type": "bearer",
													"bearer": [
														{
															"key": "token",
															"value": "{{auth-token}}",
															"type": "string"
														}
													]
												},
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
													"host": [
														"{{arangoUrl}}"
													],
													"path": [
														"_db",
														"{{db_results}}",
														"_api",
														"cursor"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 3 - Post pacs.008 to TMS API",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
															"\r",
															"let dbtrId = pm.globals.get('debtorId');\r",
															"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
															"let cdtrId = pm.globals.get('creditorId');\r",
															"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
															"\r",
															"// Hacky workaround for testing the timeout of the submission of the pacs002 after this test\r",
															"pm.globals.set('responseTimedOut', true);\r",
															"\r",
															"// ## Set up transaction eco-system\r",
															"\r",
															"messageSet = utils.createTransactionSetInMemory(\r",
															"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
															"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
															"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
															"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
															"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
															"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
															"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
															"    /* Creditor ID - null defaults random UUID ---------------------- */ cdtrId,\r",
															"    /* Creditor Account ID - null defaults random UUID -------------- */ cdtrAcctId,\r",
															"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
															"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
															"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
															"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
															"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
															"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
															"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
															"    /* Description - null defaults random UUID ---------------------- */ null,\r",
															"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
															"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
															"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
															"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
															"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
															"    );\r",
															"\r",
															"let messageBody = pm.globals.get('pacs008');\r",
															"pm.globals.set('messageBody', messageBody);"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{{messageBody}}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
													"host": [
														"{{tazamaTMSUrl}}{{path-tms-api-version}}"
													],
													"path": [
														"{{path-pacs008}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 3 - Post pacs.002 to TMS API - NO TIMEOUT EXPECTED",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
															"const responseDestination = `relay-service-nats-tp`; // The NATS subject for the output retrieval\r",
															"const awaitReply = true; // Hold the phone for a callback\r",
															"\r",
															"let messageBody = pm.globals.get('pacs002');\r",
															"pm.globals.set('messageBody', messageBody);\r",
															"pm.globals.set('endpoint', endpoint);\r",
															"pm.globals.set('responseDestination', responseDestination);\r",
															"pm.globals.set('awaitReply', awaitReply);\r",
															""
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"const resJson = pm.response.json();\r",
															"console.log(resJson);\r",
															"\r",
															"// Hacky workaround for testing the timeout of the submission of the pacs002\r",
															"pm.globals.set('responseTimedOut', false);\r",
															"\r",
															"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});\r",
															"\r",
															"pm.test(`Interdiction alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
															"    pm.expect(resJson.edResponse.typologyResult.review).to.be.true;\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
													"host": [
														"{{natsUrl}}"
													],
													"path": [
														"{{nats-path-tms-api}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 3 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
														],
														"type": "text/javascript",
														"packages": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"const resJson = pm.response.json();\r",
															"\r",
															"const rulesPerTypologyCount = [3];\r",
															"const totalExpectedTypologies = 1;\r",
															"const expectedAlertStatus = \"ALRT\";\r",
															"const expectedBlockingOutcome = \"none\";\r",
															"const expectedReviewFlag = true;\r",
															"const expectedTypologyAlert = true;\r",
															"const expectedTypologyInterdiction = true;\r",
															"const expectedResponseTimedOut = false;\r",
															"\r",
															"const interdictionTypologies = [\r",
															"  \"999\"\r",
															"];\r",
															"const ruleDescriptions = {\r",
															"  \"901\": \"Number of outgoing transactions - debtor\",\r",
															"  \"902\": \"Number of incoming transactions - creditor\",\r",
															"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
															"}\r",
															"const typologyDescriptions = {\r",
															"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
															"}\r",
															"\r",
															"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
															"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
															"\r",
															"typologyCount = typologyResultsUnique.count();\r",
															"ruleCount = ruleResultsUnique.count();\r",
															"\r",
															"foundEFRuP = false;\r",
															"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
															"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
															"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
															"        foundEFRuP = true;\r",
															"    }\r",
															"}\r",
															"\r",
															"ruleWeightingTotal = 0;\r",
															"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
															"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
															"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
															"    }    \r",
															"}\r",
															"\r",
															"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
															"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
															"});\r",
															"\r",
															"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
															"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
															"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
															"    pm.expect(foundEFRuP).to.be.true;\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
															"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
															"});\r",
															"\r",
															"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedReviewFlag) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
															"    });\r",
															"} else {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
															"    });\r",
															"}\r",
															"\r",
															"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
															"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
															"    });\r",
															"\r",
															"pm.test(`Response received at EFRuP interdiction service before timeout`, function () {\r",
															"        pm.expect(pm.globals.get('responseTimedOut')).to.be.eql(expectedResponseTimedOut);\r",
															"    });"
														],
														"type": "text/javascript",
														"packages": {}
													}
												}
											],
											"request": {
												"auth": {
													"type": "bearer",
													"bearer": [
														{
															"key": "token",
															"value": "{{auth-token}}",
															"type": "string"
														}
													]
												},
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
													"host": [
														"{{arangoUrl}}"
													],
													"path": [
														"_db",
														"{{db_results}}",
														"_api",
														"cursor"
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "After override",
									"item": [
										{
											"name": "Create New Entity Condition Manually - Existing debtor",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"responseJSON = pm.response.json();\r",
															"let conditionResult = responseJSON.result.conditions;\r",
															"let conditionEntity = responseJSON.result.ntty;\r",
															"let requestMessage = responseJSON.message;\r",
															"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
															"let nttyId = pm.globals.get(\"cdtrNttyId\");\r",
															"let nttyIdSchme = pm.globals.get(\"cdtrNttyIdSchmeNm\");\r",
															"let tenantId = pm.globals.get(\"tenantId\");\r",
															"let targetEntityId = nttyId + nttyIdSchme;\r",
															"\r",
															"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
															"targetRequestMessage = \"New condition was saved successfully.\"\r",
															"\r",
															"pm.test(\"Status code is 200\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});\r",
															"\r",
															"pm.test(\"Result message matches target result message\", function () {\r",
															"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
															"});\r",
															"\r",
															"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
															"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
															"});\r",
															"\r",
															"pm.test(\"Result conditions array only contains a single condition\", function () {\r",
															"    pm.expect(conditionResult.length).to.be.eql(1);\r",
															"});\r",
															"\r",
															"let firstElement = conditionResult[0];\r",
															"\r",
															"pm.test(\"Result condition has a non-empty condId\", function () {\r",
															"    pm.expect(firstElement.condId).to.exist.and.not.be.empty;\r",
															"});\r",
															"\r",
															"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
															"    pm.expect(firstElement.condTp).to.be.eql(targetConditionResult.condTp);\r",
															"});\r",
															"\r",
															"if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
															"    pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
															"        pm.expect(firstElement.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
															"    });\r",
															"} else {    // if not, one must have been defaulted\r",
															"    pm.test(\"Result condition has a non-empty incptnDtTm\", function () {\r",
															"        pm.expect(firstElement.incptnDtTm).to.exist.and.not.be.empty;\r",
															"    });\r",
															"}\r",
															"\r",
															"if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
															"    pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
															"        pm.expect(firstElement.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
															"    });\r",
															"} else {    // if not, one must not have been defaulted\r",
															"    pm.test(\"Result condition does not have an xprtnDtTm\", function () {\r",
															"        pm.expect(firstElement.xprtnDtTm).to.not.exist;\r",
															"    });\r",
															"}\r",
															"\r",
															"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
															"    pm.expect(firstElement.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
															"});\r",
															"\r",
															"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
															"    pm.expect(firstElement.usr).to.be.eql(targetConditionResult.usr);\r",
															"});\r",
															"\r",
															"pm.test(\"Result condition has a non-empty creDtTm\", function () {\r",
															"    pm.expect(firstElement.creDtTm).to.exist.and.not.be.empty;\r",
															"});\r",
															"\r",
															"// create an array that only includes the perspective descriptions so that we can evaluate them easily\r",
															"let perspectives = firstElement.prsptvs.map(({ prsptv }) => prsptv);\r",
															"\r",
															"if (targetConditionResult.prsptv === \"both\") {\r",
															"    pm.test(\"Result prsptv array contains only 2 perspectives\", function () {\r",
															"        pm.expect(firstElement.prsptvs.length).to.be.eql(2);\r",
															"    });\r",
															"\r",
															"    let targetPerspectives = [\"governed_as_creditor_by\", \"governed_as_debtor_by\"];\r",
															"\r",
															"    pm.test(`Result prsptv array contains both ${JSON.stringify(targetPerspectives)} perspectives`, function () {\r",
															"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
															"    });\r",
															"\r",
															"} else if (targetConditionResult.prsptv === \"debtor\") {\r",
															"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
															"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
															"    });\r",
															"\r",
															"    let targetPerspectives = [\"governed_as_debtor_by\"];\r",
															"\r",
															"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
															"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
															"    });\r",
															"\r",
															"} else if (targetConditionResult.prsptv === \"creditor\") {\r",
															"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
															"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
															"    });\r",
															"\r",
															"    let targetPerspectives = [\"governed_as_creditor_by\"];\r",
															"\r",
															"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
															"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
															"    });\r",
															"\r",
															"};\r",
															"\r",
															"for (let i = 0; i < firstElement.prsptvs.length; i++) {   // for each perspective\r",
															"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} contains a non-empty evtTp array`, function () {\r",
															"        pm.expect(firstElement.prsptvs[i].evtTp).to.be.an('array').and.not.be.empty;\r",
															"    });\r",
															"\r",
															"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} evtTp array matches submitted condition`, function () {\r",
															"        pm.expect(firstElement.prsptvs[i].evtTp).to.include.members(targetConditionResult.evtTp);\r",
															"    });\r",
															"\r",
															"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
															"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches submitted condition`, function () {\r",
															"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
															"        });\r",
															"    } else {    // if not, one must have been defaulted\r",
															"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches created condition incptDtTm`, function () {\r",
															"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.eql(firstElement.incptnDtTm);\r",
															"        });\r",
															"    }\r",
															"\r",
															"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
															"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} xprtnDtTm matches submitted condition`, function () {\r",
															"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
															"        });\r",
															"    } else {    // if not, one must not have been defaulted\r",
															"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} does not have an xprtnDtTm`, function () {\r",
															"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.not.exist;\r",
															"        });\r",
															"    }\r",
															"\r",
															"}\r",
															"\r",
															"pm.test(\"Result condition ntty.id matches submitted condition\", function () {\r",
															"    pm.expect(conditionEntity.id).to.be.eql(targetConditionResult.ntty.id);\r",
															"});\r",
															"\r",
															"pm.test(\"Result condition ntty.schmeNm.prtry matches submitted condition\", function () {\r",
															"    pm.expect(conditionEntity.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
															"});\r",
															"\r",
															"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetEntityId, false);;\r",
															"\r",
															"await pm.sendRequest(postRequest, (error, response) => {\r",
															"    if (utils.getLogLevel() === 'DEBUG') {\r",
															"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
															"    }\r",
															"    databaseConditionResult = response.json().data;\r",
															"\r",
															"    if (utils.getLogLevel() === 'DEBUG') {\r",
															"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
															"    }\r",
															"\r",
															"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
															"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
															"\r",
															"    pm.test(`Only one condition for entity [${targetEntityId}] exists in the database`, function () {\r",
															"        pm.expect(graphConditionList.length).to.eql(1);\r",
															"    });\r",
															"\r",
															"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
															"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
															"            pm.expect(conditionGraph.v[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
															"        });\r",
															"    }\r",
															"\r",
															"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
															"        pm.expect(conditionGraph.v[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
															"    });\r",
															"\r",
															"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
															"        pm.expect(conditionGraph.v[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
															"    });\r",
															"\r",
															"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
															"        pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
															"            pm.expect(conditionGraph.v[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
															"        });\r",
															"    } else {    // if not, one must have been defaulted\r",
															"        pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
															"            pm.expect(conditionGraph.v[0].incptnDtTm).to.exist.and.not.be.empty;\r",
															"        });\r",
															"    }\r",
															"\r",
															"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
															"        pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
															"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
															"        });\r",
															"    } else {    // if not, one must not have been defaulted\r",
															"        pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
															"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.not.exist;\r",
															"        });\r",
															"    }\r",
															"\r",
															"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
															"        pm.expect(conditionGraph.v[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
															"    });\r",
															"\r",
															"    pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
															"        pm.expect(conditionGraph.v[0].ntty.id).to.be.eql(targetConditionResult.ntty.id);\r",
															"    });\r",
															"\r",
															"    pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
															"        pm.expect(conditionGraph.v[0].ntty.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
															"    });\r",
															"\r",
															"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
															"        pm.expect(conditionGraph.v[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
															"    });\r",
															"\r",
															"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
															"        pm.expect(conditionGraph.v[0].usr).to.be.eql(targetConditionResult.usr);\r",
															"    });\r",
															"\r",
															"    let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, conditionGraph.v[0]._key);\r",
															"\r",
															"    pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
															"        pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
															"    });\r",
															"\r",
															"    pm.test(\"Database 'governed_as_creditor_by' edge exists\", function () {\r",
															"        pm.expect(edgeList).to.include.members([\"governed_as_creditor_by\"]);\r",
															"    });\r",
															"\r",
															"    pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
															"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
															"    });\r",
															"\r",
															"    pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
															"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
															"    });\r",
															"\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {}
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
															"\r",
															"// Obliterate the current contents of the global variables\r",
															"// Retrieve the created pacs.008 message\r",
															"\r",
															"const submittedPacs008Message = JSON.parse(pm.globals.get('pacs008Stash'));\r",
															"pm.globals.set('pacs008', pm.globals.get('pacs008Stash'));\r",
															"\r",
															"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
															"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
															"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
															"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
															"\r",
															"// Load deconstructued identifier variables into global variables\r",
															"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
															"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
															"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
															"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
															"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
															"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
															"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
															"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
															"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
															"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
															"\r",
															"xprtnDtTm = utils.timestampAtTMinus(-10, \"m\");\r",
															"\r",
															"// Set up the condition\r",
															"\r",
															"console.log(`Override incepts at ${utils.getTimestampNow()}`);\r",
															"\r",
															"messageBody = {\r",
															"  \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09\",\"pacs.008.001.10\",\"pacs.002.001.12\"],\r",
															"  \"condTp\":\"override\",\r",
															"  \"prsptv\":\"both\",\r",
															"  \"xprtnDtTm\": xprtnDtTm,\r",
															"  \"condRsn\":\"Default Test Condition\",\r",
															"  \"ntty\":\r",
															"  {\r",
															"    \"id\": `${cdtrNttyId.id}`,\r",
															"    \"schmeNm\":\r",
															"    {\r",
															"      \"prtry\":\"TAZAMA_EID\"\r",
															"    }\r",
															"  },\r",
															"  \"forceCret\":true,\r",
															"  \"usr\":\"POSTMAN\"\r",
															"}\r",
															"\r",
															"// Set up body variables\r",
															"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
															"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
														],
														"type": "text/javascript",
														"packages": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{{messageBody}}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
													"host": [
														"{{tazamaAdminUrl}}{{path-admin-api-version}}"
													],
													"path": [
														"{{path-entity-condition}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 4 - Post pacs.008 to TMS API",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
															"\r",
															"let dbtrId = pm.globals.get('debtorId');\r",
															"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
															"let cdtrId = pm.globals.get('creditorId');\r",
															"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
															"\r",
															"// Hacky workaround for testing the timeout of the submission of the pacs002 after this test\r",
															"pm.globals.set('responseTimedOut', true);\r",
															"\r",
															"// ## Set up transaction eco-system\r",
															"\r",
															"messageSet = utils.createTransactionSetInMemory(\r",
															"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
															"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
															"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
															"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
															"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
															"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
															"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
															"    /* Creditor ID - null defaults random UUID ---------------------- */ cdtrId,\r",
															"    /* Creditor Account ID - null defaults random UUID -------------- */ cdtrAcctId,\r",
															"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
															"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
															"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
															"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
															"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
															"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
															"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
															"    /* Description - null defaults random UUID ---------------------- */ null,\r",
															"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
															"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
															"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
															"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
															"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
															"    );\r",
															"\r",
															"let messageBody = pm.globals.get('pacs008');\r",
															"pm.globals.set('messageBody', messageBody);"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{{messageBody}}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
													"host": [
														"{{tazamaTMSUrl}}{{path-tms-api-version}}"
													],
													"path": [
														"{{path-pacs008}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 4 - Post pacs.002 to TMS API - TIMEOUT EXPECTED",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
															"const responseDestination = `relay-service-nats-tp`; // The NATS subject for the output retrieval\r",
															"const awaitReply = true; // Hold the phone for a callback\r",
															"\r",
															"let messageBody = pm.globals.get('pacs002');\r",
															"pm.globals.set('messageBody', messageBody);\r",
															"pm.globals.set('endpoint', endpoint);\r",
															"pm.globals.set('responseDestination', responseDestination);\r",
															"pm.globals.set('awaitReply', awaitReply);\r",
															""
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"const resJson = pm.response.json();\r",
															"console.log(resJson);\r",
															"\r",
															"// Hacky workaround for testing the timeout of the submission of the pacs002\r",
															"pm.globals.set('responseTimedOut', false);\r",
															"\r",
															"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});\r",
															"\r",
															"pm.test(`No alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
															"    pm.expect(resJson.edResponse.ruleResult.typologyResult.review).to.be.true;\r",
															"});\r",
															"\r",
															"pm.test(`Request does not complete within specified timeout of ${pm.globals.get('timeoutLimit')}`, function () {\r",
															"    pm.expect(pm.response.responseTime).to.be.above(4000);\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
													"host": [
														"{{natsUrl}}"
													],
													"path": [
														"{{nats-path-tms-api}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 4 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
														],
														"type": "text/javascript",
														"packages": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"const resJson = pm.response.json();\r",
															"\r",
															"const rulesPerTypologyCount = [3];\r",
															"const totalExpectedTypologies = 1;\r",
															"const expectedAlertStatus = \"ALRT\";\r",
															"const expectedBlockingOutcome = \"override\";\r",
															"const expectedReviewFlag = true;\r",
															"const expectedTypologyAlert = true;\r",
															"const expectedTypologyInterdiction = true;\r",
															"const expectedResponseTimedOut = true;\r",
															"\r",
															"const interdictionTypologies = [\r",
															"  \"999\"\r",
															"];\r",
															"const ruleDescriptions = {\r",
															"  \"901\": \"Number of outgoing transactions - debtor\",\r",
															"  \"902\": \"Number of incoming transactions - creditor\",\r",
															"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
															"}\r",
															"const typologyDescriptions = {\r",
															"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
															"}\r",
															"\r",
															"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
															"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
															"\r",
															"typologyCount = typologyResultsUnique.count();\r",
															"ruleCount = ruleResultsUnique.count();\r",
															"\r",
															"foundEFRuP = false;\r",
															"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
															"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
															"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
															"        foundEFRuP = true;\r",
															"    }\r",
															"}\r",
															"\r",
															"ruleWeightingTotal = 0;\r",
															"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
															"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
															"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
															"    }    \r",
															"}\r",
															"\r",
															"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
															"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
															"});\r",
															"\r",
															"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
															"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
															"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
															"    pm.expect(foundEFRuP).to.be.true;\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
															"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
															"});\r",
															"\r",
															"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedReviewFlag) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
															"    });\r",
															"} else {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
															"    });\r",
															"}\r",
															"\r",
															"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
															"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
															"    });\r",
															"\r",
															"pm.test(`No response received at EFRuP interdiction service before timeout`, function () {\r",
															"        pm.expect(pm.globals.get('responseTimedOut')).to.be.eql(expectedResponseTimedOut);\r",
															"    });"
														],
														"type": "text/javascript",
														"packages": {}
													}
												}
											],
											"request": {
												"auth": {
													"type": "bearer",
													"bearer": [
														{
															"key": "token",
															"value": "{{auth-token}}",
															"type": "string"
														}
													]
												},
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
													"host": [
														"{{arangoUrl}}"
													],
													"path": [
														"_db",
														"{{db_results}}",
														"_api",
														"cursor"
													]
												}
											},
											"response": []
										}
									]
								}
							]
						}
					]
				},
				{
					"name": "cdtrId - perspective=debtor",
					"item": [
						{
							"name": "non-overridable block",
							"item": [
								{
									"name": "Create New Entity Condition Manually - Unknown creditor entity",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"responseJSON = pm.response.json();\r",
													"let conditionResult = responseJSON.result.conditions;\r",
													"let conditionEntity = responseJSON.result.ntty;\r",
													"let requestMessage = responseJSON.message;\r",
													"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
													"let nttyId = pm.globals.get(\"cdtrNttyId\");\r",
													"let nttyIdSchme = pm.globals.get(\"cdtrNttyIdSchmeNm\");\r",
													"let tenantId = pm.globals.get(\"tenantId\");\r",
													"let targetEntityId = nttyId + nttyIdSchme;\r",
													"\r",
													"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
													"targetRequestMessage = \"New condition was saved successfully.\"\r",
													"\r",
													"pm.test(\"Status code is 200\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(\"Result message matches target result message\", function () {\r",
													"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
													"});\r",
													"\r",
													"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
													"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
													"});\r",
													"\r",
													"pm.test(\"Result conditions array only contains a single condition\", function () {\r",
													"    pm.expect(conditionResult.length).to.be.eql(1);\r",
													"});\r",
													"\r",
													"let firstElement = conditionResult[0];\r",
													"\r",
													"pm.test(\"Result condition has a non-empty condId\", function () {\r",
													"    pm.expect(firstElement.condId).to.exist.and.not.be.empty;\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.condTp).to.be.eql(targetConditionResult.condTp);\r",
													"});\r",
													"\r",
													"if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"    pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
													"        pm.expect(firstElement.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"    });\r",
													"} else {    // if not, one must have been defaulted\r",
													"    pm.test(\"Result condition has a non-empty incptnDtTm\", function () {\r",
													"        pm.expect(firstElement.incptnDtTm).to.exist.and.not.be.empty;\r",
													"    });\r",
													"}\r",
													"\r",
													"if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"    pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
													"        pm.expect(firstElement.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"    });\r",
													"} else {    // if not, one must not have been defaulted\r",
													"    pm.test(\"Result condition does not have an xprtnDtTm\", function () {\r",
													"        pm.expect(firstElement.xprtnDtTm).to.not.exist;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.usr).to.be.eql(targetConditionResult.usr);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition has a non-empty creDtTm\", function () {\r",
													"    pm.expect(firstElement.creDtTm).to.exist.and.not.be.empty;\r",
													"});\r",
													"\r",
													"// create an array that only includes the perspective descriptions so that we can evaluate them easily\r",
													"let perspectives = firstElement.prsptvs.map(({ prsptv }) => prsptv);\r",
													"\r",
													"if (targetConditionResult.prsptv === \"both\") {\r",
													"    pm.test(\"Result prsptv array contains only 2 perspectives\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(2);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_creditor_by\", \"governed_as_debtor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains both ${JSON.stringify(targetPerspectives)} perspectives`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"} else if (targetConditionResult.prsptv === \"debtor\") {\r",
													"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_debtor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"} else if (targetConditionResult.prsptv === \"creditor\") {\r",
													"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_creditor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"};\r",
													"\r",
													"for (let i = 0; i < firstElement.prsptvs.length; i++) {   // for each perspective\r",
													"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} contains a non-empty evtTp array`, function () {\r",
													"        pm.expect(firstElement.prsptvs[i].evtTp).to.be.an('array').and.not.be.empty;\r",
													"    });\r",
													"\r",
													"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} evtTp array matches submitted condition`, function () {\r",
													"        pm.expect(firstElement.prsptvs[i].evtTp).to.include.members(targetConditionResult.evtTp);\r",
													"    });\r",
													"\r",
													"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches submitted condition`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must have been defaulted\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches created condition incptDtTm`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.eql(firstElement.incptnDtTm);\r",
													"        });\r",
													"    }\r",
													"\r",
													"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} xprtnDtTm matches submitted condition`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must not have been defaulted\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} does not have an xprtnDtTm`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.not.exist;\r",
													"        });\r",
													"    }\r",
													"\r",
													"}\r",
													"\r",
													"pm.test(\"Result condition ntty.id matches submitted condition\", function () {\r",
													"    pm.expect(conditionEntity.id).to.be.eql(targetConditionResult.ntty.id);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"    pm.expect(conditionEntity.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
													"});\r",
													"\r",
													"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetEntityId, false);;\r",
													"\r",
													"await pm.sendRequest(postRequest, (error, response) => {\r",
													"    if (utils.getLogLevel() === 'DEBUG') {\r",
													"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
													"    }\r",
													"    databaseConditionResult = response.json().data;\r",
													"\r",
													"    if (utils.getLogLevel() === 'DEBUG') {\r",
													"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
													"    }\r",
													"\r",
													"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
													"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
													"\r",
													"    pm.test(`Only one condition for entity [${targetEntityId}] exists in the database`, function () {\r",
													"        pm.expect(graphConditionList.length).to.eql(1);\r",
													"    });\r",
													"\r",
													"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
													"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
													"            pm.expect(conditionGraph.v[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
													"        });\r",
													"    }\r",
													"\r",
													"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
													"    });\r",
													"\r",
													"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"        pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
													"            pm.expect(conditionGraph.v[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must have been defaulted\r",
													"        pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
													"            pm.expect(conditionGraph.v[0].incptnDtTm).to.exist.and.not.be.empty;\r",
													"        });\r",
													"    }\r",
													"\r",
													"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"        pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
													"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must not have been defaulted\r",
													"        pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
													"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.not.exist;\r",
													"        });\r",
													"    }\r",
													"\r",
													"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].ntty.id).to.be.eql(targetConditionResult.ntty.id);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].ntty.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].usr).to.be.eql(targetConditionResult.usr);\r",
													"    });\r",
													"\r",
													"    let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, conditionGraph.v[0]._key);\r",
													"\r",
													"    pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
													"        pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database 'governed_as_creditor_by' edge does not exist\", function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
													"    });\r",
													"\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"// Obliterate the current contents of the global variables\r",
													"pm.globals.clear();\r",
													"\r",
													"// Set up the transaction (in memory)\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ 3600000,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"\r",
													"// Retrieve the created pacs.008 message\r",
													"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
													"\r",
													"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
													"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
													"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
													"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
													"\r",
													"// Load deconstructued identifier variables into global variables\r",
													"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
													"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
													"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
													"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
													"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
													"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
													"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
													"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
													"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
													"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
													"pm.globals.set(\"tenantId\", submittedPacs008Message.TenantId);\r",
													"\r",
													"// Set up the condition\r",
													"\r",
													"messageBody = {\r",
													"  \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09\",\"pacs.008.001.10\",\"pacs.002.001.12\"],\r",
													"  \"condTp\":\"non-overridable-block\",\r",
													"  \"prsptv\":\"debtor\",\r",
													"  \"condRsn\":\"Default Test Condition\",\r",
													"  \"ntty\":\r",
													"  {\r",
													"    \"id\": `${cdtrNttyId.id}`,\r",
													"    \"schmeNm\":\r",
													"    {\r",
													"      \"prtry\":\"TAZAMA_EID\"\r",
													"    }\r",
													"  },\r",
													"  \"forceCret\":true,\r",
													"  \"usr\":\"POSTMAN\"\r",
													"}\r",
													"\r",
													"// Set up body variables\r",
													"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
													"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
											"host": [
												"{{tazamaAdminUrl}}{{path-admin-api-version}}"
											],
											"path": [
												"{{path-entity-condition}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('dbtrNttyId');\r",
													"let dbtrAcctId = pm.globals.get('dbtrAcctId');\r",
													"let cdtrId = pm.globals.get('cdtrNttyId');\r",
													"let cdtrAcctId = pm.globals.get('cdtrAcctId');\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ cdtrId,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ cdtrAcctId,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ 'fsp001',\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Post pacs.002 to TMS API - TIMEOUT EXPECTED",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`Alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"NALT\";\r",
													"const expectedBlockingOutcome = \"none\";\r",
													"const expectedReviewFlag = false;\r",
													"const expectedTypologyAlert = false;\r",
													"const expectedTypologyInterdiction = false;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('dbtrNttyId');\r",
													"let dbtrAcctId = pm.globals.get('dbtrAcctId');\r",
													"let cdtrId = pm.globals.get('cdtrNttyId');\r",
													"let cdtrAcctId = pm.globals.get('cdtrAcctId');\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ cdtrId,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ cdtrAcctId,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ 'fsp001',\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Post pacs.002 to TMS API - EXPECTED TIMEOUT",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`Alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"ALRT\";\r",
													"const expectedBlockingOutcome = \"none\";\r",
													"const expectedReviewFlag = true;\r",
													"const expectedTypologyAlert = true;\r",
													"const expectedTypologyInterdiction = false;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('dbtrNttyId');\r",
													"let dbtrAcctId = pm.globals.get('dbtrAcctId');\r",
													"let cdtrId = pm.globals.get('cdtrNttyId');\r",
													"let cdtrAcctId = pm.globals.get('cdtrAcctId');\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ cdtrId,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ cdtrAcctId,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ 'fsp001',\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Post pacs.002 to TMS API - TIMEOUT EXPECTED",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`Alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"ALRT\";\r",
													"const expectedBlockingOutcome = \"none\";\r",
													"const expectedReviewFlag = true;\r",
													"const expectedTypologyAlert = true;\r",
													"const expectedTypologyInterdiction = true;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "overridable block",
							"item": [
								{
									"name": "Create New Entity Condition Manually - Unknown debtor entity",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"responseJSON = pm.response.json();\r",
													"let conditionResult = responseJSON.result.conditions;\r",
													"let conditionEntity = responseJSON.result.ntty;\r",
													"let requestMessage = responseJSON.message;\r",
													"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
													"let nttyId = pm.globals.get(\"cdtrNttyId\");\r",
													"let nttyIdSchme = pm.globals.get(\"cdtrNttyIdSchmeNm\");\r",
													"let tenantId = pm.globals.get(\"tenantId\");\r",
													"let targetEntityId = nttyId + nttyIdSchme;\r",
													"\r",
													"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
													"targetRequestMessage = \"New condition was saved successfully.\"\r",
													"\r",
													"pm.test(\"Status code is 200\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(\"Result message matches target result message\", function () {\r",
													"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
													"});\r",
													"\r",
													"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
													"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
													"});\r",
													"\r",
													"pm.test(\"Result conditions array only contains a single condition\", function () {\r",
													"    pm.expect(conditionResult.length).to.be.eql(1);\r",
													"});\r",
													"\r",
													"let firstElement = conditionResult[0];\r",
													"\r",
													"pm.test(\"Result condition has a non-empty condId\", function () {\r",
													"    pm.expect(firstElement.condId).to.exist.and.not.be.empty;\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.condTp).to.be.eql(targetConditionResult.condTp);\r",
													"});\r",
													"\r",
													"if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"    pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
													"        pm.expect(firstElement.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"    });\r",
													"} else {    // if not, one must have been defaulted\r",
													"    pm.test(\"Result condition has a non-empty incptnDtTm\", function () {\r",
													"        pm.expect(firstElement.incptnDtTm).to.exist.and.not.be.empty;\r",
													"    });\r",
													"}\r",
													"\r",
													"if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"    pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
													"        pm.expect(firstElement.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"    });\r",
													"} else {    // if not, one must not have been defaulted\r",
													"    pm.test(\"Result condition does not have an xprtnDtTm\", function () {\r",
													"        pm.expect(firstElement.xprtnDtTm).to.not.exist;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.usr).to.be.eql(targetConditionResult.usr);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition has a non-empty creDtTm\", function () {\r",
													"    pm.expect(firstElement.creDtTm).to.exist.and.not.be.empty;\r",
													"});\r",
													"\r",
													"// create an array that only includes the perspective descriptions so that we can evaluate them easily\r",
													"let perspectives = firstElement.prsptvs.map(({ prsptv }) => prsptv);\r",
													"\r",
													"if (targetConditionResult.prsptv === \"both\") {\r",
													"    pm.test(\"Result prsptv array contains only 2 perspectives\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(2);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_creditor_by\", \"governed_as_debtor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains both ${JSON.stringify(targetPerspectives)} perspectives`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"} else if (targetConditionResult.prsptv === \"debtor\") {\r",
													"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_debtor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"} else if (targetConditionResult.prsptv === \"creditor\") {\r",
													"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_creditor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"};\r",
													"\r",
													"for (let i = 0; i < firstElement.prsptvs.length; i++) {   // for each perspective\r",
													"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} contains a non-empty evtTp array`, function () {\r",
													"        pm.expect(firstElement.prsptvs[i].evtTp).to.be.an('array').and.not.be.empty;\r",
													"    });\r",
													"\r",
													"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} evtTp array matches submitted condition`, function () {\r",
													"        pm.expect(firstElement.prsptvs[i].evtTp).to.include.members(targetConditionResult.evtTp);\r",
													"    });\r",
													"\r",
													"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches submitted condition`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must have been defaulted\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches created condition incptDtTm`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.eql(firstElement.incptnDtTm);\r",
													"        });\r",
													"    }\r",
													"\r",
													"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} xprtnDtTm matches submitted condition`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must not have been defaulted\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} does not have an xprtnDtTm`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.not.exist;\r",
													"        });\r",
													"    }\r",
													"\r",
													"}\r",
													"\r",
													"pm.test(\"Result condition ntty.id matches submitted condition\", function () {\r",
													"    pm.expect(conditionEntity.id).to.be.eql(targetConditionResult.ntty.id);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"    pm.expect(conditionEntity.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
													"});\r",
													"\r",
													"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetEntityId, false);;\r",
													"\r",
													"await pm.sendRequest(postRequest, (error, response) => {\r",
													"    if (utils.getLogLevel() === 'DEBUG') {\r",
													"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
													"    }\r",
													"    databaseConditionResult = response.json().data;\r",
													"\r",
													"    if (utils.getLogLevel() === 'DEBUG') {\r",
													"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
													"    }\r",
													"\r",
													"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
													"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
													"\r",
													"    pm.test(`Only one condition for entity [${targetEntityId}] exists in the database`, function () {\r",
													"        pm.expect(graphConditionList.length).to.eql(1);\r",
													"    });\r",
													"\r",
													"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
													"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
													"            pm.expect(conditionGraph.v[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
													"        });\r",
													"    }\r",
													"\r",
													"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
													"    });\r",
													"\r",
													"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"        pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
													"            pm.expect(conditionGraph.v[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must have been defaulted\r",
													"        pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
													"            pm.expect(conditionGraph.v[0].incptnDtTm).to.exist.and.not.be.empty;\r",
													"        });\r",
													"    }\r",
													"\r",
													"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"        pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
													"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must not have been defaulted\r",
													"        pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
													"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.not.exist;\r",
													"        });\r",
													"    }\r",
													"\r",
													"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].ntty.id).to.be.eql(targetConditionResult.ntty.id);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].ntty.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].usr).to.be.eql(targetConditionResult.usr);\r",
													"    });\r",
													"\r",
													"    let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, conditionGraph.v[0]._key);\r",
													"\r",
													"    pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
													"        pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database 'governed_as_creditor_by' edge does not exist\", function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
													"    });\r",
													"\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"// Obliterate the current contents of the global variables\r",
													"pm.globals.clear();\r",
													"\r",
													"// Set up the transaction (in memory)\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ 3600000,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"\r",
													"// Retrieve the created pacs.008 message\r",
													"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
													"\r",
													"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
													"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
													"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
													"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
													"\r",
													"// Load deconstructued identifier variables into global variables\r",
													"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
													"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
													"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
													"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
													"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
													"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
													"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
													"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
													"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
													"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
													"\r",
													"// Set up the condition\r",
													"\r",
													"messageBody = {\r",
													"  \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09\",\"pacs.008.001.10\",\"pacs.002.001.12\"],\r",
													"  \"condTp\":\"overridable-block\",\r",
													"  \"prsptv\":\"debtor\",\r",
													"  \"condRsn\":\"Default Test Condition\",\r",
													"  \"ntty\":\r",
													"  {\r",
													"    \"id\": `${cdtrNttyId.id}`,\r",
													"    \"schmeNm\":\r",
													"    {\r",
													"      \"prtry\":\"TAZAMA_EID\"\r",
													"    }\r",
													"  },\r",
													"  \"forceCret\":true,\r",
													"  \"usr\":\"POSTMAN\"\r",
													"}\r",
													"\r",
													"// Set up body variables\r",
													"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
													"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
											"host": [
												"{{tazamaAdminUrl}}{{path-admin-api-version}}"
											],
											"path": [
												"{{path-entity-condition}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('debtorId');\r",
													"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
													"let cdtrId = pm.globals.get('creditorId');\r",
													"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ cdtrId,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ cdtrAcctId,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ 'fsp001',\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Post pacs.002 to TMS API - TIMEOUT EXPECTED",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`Alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"NALT\";\r",
													"const expectedBlockingOutcome = \"none\";\r",
													"const expectedReviewFlag = false;\r",
													"const expectedTypologyAlert = false;\r",
													"const expectedTypologyInterdiction = false;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('debtorId');\r",
													"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
													"let cdtrId = pm.globals.get('creditorId');\r",
													"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ cdtrId,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ cdtrAcctId,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ 'fsp001',\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Post pacs.002 to TMS API - TIMEOUT EXPECTED",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`Alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"ALRT\";\r",
													"const expectedBlockingOutcome = \"none\";\r",
													"const expectedReviewFlag = true;\r",
													"const expectedTypologyAlert = true;\r",
													"const expectedTypologyInterdiction = false;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('debtorId');\r",
													"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
													"let cdtrId = pm.globals.get('creditorId');\r",
													"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ cdtrId,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ cdtrAcctId,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ 'fsp001',\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Post pacs.002 to TMS API - TIMEOUT EXPECTED",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`Alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"ALRT\";\r",
													"const expectedBlockingOutcome = \"none\";\r",
													"const expectedReviewFlag = true;\r",
													"const expectedTypologyAlert = true;\r",
													"const expectedTypologyInterdiction = true;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "overridable block with override",
							"item": [
								{
									"name": "Create New Entity Condition Manually - Unknown debtor entity",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"responseJSON = pm.response.json();\r",
													"let conditionResult = responseJSON.result.conditions;\r",
													"let conditionEntity = responseJSON.result.ntty;\r",
													"let requestMessage = responseJSON.message;\r",
													"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
													"let nttyId = pm.globals.get(\"cdtrNttyId\");\r",
													"let nttyIdSchme = pm.globals.get(\"cdtrNttyIdSchmeNm\");\r",
													"let tenantId = pm.globals.get(\"tenantId\");\r",
													"let targetEntityId = nttyId + nttyIdSchme;\r",
													"\r",
													"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
													"targetRequestMessage = \"New condition was saved successfully.\"\r",
													"\r",
													"pm.test(\"Status code is 200\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(\"Result message matches target result message\", function () {\r",
													"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
													"});\r",
													"\r",
													"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
													"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
													"});\r",
													"\r",
													"pm.test(\"Result conditions array only contains a single condition\", function () {\r",
													"    pm.expect(conditionResult.length).to.be.eql(1);\r",
													"});\r",
													"\r",
													"let firstElement = conditionResult[0];\r",
													"\r",
													"pm.test(\"Result condition has a non-empty condId\", function () {\r",
													"    pm.expect(firstElement.condId).to.exist.and.not.be.empty;\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.condTp).to.be.eql(targetConditionResult.condTp);\r",
													"});\r",
													"\r",
													"if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"    pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
													"        pm.expect(firstElement.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"    });\r",
													"} else {    // if not, one must have been defaulted\r",
													"    pm.test(\"Result condition has a non-empty incptnDtTm\", function () {\r",
													"        pm.expect(firstElement.incptnDtTm).to.exist.and.not.be.empty;\r",
													"    });\r",
													"}\r",
													"\r",
													"if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"    pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
													"        pm.expect(firstElement.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"    });\r",
													"} else {    // if not, one must not have been defaulted\r",
													"    pm.test(\"Result condition does not have an xprtnDtTm\", function () {\r",
													"        pm.expect(firstElement.xprtnDtTm).to.not.exist;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.usr).to.be.eql(targetConditionResult.usr);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition has a non-empty creDtTm\", function () {\r",
													"    pm.expect(firstElement.creDtTm).to.exist.and.not.be.empty;\r",
													"});\r",
													"\r",
													"// create an array that only includes the perspective descriptions so that we can evaluate them easily\r",
													"let perspectives = firstElement.prsptvs.map(({ prsptv }) => prsptv);\r",
													"\r",
													"if (targetConditionResult.prsptv === \"both\") {\r",
													"    pm.test(\"Result prsptv array contains only 2 perspectives\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(2);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_creditor_by\", \"governed_as_debtor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains both ${JSON.stringify(targetPerspectives)} perspectives`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"} else if (targetConditionResult.prsptv === \"debtor\") {\r",
													"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_debtor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"} else if (targetConditionResult.prsptv === \"creditor\") {\r",
													"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_creditor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"};\r",
													"\r",
													"for (let i = 0; i < firstElement.prsptvs.length; i++) {   // for each perspective\r",
													"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} contains a non-empty evtTp array`, function () {\r",
													"        pm.expect(firstElement.prsptvs[i].evtTp).to.be.an('array').and.not.be.empty;\r",
													"    });\r",
													"\r",
													"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} evtTp array matches submitted condition`, function () {\r",
													"        pm.expect(firstElement.prsptvs[i].evtTp).to.include.members(targetConditionResult.evtTp);\r",
													"    });\r",
													"\r",
													"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches submitted condition`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must have been defaulted\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches created condition incptDtTm`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.eql(firstElement.incptnDtTm);\r",
													"        });\r",
													"    }\r",
													"\r",
													"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} xprtnDtTm matches submitted condition`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must not have been defaulted\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} does not have an xprtnDtTm`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.not.exist;\r",
													"        });\r",
													"    }\r",
													"\r",
													"}\r",
													"\r",
													"pm.test(\"Result condition ntty.id matches submitted condition\", function () {\r",
													"    pm.expect(conditionEntity.id).to.be.eql(targetConditionResult.ntty.id);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"    pm.expect(conditionEntity.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
													"});\r",
													"\r",
													"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetEntityId, false);;\r",
													"\r",
													"await pm.sendRequest(postRequest, (error, response) => {\r",
													"    if (utils.getLogLevel() === 'DEBUG') {\r",
													"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
													"    }\r",
													"    databaseConditionResult = response.json().data;\r",
													"\r",
													"    if (utils.getLogLevel() === 'DEBUG') {\r",
													"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
													"    }\r",
													"\r",
													"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
													"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
													"\r",
													"    pm.test(`Only one condition for entity [${targetEntityId}] exists in the database`, function () {\r",
													"        pm.expect(graphConditionList.length).to.eql(1);\r",
													"    });\r",
													"\r",
													"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
													"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
													"            pm.expect(conditionGraph.v[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
													"        });\r",
													"    }\r",
													"\r",
													"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
													"    });\r",
													"\r",
													"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"        pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
													"            pm.expect(conditionGraph.v[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must have been defaulted\r",
													"        pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
													"            pm.expect(conditionGraph.v[0].incptnDtTm).to.exist.and.not.be.empty;\r",
													"        });\r",
													"    }\r",
													"\r",
													"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"        pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
													"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must not have been defaulted\r",
													"        pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
													"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.not.exist;\r",
													"        });\r",
													"    }\r",
													"\r",
													"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].ntty.id).to.be.eql(targetConditionResult.ntty.id);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].ntty.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].usr).to.be.eql(targetConditionResult.usr);\r",
													"    });\r",
													"\r",
													"    let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, conditionGraph.v[0]._key);\r",
													"\r",
													"    pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
													"        pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database 'governed_as_creditor_by' edge does not exist\", function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
													"    });\r",
													"\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"// Obliterate the current contents of the global variables\r",
													"pm.globals.clear();\r",
													"\r",
													"// Set up the transaction (in memory)\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ 3600000,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"\r",
													"// Retrieve the created pacs.008 message\r",
													"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
													"\r",
													"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
													"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
													"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
													"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
													"\r",
													"// Load deconstructued identifier variables into global variables\r",
													"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
													"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
													"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
													"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
													"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
													"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
													"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
													"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
													"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
													"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
													"\r",
													"// Set up the condition\r",
													"\r",
													"console.log(`Overridable block incepts at ${utils.getTimestampNow()}`);\r",
													"\r",
													"messageBody = {\r",
													"  \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09\",\"pacs.008.001.10\",\"pacs.002.001.12\"],\r",
													"  \"condTp\":\"overridable-block\",\r",
													"  \"prsptv\":\"debtor\",\r",
													"  \"condRsn\":\"Default Test Condition\",\r",
													"  \"ntty\":\r",
													"  {\r",
													"    \"id\": `${cdtrNttyId.id}`,\r",
													"    \"schmeNm\":\r",
													"    {\r",
													"      \"prtry\":\"TAZAMA_EID\"\r",
													"    }\r",
													"  },\r",
													"  \"forceCret\":true,\r",
													"  \"usr\":\"POSTMAN\"\r",
													"}\r",
													"\r",
													"// Set up body variables\r",
													"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
													"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
											"host": [
												"{{tazamaAdminUrl}}{{path-admin-api-version}}"
											],
											"path": [
												"{{path-entity-condition}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Create New Entity Condition Manually - set override",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"responseJSON = pm.response.json();\r",
													"let conditionResult = responseJSON.result.conditions;\r",
													"let conditionEntity = responseJSON.result.ntty;\r",
													"let requestMessage = responseJSON.message;\r",
													"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
													"let nttyId = pm.globals.get(\"cdtrNttyId\");\r",
													"let nttyIdSchme = pm.globals.get(\"cdtrNttyIdSchmeNm\");\r",
													"let tenantId = pm.globals.get(\"tenantId\");\r",
													"let targetEntityId = nttyId + nttyIdSchme;\r",
													"\r",
													"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
													"targetRequestMessage = \"1 conditions already exist for the entity\"\r",
													"\r",
													"pm.test(\"Status code is 200\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(\"Result message matches target result message\", function () {\r",
													"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
													"});\r",
													"\r",
													"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
													"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
													"});\r",
													"\r",
													"pm.test(\"Result conditions array contains two conditions\", function () {\r",
													"    pm.expect(conditionResult.length).to.be.eql(2);\r",
													"});\r",
													"\r",
													"let newElement = conditionResult[conditionResult.length - 1];  // the last element is the newly submitted condition\r",
													"\r",
													"pm.test(\"Result condition has a non-empty condId\", function () {\r",
													"    pm.expect(newElement.condId).to.exist.and.not.be.empty;\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
													"    pm.expect(newElement.condTp).to.be.eql(targetConditionResult.condTp);\r",
													"});\r",
													"\r",
													"if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"    pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
													"        pm.expect(newElement.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"    });\r",
													"} else {    // if not, one must have been defaulted\r",
													"    pm.test(\"Result condition has a non-empty incptnDtTm\", function () {\r",
													"        pm.expect(newElement.incptnDtTm).to.exist.and.not.be.empty;\r",
													"    });\r",
													"}\r",
													"\r",
													"if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"    pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
													"        pm.expect(newElement.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"    });\r",
													"} else {    // if not, one must not have been defaulted\r",
													"    pm.test(\"Result condition does not have an xprtnDtTm\", function () {\r",
													"        pm.expect(newElement.xprtnDtTm).to.not.exist;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
													"    pm.expect(newElement.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
													"    pm.expect(newElement.usr).to.be.eql(targetConditionResult.usr);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition has a non-empty creDtTm\", function () {\r",
													"    pm.expect(newElement.creDtTm).to.exist.and.not.be.empty;\r",
													"});\r",
													"\r",
													"// create an array that only includes the perspective descriptions so that we can evaluate them easily\r",
													"let perspectives = newElement.prsptvs.map(({ prsptv }) => prsptv);\r",
													"\r",
													"if (targetConditionResult.prsptv === \"both\") {\r",
													"    pm.test(\"Result prsptv array contains only 2 perspectives\", function () {\r",
													"        pm.expect(newElement.prsptvs.length).to.be.eql(2);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_creditor_by\", \"governed_as_debtor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains both ${JSON.stringify(targetPerspectives)} perspectives`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"} else if (targetConditionResult.prsptv === \"debtor\") {\r",
													"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
													"        pm.expect(newElement.prsptvs.length).to.be.eql(1);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_debtor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"} else if (targetConditionResult.prsptv === \"creditor\") {\r",
													"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
													"        pm.expect(newElement.prsptvs.length).to.be.eql(1);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_creditor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"};\r",
													"\r",
													"for (let i = 0; i < newElement.prsptvs.length; i++) {   // for each perspective\r",
													"    pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} contains a non-empty evtTp array`, function () {\r",
													"        pm.expect(newElement.prsptvs[i].evtTp).to.be.an('array').and.not.be.empty;\r",
													"    });\r",
													"\r",
													"    pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} evtTp array matches submitted condition`, function () {\r",
													"        pm.expect(newElement.prsptvs[i].evtTp).to.include.members(targetConditionResult.evtTp);\r",
													"    });\r",
													"\r",
													"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"        pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} incptnDtTm matches submitted condition`, function () {\r",
													"            pm.expect(newElement.prsptvs[i].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must have been defaulted\r",
													"        pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} incptnDtTm matches created condition incptDtTm`, function () {\r",
													"            pm.expect(newElement.prsptvs[i].incptnDtTm).to.eql(newElement.incptnDtTm);\r",
													"        });\r",
													"    }\r",
													"\r",
													"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"        pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} xprtnDtTm matches submitted condition`, function () {\r",
													"            pm.expect(newElement.prsptvs[i].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must not have been defaulted\r",
													"        pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} does not have an xprtnDtTm`, function () {\r",
													"            pm.expect(newElement.prsptvs[i].xprtnDtTm).to.not.exist;\r",
													"        });\r",
													"    }\r",
													"\r",
													"}\r",
													"\r",
													"pm.test(\"Result condition ntty.id matches submitted condition\", function () {\r",
													"    pm.expect(conditionEntity.id).to.be.eql(targetConditionResult.ntty.id);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"    pm.expect(conditionEntity.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
													"});\r",
													"\r",
													"// Now we want to test that the data in the database matches the submitted data AND the response data\r",
													"\r",
													"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetEntityId, false);;\r",
													"\r",
													"await pm.sendRequest(postRequest, (error, response) => {\r",
													"    if (utils.getLogLevel() === 'DEBUG') {\r",
													"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
													"    }\r",
													"    databaseConditionResult = response.json().data;\r",
													"\r",
													"    if (utils.getLogLevel() === 'DEBUG') {\r",
													"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
													"    }\r",
													"\r",
													"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
													"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
													"\r",
													"    let submittedCondition = graphConditionList.filter(condition => condition._id === `conditions/${newElement.condId}`);\r",
													"\r",
													"    // First we check that the submitted condition matches the database version\r",
													"\r",
													"    pm.test(`Only two conditions for entity [${targetEntityId}] exists in the database`, function () {\r",
													"        pm.expect(graphConditionList.length).to.eql(2);\r",
													"    });\r",
													"\r",
													"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
													"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
													"            pm.expect(submittedCondition[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
													"        });\r",
													"    }\r",
													"\r",
													"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
													"        pm.expect(submittedCondition[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
													"        pm.expect(submittedCondition[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
													"    });\r",
													"\r",
													"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"        pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
													"            pm.expect(submittedCondition[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must have been defaulted\r",
													"        pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
													"            pm.expect(submittedCondition[0].incptnDtTm).to.exist.and.not.be.empty;\r",
													"        });\r",
													"    }\r",
													"\r",
													"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"        pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
													"            pm.expect(submittedCondition[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must not have been defaulted\r",
													"        pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
													"            pm.expect(submittedCondition[0].xprtnDtTm).to.not.exist;\r",
													"        });\r",
													"    }\r",
													"\r",
													"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
													"        pm.expect(submittedCondition[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
													"        pm.expect(submittedCondition[0].ntty.id).to.be.eql(targetConditionResult.ntty.id);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"        pm.expect(submittedCondition[0].ntty.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
													"        pm.expect(submittedCondition[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
													"        pm.expect(submittedCondition[0].usr).to.be.eql(targetConditionResult.usr);\r",
													"    });\r",
													"\r",
													"    let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, submittedCondition[0]._key);\r",
													"\r",
													"    pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
													"        pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database 'governed_as_creditor_by' edge does not exist\", function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
													"    });\r",
													"\r",
													"    // Then we check the previous conditions in the response one-by-one against the database version\r",
													"    let previousConditionsFromResponse = graphConditionList.filter(condition => condition._id != `conditions/${newElement.condId}`);\r",
													"    let previousResponseConditionIds = previousConditionsFromResponse.map(({ condId }) => condId);\r",
													"    let previousConditionsFromDatabase = graphConditionList.filter(condition => condition._id != `conditions/${newElement.condId}`);\r",
													"    let previousDatabaseConditionIds = previousConditionsFromDatabase.map(({ condId }) => condId);\r",
													"\r",
													"    pm.test(`List of previous conditions in response match list of conditions from database`, function () {\r",
													"        pm.expect(previousResponseConditionIds).to.have.members(previousDatabaseConditionIds);\r",
													"    });\r",
													"\r",
													"    pm.test(`Only one previous condition for entity [${targetEntityId}] exists in the reponse`, function () {\r",
													"        pm.expect(previousConditionsFromResponse.length).to.eql(1);\r",
													"    });\r",
													"\r",
													"    pm.test(`Only one previous condition for entity [${targetEntityId}] exists in the database`, function () {\r",
													"        pm.expect(previousConditionsFromDatabase.length).to.eql(1);\r",
													"    });\r",
													"\r",
													"    for (let j = 0; j < previousConditionsFromResponse.length; j++) {\r",
													"\r",
													"        let justOneConditionFromResponse = previousConditionsFromResponse.filter(condition => condition._id === `conditions/${conditionResult[j].condId}`);\r",
													"        let sameConditionFromDatabase = previousConditionsFromDatabase.filter(condition => condition._id === `conditions/${conditionResult[j].condId}`);\r",
													"\r",
													"        for (let i = 0; i < sameConditionFromDatabase[0].evtTp.length; i++) {\r",
													"            pm.test(`Database condition.evtTp contains ${sameConditionFromDatabase[0].evtTp[i]}`, function () {\r",
													"                pm.expect(justOneConditionFromResponse[0].evtTp).to.include.members([sameConditionFromDatabase[0].evtTp[i]]);\r",
													"            });\r",
													"        }\r",
													"\r",
													"        pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
													"            pm.expect(justOneConditionFromResponse[0].condTp).to.be.eql(sameConditionFromDatabase[0].condTp);\r",
													"        });\r",
													"\r",
													"        pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
													"            pm.expect(justOneConditionFromResponse[0].prsptv).to.be.eql(sameConditionFromDatabase[0].prsptv);\r",
													"        });\r",
													"\r",
													"        if (sameConditionFromDatabase[0].incptnDtTm) { // was an inception date specified?\r",
													"            pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
													"                pm.expect(justOneConditionFromResponse[0].incptnDtTm).to.be.eql(sameConditionFromDatabase[0].incptnDtTm);\r",
													"            });\r",
													"        } else {    // if not, one must have been defaulted\r",
													"            pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
													"                pm.expect(justOneConditionFromResponse[0].incptnDtTm).to.exist.and.not.be.empty;\r",
													"            });\r",
													"        }\r",
													"\r",
													"        if (sameConditionFromDatabase[0].xprtnDtTm) { // was an expiration date specified?\r",
													"            pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
													"                pm.expect(justOneConditionFromResponse[0].xprtnDtTm).to.be.eql(sameConditionFromDatabase[0].xprtnDtTm);\r",
													"            });\r",
													"        } else {    // if not, one must not have been defaulted\r",
													"            pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
													"                pm.expect(justOneConditionFromResponse[0].xprtnDtTm).to.not.exist;\r",
													"            });\r",
													"        }\r",
													"\r",
													"        pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
													"            pm.expect(justOneConditionFromResponse[0].condRsn).to.be.eql(sameConditionFromDatabase[0].condRsn);\r",
													"        });\r",
													"\r",
													"        pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
													"            pm.expect(justOneConditionFromResponse[0].ntty.id).to.be.eql(sameConditionFromDatabase[0].ntty.id);\r",
													"        });\r",
													"\r",
													"        pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"            pm.expect(justOneConditionFromResponse[0].ntty.schmeNm.prtry).to.be.eql(sameConditionFromDatabase[0].ntty.schmeNm.prtry);\r",
													"        });\r",
													"\r",
													"        pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
													"            pm.expect(justOneConditionFromResponse[0].forceCret).to.be.eql(sameConditionFromDatabase[0].forceCret);\r",
													"        });\r",
													"\r",
													"        pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
													"            pm.expect(justOneConditionFromResponse[0].usr).to.be.eql(sameConditionFromDatabase[0].usr);\r",
													"        });\r",
													"\r",
													"        let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, justOneConditionFromResponse[0]._key);\r",
													"\r",
													"        pm.test(`Database \"governed_as_debtor_by\" edge exists`, function () {\r",
													"            pm.expect(edgeList).to.include.members([\"governed_as_debtor_by\"]);\r",
													"        });\r",
													"\r",
													"        pm.test(\"Database 'governed_as_creditor_by' edge does not exist\", function () {\r",
													"            pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_by\"]);\r",
													"        });\r",
													"\r",
													"        pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
													"            pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
													"        });\r",
													"\r",
													"        pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
													"            pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
													"        });\r",
													"    }\r",
													"\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"// Retrieve the created pacs.008 message\r",
													"const submittedPacs008Message = utils.addTenantId(null, JSON.parse(pm.globals.get(\"pacs008\")));\r",
													"\r",
													"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
													"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
													"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
													"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
													"\r",
													"// Load deconstructued identifier variables into global variables\r",
													"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
													"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
													"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
													"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
													"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
													"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
													"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
													"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
													"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
													"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
													"\r",
													"xprtnDtTm = utils.timestampAtTMinus(-10, \"m\");\r",
													"\r",
													"// Set up the condition\r",
													"\r",
													"console.log(`Override incepts at ${utils.getTimestampNow()}`);\r",
													"\r",
													"messageBody = {\r",
													"  \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09\",\"pacs.008.001.10\",\"pacs.002.001.12\"],\r",
													"  \"condTp\":\"override\",\r",
													"  \"prsptv\":\"debtor\",\r",
													"  \"xprtnDtTm\": xprtnDtTm,\r",
													"  \"condRsn\":\"Default Test Condition\",\r",
													"  \"ntty\":\r",
													"  {\r",
													"    \"id\": `${cdtrNttyId.id}`,\r",
													"    \"schmeNm\":\r",
													"    {\r",
													"      \"prtry\":\"TAZAMA_EID\"\r",
													"    }\r",
													"  },\r",
													"  \"forceCret\":true,\r",
													"  \"usr\":\"POSTMAN\"\r",
													"}\r",
													"\r",
													"// Set up body variables\r",
													"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
													"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
											"host": [
												"{{tazamaAdminUrl}}{{path-admin-api-version}}"
											],
											"path": [
												"{{path-entity-condition}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('debtorId');\r",
													"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
													"let cdtrId = pm.globals.get('creditorId');\r",
													"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
													"\r",
													"// Hacky workaround for testing the timeout of the submission of the pacs002 after this test\r",
													"pm.globals.set('responseTimedOut', true);\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ cdtrId,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ cdtrAcctId,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ 'fsp001',\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Post pacs.002 to TMS API - TIMEOUT EXPECTED",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"// Hacky workaround for testing the timeout of the submission of the pacs002\r",
													"pm.globals.set('responseTimedOut', false);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`No alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													"\r",
													"pm.test(`Request does not complete within specified timeout of ${pm.globals.get('timeoutLimit')}`, function () {\r",
													"    pm.expect(pm.response.responseTime).to.be.above(4000);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"NALT\";\r",
													"const expectedBlockingOutcome = \"none\";\r",
													"const expectedReviewFlag = false;\r",
													"const expectedTypologyAlert = false;\r",
													"const expectedTypologyInterdiction = false;\r",
													"const expectedResponseTimedOut = true;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });\r",
													"\r",
													"pm.test(`No response received at EFRuP interdiction service before timeout`, function () {\r",
													"        pm.expect(pm.globals.get('responseTimedOut')).to.be.eql(expectedResponseTimedOut);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('debtorId');\r",
													"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
													"let cdtrId = pm.globals.get('creditorId');\r",
													"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
													"\r",
													"// Hacky workaround for testing the timeout of the submission of the pacs002 after this test\r",
													"pm.globals.set('responseTimedOut', true);\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ cdtrId,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ cdtrAcctId,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ 'fsp001',\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Post pacs.002 to TMS API - TIMEOUT EXPECTED",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"// Hacky workaround for testing the timeout of the submission of the pacs002\r",
													"pm.globals.set('responseTimedOut', false);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`Alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													"\r",
													"pm.test(`Request does not complete within specified timeout of ${pm.globals.get('timeoutLimit')}`, function () {\r",
													"    pm.expect(pm.response.responseTime).to.be.above(4000);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"ALRT\";\r",
													"const expectedBlockingOutcome = \"none\";\r",
													"const expectedReviewFlag = true;\r",
													"const expectedTypologyAlert = true;\r",
													"const expectedTypologyInterdiction = false;\r",
													"const expectedResponseTimedOut = true;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });\r",
													"\r",
													"pm.test(`No response received at EFRuP interdiction service before timeout`, function () {\r",
													"        pm.expect(pm.globals.get('responseTimedOut')).to.be.eql(expectedResponseTimedOut);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('debtorId');\r",
													"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
													"let cdtrId = pm.globals.get('creditorId');\r",
													"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
													"\r",
													"// Hacky workaround for testing the timeout of the submission of the pacs002 after this test\r",
													"pm.globals.set('responseTimedOut', true);\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ cdtrId,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ cdtrAcctId,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ 'fsp001',\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Post pacs.002 to TMS API - TIMEOUT EXPECTED",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"// Hacky workaround for testing the timeout of the submission of the pacs002\r",
													"pm.globals.set('responseTimedOut', false);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`No alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													"\r",
													"pm.test(`Request does not complete within specified timeout of ${pm.globals.get('timeoutLimit')}`, function () {\r",
													"    pm.expect(pm.response.responseTime).to.be.above(4000);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"ALRT\";\r",
													"const expectedBlockingOutcome = \"none\";\r",
													"const expectedReviewFlag = true;\r",
													"const expectedTypologyAlert = true;\r",
													"const expectedTypologyInterdiction = true;\r",
													"const expectedResponseTimedOut = true;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });\r",
													"\r",
													"pm.test(`No response received at EFRuP interdiction service before timeout`, function () {\r",
													"        pm.expect(pm.globals.get('responseTimedOut')).to.be.eql(expectedResponseTimedOut);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "interdiction with override",
							"item": [
								{
									"name": "Before override",
									"item": [
										{
											"name": "Transaction 1 - Post pacs.008 to TMS API",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
															"\r",
															"let dbtrId = pm.globals.get('debtorId');\r",
															"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
															"let cdtrId = pm.globals.get('creditorId');\r",
															"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
															"\r",
															"// Hacky workaround for testing the timeout of the submission of the pacs002 after this test\r",
															"pm.globals.set('responseTimedOut', true);\r",
															"\r",
															"// ## Set up transaction eco-system\r",
															"\r",
															"messageSet = utils.createTransactionSetInMemory(\r",
															"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
															"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
															"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
															"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
															"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
															"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
															"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
															"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
															"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
															"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
															"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
															"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
															"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
															"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
															"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
															"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
															"    /* Description - null defaults random UUID ---------------------- */ null,\r",
															"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
															"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
															"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
															"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
															"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
															"    );\r",
															"\r",
															"let messageBody = pm.globals.get('pacs008');\r",
															"pm.globals.set('pacs008Stash', messageBody);\r",
															"pm.globals.set('messageBody', messageBody);"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{{messageBody}}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
													"host": [
														"{{tazamaTMSUrl}}{{path-tms-api-version}}"
													],
													"path": [
														"{{path-pacs008}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 1 - Post pacs.002 to TMS API",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"let messageBody = pm.globals.get('pacs002');\r",
															"pm.globals.set('messageBody', messageBody);"
														],
														"type": "text/javascript",
														"packages": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{{pacs002}}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs002}}",
													"host": [
														"{{tazamaTMSUrl}}{{path-tms-api-version}}"
													],
													"path": [
														"{{path-pacs002}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 1 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
														],
														"type": "text/javascript",
														"packages": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"const resJson = pm.response.json();\r",
															"\r",
															"const rulesPerTypologyCount = [3];\r",
															"const totalExpectedTypologies = 1;\r",
															"const expectedAlertStatus = \"NALT\";\r",
															"const expectedBlockingOutcome = \"none\";\r",
															"const expectedReviewFlag = false;\r",
															"const expectedTypologyAlert = false;\r",
															"const expectedTypologyInterdiction = false;\r",
															"\r",
															"const interdictionTypologies = [\r",
															"  \"999\"\r",
															"];\r",
															"const ruleDescriptions = {\r",
															"  \"901\": \"Number of outgoing transactions - debtor\",\r",
															"  \"902\": \"Number of incoming transactions - creditor\",\r",
															"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
															"}\r",
															"const typologyDescriptions = {\r",
															"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
															"}\r",
															"\r",
															"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
															"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
															"\r",
															"typologyCount = typologyResultsUnique.count();\r",
															"ruleCount = ruleResultsUnique.count();\r",
															"\r",
															"foundEFRuP = false;\r",
															"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
															"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
															"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
															"        foundEFRuP = true;\r",
															"    }\r",
															"}\r",
															"\r",
															"ruleWeightingTotal = 0;\r",
															"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
															"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
															"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
															"    }    \r",
															"}\r",
															"\r",
															"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
															"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
															"});\r",
															"\r",
															"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
															"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
															"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
															"    pm.expect(foundEFRuP).to.be.true;\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
															"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
															"});\r",
															"\r",
															"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedReviewFlag) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
															"    });\r",
															"} else {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
															"    });\r",
															"}\r",
															"\r",
															"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
															"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
															"    });"
														],
														"type": "text/javascript",
														"packages": {}
													}
												}
											],
											"request": {
												"auth": {
													"type": "bearer",
													"bearer": [
														{
															"key": "token",
															"value": "{{auth-token}}",
															"type": "string"
														}
													]
												},
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
													"host": [
														"{{arangoUrl}}"
													],
													"path": [
														"_db",
														"{{db_results}}",
														"_api",
														"cursor"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 2 - Post pacs.008 to TMS API",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
															"\r",
															"let dbtrId = pm.globals.get('debtorId');\r",
															"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
															"let cdtrId = pm.globals.get('creditorId');\r",
															"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
															"\r",
															"// Hacky workaround for testing the timeout of the submission of the pacs002 after this test\r",
															"pm.globals.set('responseTimedOut', true);\r",
															"\r",
															"// ## Set up transaction eco-system\r",
															"\r",
															"messageSet = utils.createTransactionSetInMemory(\r",
															"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
															"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
															"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
															"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
															"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
															"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
															"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
															"    /* Creditor ID - null defaults random UUID ---------------------- */ cdtrId,\r",
															"    /* Creditor Account ID - null defaults random UUID -------------- */ cdtrAcctId,\r",
															"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
															"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
															"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
															"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
															"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
															"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
															"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
															"    /* Description - null defaults random UUID ---------------------- */ null,\r",
															"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
															"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
															"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
															"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
															"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
															"    );\r",
															"\r",
															"let messageBody = pm.globals.get('pacs008');\r",
															"pm.globals.set('messageBody', messageBody);"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{{messageBody}}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
													"host": [
														"{{tazamaTMSUrl}}{{path-tms-api-version}}"
													],
													"path": [
														"{{path-pacs008}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 2 - Post pacs.002 to TMS API - TIMEOUT EXPECTED",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
															"const responseDestination = `relay-service-nats-tp`; // The NATS subject for the output retrieval\r",
															"const awaitReply = true; // Hold the phone for a callback\r",
															"\r",
															"let messageBody = pm.globals.get('pacs002');\r",
															"pm.globals.set('messageBody', messageBody);\r",
															"pm.globals.set('endpoint', endpoint);\r",
															"pm.globals.set('responseDestination', responseDestination);\r",
															"pm.globals.set('awaitReply', awaitReply);"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"const resJson = pm.response.json();\r",
															"console.log(resJson);\r",
															"\r",
															"// Hacky workaround for testing the timeout of the submission of the pacs002\r",
															"pm.globals.set('responseTimedOut', false);\r",
															"\r",
															"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});\r",
															"\r",
															"pm.test(`Interdiction alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
															"    pm.expect(resJson.edResponse.report.status).to.be.eql('ALRT');\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
													"host": [
														"{{natsUrl}}"
													],
													"path": [
														"{{nats-path-tms-api}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 2 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"const resJson = pm.response.json();\r",
															"\r",
															"const rulesPerTypologyCount = [3];\r",
															"const totalExpectedTypologies = 1;\r",
															"const expectedAlertStatus = \"ALRT\";\r",
															"const expectedBlockingOutcome = \"none\";\r",
															"const expectedReviewFlag = true;\r",
															"const expectedTypologyAlert = true;\r",
															"const expectedTypologyInterdiction = false;\r",
															"const expectedResponseTimedOut = true;\r",
															"\r",
															"const interdictionTypologies = [\r",
															"  \"999\"\r",
															"];\r",
															"const ruleDescriptions = {\r",
															"  \"901\": \"Number of outgoing transactions - debtor\",\r",
															"  \"902\": \"Number of incoming transactions - creditor\",\r",
															"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
															"}\r",
															"const typologyDescriptions = {\r",
															"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
															"}\r",
															"\r",
															"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
															"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
															"\r",
															"typologyCount = typologyResultsUnique.count();\r",
															"ruleCount = ruleResultsUnique.count();\r",
															"\r",
															"foundEFRuP = false;\r",
															"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
															"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
															"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
															"        foundEFRuP = true;\r",
															"    }\r",
															"}\r",
															"\r",
															"ruleWeightingTotal = 0;\r",
															"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
															"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
															"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
															"    }    \r",
															"}\r",
															"\r",
															"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
															"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
															"});\r",
															"\r",
															"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
															"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
															"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
															"    pm.expect(foundEFRuP).to.be.true;\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
															"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
															"});\r",
															"\r",
															"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedReviewFlag) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
															"    });\r",
															"} else {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
															"    });\r",
															"}\r",
															"\r",
															"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
															"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
															"    });\r",
															"\r",
															"pm.test(`No response received at EFRuP interdiction service before timeout`, function () {\r",
															"        pm.expect(pm.globals.get('responseTimedOut')).to.be.eql(expectedResponseTimedOut);\r",
															"    });"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"auth": {
													"type": "bearer",
													"bearer": [
														{
															"key": "token",
															"value": "{{auth-token}}",
															"type": "string"
														}
													]
												},
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
													"host": [
														"{{arangoUrl}}"
													],
													"path": [
														"_db",
														"{{db_results}}",
														"_api",
														"cursor"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 3 - Post pacs.008 to TMS API",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
															"\r",
															"let dbtrId = pm.globals.get('debtorId');\r",
															"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
															"let cdtrId = pm.globals.get('creditorId');\r",
															"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
															"\r",
															"// Hacky workaround for testing the timeout of the submission of the pacs002 after this test\r",
															"pm.globals.set('responseTimedOut', true);\r",
															"\r",
															"// ## Set up transaction eco-system\r",
															"\r",
															"messageSet = utils.createTransactionSetInMemory(\r",
															"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
															"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
															"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
															"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
															"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
															"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
															"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
															"    /* Creditor ID - null defaults random UUID ---------------------- */ cdtrId,\r",
															"    /* Creditor Account ID - null defaults random UUID -------------- */ cdtrAcctId,\r",
															"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
															"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
															"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
															"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
															"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
															"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
															"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
															"    /* Description - null defaults random UUID ---------------------- */ null,\r",
															"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
															"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
															"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
															"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
															"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
															"    );\r",
															"\r",
															"let messageBody = pm.globals.get('pacs008');\r",
															"pm.globals.set('messageBody', messageBody);"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{{messageBody}}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
													"host": [
														"{{tazamaTMSUrl}}{{path-tms-api-version}}"
													],
													"path": [
														"{{path-pacs008}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 3 - Post pacs.002 to TMS API - NO TIMEOUT EXPECTED",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
															"const responseDestination = `relay-service-nats-tp`; // The NATS subject for the output retrieval\r",
															"const awaitReply = true; // Hold the phone for a callback\r",
															"\r",
															"let messageBody = pm.globals.get('pacs002');\r",
															"pm.globals.set('messageBody', messageBody);\r",
															"pm.globals.set('endpoint', endpoint);\r",
															"pm.globals.set('responseDestination', responseDestination);\r",
															"pm.globals.set('awaitReply', awaitReply);"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"const resJson = pm.response.json();\r",
															"console.log(resJson);\r",
															"\r",
															"// Hacky workaround for testing the timeout of the submission of the pacs002\r",
															"pm.globals.set('responseTimedOut', false);\r",
															"\r",
															"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});\r",
															"\r",
															"pm.test(`Interdiction alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
															"    pm.expect(resJson.edResponse.report.status).to.be.eql('ALRT');\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
													"host": [
														"{{natsUrl}}"
													],
													"path": [
														"{{nats-path-tms-api}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 3 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"const resJson = pm.response.json();\r",
															"\r",
															"const rulesPerTypologyCount = [3];\r",
															"const totalExpectedTypologies = 1;\r",
															"const expectedAlertStatus = \"ALRT\";\r",
															"const expectedBlockingOutcome = \"none\";\r",
															"const expectedReviewFlag = true;\r",
															"const expectedTypologyAlert = true;\r",
															"const expectedTypologyInterdiction = false;\r",
															"const expectedResponseTimedOut = true;\r",
															"\r",
															"const interdictionTypologies = [\r",
															"  \"999\"\r",
															"];\r",
															"const ruleDescriptions = {\r",
															"  \"901\": \"Number of outgoing transactions - debtor\",\r",
															"  \"902\": \"Number of incoming transactions - creditor\",\r",
															"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
															"}\r",
															"const typologyDescriptions = {\r",
															"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
															"}\r",
															"\r",
															"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
															"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
															"\r",
															"typologyCount = typologyResultsUnique.count();\r",
															"ruleCount = ruleResultsUnique.count();\r",
															"\r",
															"foundEFRuP = false;\r",
															"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
															"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
															"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
															"        foundEFRuP = true;\r",
															"    }\r",
															"}\r",
															"\r",
															"ruleWeightingTotal = 0;\r",
															"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
															"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
															"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
															"    }    \r",
															"}\r",
															"\r",
															"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
															"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
															"});\r",
															"\r",
															"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
															"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
															"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
															"    pm.expect(foundEFRuP).to.be.true;\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
															"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
															"});\r",
															"\r",
															"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedReviewFlag) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
															"    });\r",
															"} else {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
															"    });\r",
															"}\r",
															"\r",
															"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
															"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
															"    });\r",
															"\r",
															"pm.test(`Response received at EFRuP interdiction service before timeout`, function () {\r",
															"        pm.expect(pm.globals.get('responseTimedOut')).to.be.eql(expectedResponseTimedOut);\r",
															"    });"
														],
														"type": "text/javascript",
														"packages": {}
													}
												}
											],
											"request": {
												"auth": {
													"type": "bearer",
													"bearer": [
														{
															"key": "token",
															"value": "{{auth-token}}",
															"type": "string"
														}
													]
												},
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
													"host": [
														"{{arangoUrl}}"
													],
													"path": [
														"_db",
														"{{db_results}}",
														"_api",
														"cursor"
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "After override",
									"item": [
										{
											"name": "Create New Entity Condition Manually - Existing debtor",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"responseJSON = pm.response.json();\r",
															"let conditionResult = responseJSON.result.conditions;\r",
															"let conditionEntity = responseJSON.result.ntty;\r",
															"let requestMessage = responseJSON.message;\r",
															"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
															"let nttyId = pm.globals.get(\"cdtrNttyId\");\r",
															"let nttyIdSchme = pm.globals.get(\"cdtrNttyIdSchmeNm\");\r",
															"let tenantId = pm.globals.get(\"tenantId\");\r",
															"let targetEntityId = nttyId + nttyIdSchme;\r",
															"\r",
															"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
															"targetRequestMessage = \"New condition was saved successfully.\"\r",
															"\r",
															"pm.test(\"Status code is 200\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});\r",
															"\r",
															"pm.test(\"Result message matches target result message\", function () {\r",
															"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
															"});\r",
															"\r",
															"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
															"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
															"});\r",
															"\r",
															"pm.test(\"Result conditions array only contains a single condition\", function () {\r",
															"    pm.expect(conditionResult.length).to.be.eql(1);\r",
															"});\r",
															"\r",
															"let firstElement = conditionResult[0];\r",
															"\r",
															"pm.test(\"Result condition has a non-empty condId\", function () {\r",
															"    pm.expect(firstElement.condId).to.exist.and.not.be.empty;\r",
															"});\r",
															"\r",
															"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
															"    pm.expect(firstElement.condTp).to.be.eql(targetConditionResult.condTp);\r",
															"});\r",
															"\r",
															"if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
															"    pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
															"        pm.expect(firstElement.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
															"    });\r",
															"} else {    // if not, one must have been defaulted\r",
															"    pm.test(\"Result condition has a non-empty incptnDtTm\", function () {\r",
															"        pm.expect(firstElement.incptnDtTm).to.exist.and.not.be.empty;\r",
															"    });\r",
															"}\r",
															"\r",
															"if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
															"    pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
															"        pm.expect(firstElement.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
															"    });\r",
															"} else {    // if not, one must not have been defaulted\r",
															"    pm.test(\"Result condition does not have an xprtnDtTm\", function () {\r",
															"        pm.expect(firstElement.xprtnDtTm).to.not.exist;\r",
															"    });\r",
															"}\r",
															"\r",
															"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
															"    pm.expect(firstElement.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
															"});\r",
															"\r",
															"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
															"    pm.expect(firstElement.usr).to.be.eql(targetConditionResult.usr);\r",
															"});\r",
															"\r",
															"pm.test(\"Result condition has a non-empty creDtTm\", function () {\r",
															"    pm.expect(firstElement.creDtTm).to.exist.and.not.be.empty;\r",
															"});\r",
															"\r",
															"// create an array that only includes the perspective descriptions so that we can evaluate them easily\r",
															"let perspectives = firstElement.prsptvs.map(({ prsptv }) => prsptv);\r",
															"\r",
															"if (targetConditionResult.prsptv === \"both\") {\r",
															"    pm.test(\"Result prsptv array contains only 2 perspectives\", function () {\r",
															"        pm.expect(firstElement.prsptvs.length).to.be.eql(2);\r",
															"    });\r",
															"\r",
															"    let targetPerspectives = [\"governed_as_creditor_by\", \"governed_as_debtor_by\"];\r",
															"\r",
															"    pm.test(`Result prsptv array contains both ${JSON.stringify(targetPerspectives)} perspectives`, function () {\r",
															"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
															"    });\r",
															"\r",
															"} else if (targetConditionResult.prsptv === \"debtor\") {\r",
															"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
															"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
															"    });\r",
															"\r",
															"    let targetPerspectives = [\"governed_as_debtor_by\"];\r",
															"\r",
															"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
															"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
															"    });\r",
															"\r",
															"} else if (targetConditionResult.prsptv === \"creditor\") {\r",
															"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
															"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
															"    });\r",
															"\r",
															"    let targetPerspectives = [\"governed_as_creditor_by\"];\r",
															"\r",
															"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
															"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
															"    });\r",
															"\r",
															"};\r",
															"\r",
															"for (let i = 0; i < firstElement.prsptvs.length; i++) {   // for each perspective\r",
															"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} contains a non-empty evtTp array`, function () {\r",
															"        pm.expect(firstElement.prsptvs[i].evtTp).to.be.an('array').and.not.be.empty;\r",
															"    });\r",
															"\r",
															"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} evtTp array matches submitted condition`, function () {\r",
															"        pm.expect(firstElement.prsptvs[i].evtTp).to.include.members(targetConditionResult.evtTp);\r",
															"    });\r",
															"\r",
															"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
															"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches submitted condition`, function () {\r",
															"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
															"        });\r",
															"    } else {    // if not, one must have been defaulted\r",
															"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches created condition incptDtTm`, function () {\r",
															"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.eql(firstElement.incptnDtTm);\r",
															"        });\r",
															"    }\r",
															"\r",
															"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
															"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} xprtnDtTm matches submitted condition`, function () {\r",
															"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
															"        });\r",
															"    } else {    // if not, one must not have been defaulted\r",
															"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} does not have an xprtnDtTm`, function () {\r",
															"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.not.exist;\r",
															"        });\r",
															"    }\r",
															"\r",
															"}\r",
															"\r",
															"pm.test(\"Result condition ntty.id matches submitted condition\", function () {\r",
															"    pm.expect(conditionEntity.id).to.be.eql(targetConditionResult.ntty.id);\r",
															"});\r",
															"\r",
															"pm.test(\"Result condition ntty.schmeNm.prtry matches submitted condition\", function () {\r",
															"    pm.expect(conditionEntity.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
															"});\r",
															"\r",
															"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetEntityId, false);;\r",
															"\r",
															"await pm.sendRequest(postRequest, (error, response) => {\r",
															"    if (utils.getLogLevel() === 'DEBUG') {\r",
															"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
															"    }\r",
															"    databaseConditionResult = response.json().data;\r",
															"\r",
															"    if (utils.getLogLevel() === 'DEBUG') {\r",
															"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
															"    }\r",
															"\r",
															"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
															"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
															"\r",
															"    pm.test(`Only one condition for entity [${targetEntityId}] exists in the database`, function () {\r",
															"        pm.expect(graphConditionList.length).to.eql(1);\r",
															"    });\r",
															"\r",
															"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
															"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
															"            pm.expect(conditionGraph.v[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
															"        });\r",
															"    }\r",
															"\r",
															"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
															"        pm.expect(conditionGraph.v[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
															"    });\r",
															"\r",
															"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
															"        pm.expect(conditionGraph.v[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
															"    });\r",
															"\r",
															"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
															"        pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
															"            pm.expect(conditionGraph.v[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
															"        });\r",
															"    } else {    // if not, one must have been defaulted\r",
															"        pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
															"            pm.expect(conditionGraph.v[0].incptnDtTm).to.exist.and.not.be.empty;\r",
															"        });\r",
															"    }\r",
															"\r",
															"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
															"        pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
															"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
															"        });\r",
															"    } else {    // if not, one must not have been defaulted\r",
															"        pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
															"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.not.exist;\r",
															"        });\r",
															"    }\r",
															"\r",
															"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
															"        pm.expect(conditionGraph.v[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
															"    });\r",
															"\r",
															"    pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
															"        pm.expect(conditionGraph.v[0].ntty.id).to.be.eql(targetConditionResult.ntty.id);\r",
															"    });\r",
															"\r",
															"    pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
															"        pm.expect(conditionGraph.v[0].ntty.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
															"    });\r",
															"\r",
															"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
															"        pm.expect(conditionGraph.v[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
															"    });\r",
															"\r",
															"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
															"        pm.expect(conditionGraph.v[0].usr).to.be.eql(targetConditionResult.usr);\r",
															"    });\r",
															"\r",
															"    let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, conditionGraph.v[0]._key);\r",
															"\r",
															"    pm.test(`Database \"governed_as_debtor_by\" edge does not exist`, function () {\r",
															"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_by\"]);\r",
															"    });\r",
															"\r",
															"    pm.test(\"Database 'governed_as_creditor_by' edge exists\", function () {\r",
															"        pm.expect(edgeList).to.include.members([\"governed_as_creditor_by\"]);\r",
															"    });\r",
															"\r",
															"    pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
															"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
															"    });\r",
															"\r",
															"    pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
															"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
															"    });\r",
															"\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
															"\r",
															"// Obliterate the current contents of the global variables\r",
															"// Retrieve the created pacs.008 message\r",
															"\r",
															"const submittedPacs008Message = JSON.parse(pm.globals.get('pacs008Stash'));\r",
															"pm.globals.set('pacs008', pm.globals.get('pacs008Stash'));\r",
															"\r",
															"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
															"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
															"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
															"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
															"\r",
															"// Load deconstructued identifier variables into global variables\r",
															"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
															"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
															"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
															"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
															"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
															"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
															"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
															"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
															"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
															"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
															"\r",
															"xprtnDtTm = utils.timestampAtTMinus(-10, \"m\");\r",
															"\r",
															"// Set up the condition\r",
															"\r",
															"console.log(`Override incepts at ${utils.getTimestampNow()}`);\r",
															"\r",
															"messageBody = {\r",
															"  \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09\",\"pacs.008.001.10\",\"pacs.002.001.12\"],\r",
															"  \"condTp\":\"override\",\r",
															"  \"prsptv\":\"creditor\",\r",
															"  \"xprtnDtTm\": xprtnDtTm,\r",
															"  \"condRsn\":\"Default Test Condition\",\r",
															"  \"ntty\":\r",
															"  {\r",
															"    \"id\": `${cdtrNttyId.id}`,\r",
															"    \"schmeNm\":\r",
															"    {\r",
															"      \"prtry\":\"TAZAMA_EID\"\r",
															"    }\r",
															"  },\r",
															"  \"forceCret\":true,\r",
															"  \"usr\":\"POSTMAN\"\r",
															"}\r",
															"\r",
															"// Set up body variables\r",
															"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
															"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{{messageBody}}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
													"host": [
														"{{tazamaAdminUrl}}{{path-admin-api-version}}"
													],
													"path": [
														"{{path-entity-condition}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 4 - Post pacs.008 to TMS API",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
															"\r",
															"let dbtrId = pm.globals.get('debtorId');\r",
															"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
															"let cdtrId = pm.globals.get('creditorId');\r",
															"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
															"\r",
															"// Hacky workaround for testing the timeout of the submission of the pacs002 after this test\r",
															"pm.globals.set('responseTimedOut', true);\r",
															"\r",
															"// ## Set up transaction eco-system\r",
															"\r",
															"messageSet = utils.createTransactionSetInMemory(\r",
															"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
															"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
															"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
															"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
															"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
															"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
															"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
															"    /* Creditor ID - null defaults random UUID ---------------------- */ cdtrId,\r",
															"    /* Creditor Account ID - null defaults random UUID -------------- */ cdtrAcctId,\r",
															"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
															"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
															"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
															"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
															"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
															"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
															"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
															"    /* Description - null defaults random UUID ---------------------- */ null,\r",
															"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
															"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
															"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
															"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
															"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
															"    );\r",
															"\r",
															"let messageBody = pm.globals.get('pacs008');\r",
															"pm.globals.set('messageBody', messageBody);"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{{messageBody}}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
													"host": [
														"{{tazamaTMSUrl}}{{path-tms-api-version}}"
													],
													"path": [
														"{{path-pacs008}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 4 - Post pacs.002 to TMS API - NO TIMEOUT EXPECTED",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
															"const responseDestination = `relay-service-nats-tp`; // The NATS subject for the output retrieval\r",
															"const awaitReply = true; // Hold the phone for a callback\r",
															"\r",
															"let messageBody = pm.globals.get('pacs002');\r",
															"pm.globals.set('messageBody', messageBody);\r",
															"pm.globals.set('endpoint', endpoint);\r",
															"pm.globals.set('responseDestination', responseDestination);\r",
															"pm.globals.set('awaitReply', awaitReply);\r",
															""
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"const resJson = pm.response.json();\r",
															"console.log(resJson);\r",
															"\r",
															"// Hacky workaround for testing the timeout of the submission of the pacs002\r",
															"pm.globals.set('responseTimedOut', false);\r",
															"\r",
															"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});\r",
															"\r",
															"pm.test(`No alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
															"    pm.expect(resJson.edResponse.typologyResult.review).to.be.true;\r",
															"});\r",
															"\r",
															"pm.test(`Request completes within specified timeout of ${pm.globals.get('timeoutLimit')}`, function () {\r",
															"    pm.expect(pm.response.responseTime).to.be.below(4000);\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
													"host": [
														"{{natsUrl}}"
													],
													"path": [
														"{{nats-path-tms-api}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 4 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"const resJson = pm.response.json();\r",
															"\r",
															"const rulesPerTypologyCount = [3];\r",
															"const totalExpectedTypologies = 1;\r",
															"const expectedAlertStatus = \"ALRT\";\r",
															"const expectedBlockingOutcome = \"none\";\r",
															"const expectedReviewFlag = true;\r",
															"const expectedTypologyAlert = true;\r",
															"const expectedTypologyInterdiction = true;\r",
															"const expectedResponseTimedOut = false;\r",
															"\r",
															"const interdictionTypologies = [\r",
															"  \"999\"\r",
															"];\r",
															"const ruleDescriptions = {\r",
															"  \"901\": \"Number of outgoing transactions - debtor\",\r",
															"  \"902\": \"Number of incoming transactions - creditor\",\r",
															"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
															"}\r",
															"const typologyDescriptions = {\r",
															"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
															"}\r",
															"\r",
															"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
															"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
															"\r",
															"typologyCount = typologyResultsUnique.count();\r",
															"ruleCount = ruleResultsUnique.count();\r",
															"\r",
															"foundEFRuP = false;\r",
															"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
															"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
															"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
															"        foundEFRuP = true;\r",
															"    }\r",
															"}\r",
															"\r",
															"ruleWeightingTotal = 0;\r",
															"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
															"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
															"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
															"    }    \r",
															"}\r",
															"\r",
															"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
															"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
															"});\r",
															"\r",
															"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
															"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
															"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
															"    pm.expect(foundEFRuP).to.be.true;\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
															"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
															"});\r",
															"\r",
															"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedReviewFlag) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
															"    });\r",
															"} else {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
															"    });\r",
															"}\r",
															"\r",
															"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
															"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
															"    });\r",
															"\r",
															"pm.test(`No response received at EFRuP interdiction service before timeout`, function () {\r",
															"        pm.expect(pm.globals.get('responseTimedOut')).to.be.eql(expectedResponseTimedOut);\r",
															"    });"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"auth": {
													"type": "bearer",
													"bearer": [
														{
															"key": "token",
															"value": "{{auth-token}}",
															"type": "string"
														}
													]
												},
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
													"host": [
														"{{arangoUrl}}"
													],
													"path": [
														"_db",
														"{{db_results}}",
														"_api",
														"cursor"
													]
												}
											},
											"response": []
										}
									]
								}
							]
						}
					]
				},
				{
					"name": "cdtrId - perspective=creditor",
					"item": [
						{
							"name": "non-overridable block",
							"item": [
								{
									"name": "Create New Entity Condition Manually - Unknown creditor entity",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"responseJSON = pm.response.json();\r",
													"let conditionResult = responseJSON.result.conditions;\r",
													"let conditionEntity = responseJSON.result.ntty;\r",
													"let requestMessage = responseJSON.message;\r",
													"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
													"let nttyId = pm.globals.get(\"cdtrNttyId\");\r",
													"let nttyIdSchme = pm.globals.get(\"cdtrNttyIdSchmeNm\");\r",
													"let tenantId = pm.globals.get(\"tenantId\");\r",
													"let targetEntityId = nttyId + nttyIdSchme;\r",
													"\r",
													"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
													"targetRequestMessage = \"New condition was saved successfully.\"\r",
													"\r",
													"pm.test(\"Status code is 200\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(\"Result message matches target result message\", function () {\r",
													"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
													"});\r",
													"\r",
													"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
													"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
													"});\r",
													"\r",
													"pm.test(\"Result conditions array only contains a single condition\", function () {\r",
													"    pm.expect(conditionResult.length).to.be.eql(1);\r",
													"});\r",
													"\r",
													"let firstElement = conditionResult[0];\r",
													"\r",
													"pm.test(\"Result condition has a non-empty condId\", function () {\r",
													"    pm.expect(firstElement.condId).to.exist.and.not.be.empty;\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.condTp).to.be.eql(targetConditionResult.condTp);\r",
													"});\r",
													"\r",
													"if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"    pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
													"        pm.expect(firstElement.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"    });\r",
													"} else {    // if not, one must have been defaulted\r",
													"    pm.test(\"Result condition has a non-empty incptnDtTm\", function () {\r",
													"        pm.expect(firstElement.incptnDtTm).to.exist.and.not.be.empty;\r",
													"    });\r",
													"}\r",
													"\r",
													"if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"    pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
													"        pm.expect(firstElement.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"    });\r",
													"} else {    // if not, one must not have been defaulted\r",
													"    pm.test(\"Result condition does not have an xprtnDtTm\", function () {\r",
													"        pm.expect(firstElement.xprtnDtTm).to.not.exist;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.usr).to.be.eql(targetConditionResult.usr);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition has a non-empty creDtTm\", function () {\r",
													"    pm.expect(firstElement.creDtTm).to.exist.and.not.be.empty;\r",
													"});\r",
													"\r",
													"// create an array that only includes the perspective descriptions so that we can evaluate them easily\r",
													"let perspectives = firstElement.prsptvs.map(({ prsptv }) => prsptv);\r",
													"\r",
													"if (targetConditionResult.prsptv === \"both\") {\r",
													"    pm.test(\"Result prsptv array contains only 2 perspectives\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(2);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_creditor_by\", \"governed_as_debtor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains both ${JSON.stringify(targetPerspectives)} perspectives`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"} else if (targetConditionResult.prsptv === \"debtor\") {\r",
													"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_debtor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"} else if (targetConditionResult.prsptv === \"creditor\") {\r",
													"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_creditor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"};\r",
													"\r",
													"for (let i = 0; i < firstElement.prsptvs.length; i++) {   // for each perspective\r",
													"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} contains a non-empty evtTp array`, function () {\r",
													"        pm.expect(firstElement.prsptvs[i].evtTp).to.be.an('array').and.not.be.empty;\r",
													"    });\r",
													"\r",
													"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} evtTp array matches submitted condition`, function () {\r",
													"        pm.expect(firstElement.prsptvs[i].evtTp).to.include.members(targetConditionResult.evtTp);\r",
													"    });\r",
													"\r",
													"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches submitted condition`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must have been defaulted\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches created condition incptDtTm`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.eql(firstElement.incptnDtTm);\r",
													"        });\r",
													"    }\r",
													"\r",
													"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} xprtnDtTm matches submitted condition`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must not have been defaulted\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} does not have an xprtnDtTm`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.not.exist;\r",
													"        });\r",
													"    }\r",
													"\r",
													"}\r",
													"\r",
													"pm.test(\"Result condition ntty.id matches submitted condition\", function () {\r",
													"    pm.expect(conditionEntity.id).to.be.eql(targetConditionResult.ntty.id);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"    pm.expect(conditionEntity.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
													"});\r",
													"\r",
													"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetEntityId, false);;\r",
													"\r",
													"await pm.sendRequest(postRequest, (error, response) => {\r",
													"    if (utils.getLogLevel() === 'DEBUG') {\r",
													"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
													"    }\r",
													"    databaseConditionResult = response.json().data;\r",
													"\r",
													"    if (utils.getLogLevel() === 'DEBUG') {\r",
													"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
													"    }\r",
													"\r",
													"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
													"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
													"\r",
													"    pm.test(`Only one condition for entity [${targetEntityId}] exists in the database`, function () {\r",
													"        pm.expect(graphConditionList.length).to.eql(1);\r",
													"    });\r",
													"\r",
													"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
													"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
													"            pm.expect(conditionGraph.v[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
													"        });\r",
													"    }\r",
													"\r",
													"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
													"    });\r",
													"\r",
													"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"        pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
													"            pm.expect(conditionGraph.v[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must have been defaulted\r",
													"        pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
													"            pm.expect(conditionGraph.v[0].incptnDtTm).to.exist.and.not.be.empty;\r",
													"        });\r",
													"    }\r",
													"\r",
													"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"        pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
													"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must not have been defaulted\r",
													"        pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
													"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.not.exist;\r",
													"        });\r",
													"    }\r",
													"\r",
													"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].ntty.id).to.be.eql(targetConditionResult.ntty.id);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].ntty.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].usr).to.be.eql(targetConditionResult.usr);\r",
													"    });\r",
													"\r",
													"    let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, conditionGraph.v[0]._key);\r",
													"\r",
													"    pm.test(`Database \"governed_as_debtor_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database 'governed_as_creditor_by' edge exists\", function () {\r",
													"        pm.expect(edgeList).to.include.members([\"governed_as_creditor_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
													"    });\r",
													"\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"// Obliterate the current contents of the global variables\r",
													"pm.globals.clear();\r",
													"\r",
													"// Set up the transaction (in memory)\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ 3600000,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"\r",
													"// Retrieve the created pacs.008 message\r",
													"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
													"\r",
													"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
													"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
													"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
													"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
													"\r",
													"// Load deconstructued identifier variables into global variables\r",
													"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
													"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
													"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
													"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
													"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
													"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
													"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
													"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
													"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
													"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
													"pm.globals.set(\"tenantId\", submittedPacs008Message.TenantId);\r",
													"\r",
													"// Set up the condition\r",
													"\r",
													"messageBody = {\r",
													"  \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09\",\"pacs.008.001.10\",\"pacs.002.001.12\"],\r",
													"  \"condTp\":\"non-overridable-block\",\r",
													"  \"prsptv\":\"creditor\",\r",
													"  \"condRsn\":\"Default Test Condition\",\r",
													"  \"ntty\":\r",
													"  {\r",
													"    \"id\": `${cdtrNttyId.id}`,\r",
													"    \"schmeNm\":\r",
													"    {\r",
													"      \"prtry\":\"TAZAMA_EID\"\r",
													"    }\r",
													"  },\r",
													"  \"forceCret\":true,\r",
													"  \"usr\":\"POSTMAN\"\r",
													"}\r",
													"\r",
													"// Set up body variables\r",
													"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
													"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
											"host": [
												"{{tazamaAdminUrl}}{{path-admin-api-version}}"
											],
											"path": [
												"{{path-entity-condition}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('dbtrNttyId');\r",
													"let dbtrAcctId = pm.globals.get('dbtrAcctId');\r",
													"let cdtrId = pm.globals.get('cdtrNttyId');\r",
													"let cdtrAcctId = pm.globals.get('cdtrAcctId');\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ cdtrId,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ cdtrAcctId,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ 'fsp001',\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Post pacs.002 to TMS API - NO TIMEOUT EXPECTED",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`Alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"ALRT\";\r",
													"const expectedBlockingOutcome = \"block\";\r",
													"const expectedReviewFlag = true;\r",
													"const expectedTypologyAlert = false;\r",
													"const expectedTypologyInterdiction = false;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('dbtrNttyId');\r",
													"let dbtrAcctId = pm.globals.get('dbtrAcctId');\r",
													"let cdtrId = pm.globals.get('cdtrNttyId');\r",
													"let cdtrAcctId = pm.globals.get('cdtrAcctId');\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ cdtrId,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ cdtrAcctId,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ 'fsp001',\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Post pacs.002 to TMS API - NO TIMEOUT EXPECTED",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`Alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"ALRT\";\r",
													"const expectedBlockingOutcome = \"block\";\r",
													"const expectedReviewFlag = true;\r",
													"const expectedTypologyAlert = true;\r",
													"const expectedTypologyInterdiction = false;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('dbtrNttyId');\r",
													"let dbtrAcctId = pm.globals.get('dbtrAcctId');\r",
													"let cdtrId = pm.globals.get('cdtrNttyId');\r",
													"let cdtrAcctId = pm.globals.get('cdtrAcctId');\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ cdtrId,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ cdtrAcctId,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ 'fsp001',\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Post pacs.002 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`Alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"ALRT\";\r",
													"const expectedBlockingOutcome = \"block\";\r",
													"const expectedReviewFlag = true;\r",
													"const expectedTypologyAlert = true;\r",
													"const expectedTypologyInterdiction = true;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "overridable block",
							"item": [
								{
									"name": "Create New Entity Condition Manually - Unknown debtor entity",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"responseJSON = pm.response.json();\r",
													"let conditionResult = responseJSON.result.conditions;\r",
													"let conditionEntity = responseJSON.result.ntty;\r",
													"let requestMessage = responseJSON.message;\r",
													"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
													"let nttyId = pm.globals.get(\"cdtrNttyId\");\r",
													"let nttyIdSchme = pm.globals.get(\"cdtrNttyIdSchmeNm\");\r",
													"let tenantId = pm.globals.get(\"tenantId\");\r",
													"let targetEntityId = nttyId + nttyIdSchme;\r",
													"\r",
													"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
													"targetRequestMessage = \"New condition was saved successfully.\"\r",
													"\r",
													"pm.test(\"Status code is 200\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(\"Result message matches target result message\", function () {\r",
													"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
													"});\r",
													"\r",
													"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
													"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
													"});\r",
													"\r",
													"pm.test(\"Result conditions array only contains a single condition\", function () {\r",
													"    pm.expect(conditionResult.length).to.be.eql(1);\r",
													"});\r",
													"\r",
													"let firstElement = conditionResult[0];\r",
													"\r",
													"pm.test(\"Result condition has a non-empty condId\", function () {\r",
													"    pm.expect(firstElement.condId).to.exist.and.not.be.empty;\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.condTp).to.be.eql(targetConditionResult.condTp);\r",
													"});\r",
													"\r",
													"if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"    pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
													"        pm.expect(firstElement.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"    });\r",
													"} else {    // if not, one must have been defaulted\r",
													"    pm.test(\"Result condition has a non-empty incptnDtTm\", function () {\r",
													"        pm.expect(firstElement.incptnDtTm).to.exist.and.not.be.empty;\r",
													"    });\r",
													"}\r",
													"\r",
													"if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"    pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
													"        pm.expect(firstElement.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"    });\r",
													"} else {    // if not, one must not have been defaulted\r",
													"    pm.test(\"Result condition does not have an xprtnDtTm\", function () {\r",
													"        pm.expect(firstElement.xprtnDtTm).to.not.exist;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.usr).to.be.eql(targetConditionResult.usr);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition has a non-empty creDtTm\", function () {\r",
													"    pm.expect(firstElement.creDtTm).to.exist.and.not.be.empty;\r",
													"});\r",
													"\r",
													"// create an array that only includes the perspective descriptions so that we can evaluate them easily\r",
													"let perspectives = firstElement.prsptvs.map(({ prsptv }) => prsptv);\r",
													"\r",
													"if (targetConditionResult.prsptv === \"both\") {\r",
													"    pm.test(\"Result prsptv array contains only 2 perspectives\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(2);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_creditor_by\", \"governed_as_debtor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains both ${JSON.stringify(targetPerspectives)} perspectives`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"} else if (targetConditionResult.prsptv === \"debtor\") {\r",
													"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_debtor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"} else if (targetConditionResult.prsptv === \"creditor\") {\r",
													"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_creditor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"};\r",
													"\r",
													"for (let i = 0; i < firstElement.prsptvs.length; i++) {   // for each perspective\r",
													"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} contains a non-empty evtTp array`, function () {\r",
													"        pm.expect(firstElement.prsptvs[i].evtTp).to.be.an('array').and.not.be.empty;\r",
													"    });\r",
													"\r",
													"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} evtTp array matches submitted condition`, function () {\r",
													"        pm.expect(firstElement.prsptvs[i].evtTp).to.include.members(targetConditionResult.evtTp);\r",
													"    });\r",
													"\r",
													"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches submitted condition`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must have been defaulted\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches created condition incptDtTm`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.eql(firstElement.incptnDtTm);\r",
													"        });\r",
													"    }\r",
													"\r",
													"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} xprtnDtTm matches submitted condition`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must not have been defaulted\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} does not have an xprtnDtTm`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.not.exist;\r",
													"        });\r",
													"    }\r",
													"\r",
													"}\r",
													"\r",
													"pm.test(\"Result condition ntty.id matches submitted condition\", function () {\r",
													"    pm.expect(conditionEntity.id).to.be.eql(targetConditionResult.ntty.id);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"    pm.expect(conditionEntity.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
													"});\r",
													"\r",
													"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetEntityId, false);;\r",
													"\r",
													"await pm.sendRequest(postRequest, (error, response) => {\r",
													"    if (utils.getLogLevel() === 'DEBUG') {\r",
													"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
													"    }\r",
													"    databaseConditionResult = response.json().data;\r",
													"\r",
													"    if (utils.getLogLevel() === 'DEBUG') {\r",
													"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
													"    }\r",
													"\r",
													"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
													"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
													"\r",
													"    pm.test(`Only one condition for entity [${targetEntityId}] exists in the database`, function () {\r",
													"        pm.expect(graphConditionList.length).to.eql(1);\r",
													"    });\r",
													"\r",
													"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
													"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
													"            pm.expect(conditionGraph.v[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
													"        });\r",
													"    }\r",
													"\r",
													"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
													"    });\r",
													"\r",
													"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"        pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
													"            pm.expect(conditionGraph.v[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must have been defaulted\r",
													"        pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
													"            pm.expect(conditionGraph.v[0].incptnDtTm).to.exist.and.not.be.empty;\r",
													"        });\r",
													"    }\r",
													"\r",
													"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"        pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
													"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must not have been defaulted\r",
													"        pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
													"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.not.exist;\r",
													"        });\r",
													"    }\r",
													"\r",
													"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].ntty.id).to.be.eql(targetConditionResult.ntty.id);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].ntty.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].usr).to.be.eql(targetConditionResult.usr);\r",
													"    });\r",
													"\r",
													"    let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, conditionGraph.v[0]._key);\r",
													"\r",
													"    pm.test(`Database \"governed_as_debtor_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database 'governed_as_creditor_by' edge exists\", function () {\r",
													"        pm.expect(edgeList).to.include.members([\"governed_as_creditor_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
													"    });\r",
													"\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"// Obliterate the current contents of the global variables\r",
													"pm.globals.clear();\r",
													"\r",
													"// Set up the transaction (in memory)\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ 3600000,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"\r",
													"// Retrieve the created pacs.008 message\r",
													"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
													"\r",
													"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
													"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
													"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
													"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
													"\r",
													"// Load deconstructued identifier variables into global variables\r",
													"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
													"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
													"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
													"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
													"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
													"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
													"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
													"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
													"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
													"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
													"\r",
													"// Set up the condition\r",
													"\r",
													"messageBody = {\r",
													"  \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09\",\"pacs.008.001.10\",\"pacs.002.001.12\"],\r",
													"  \"condTp\":\"overridable-block\",\r",
													"  \"prsptv\":\"creditor\",\r",
													"  \"condRsn\":\"Default Test Condition\",\r",
													"  \"ntty\":\r",
													"  {\r",
													"    \"id\": `${cdtrNttyId.id}`,\r",
													"    \"schmeNm\":\r",
													"    {\r",
													"      \"prtry\":\"TAZAMA_EID\"\r",
													"    }\r",
													"  },\r",
													"  \"forceCret\":true,\r",
													"  \"usr\":\"POSTMAN\"\r",
													"}\r",
													"\r",
													"// Set up body variables\r",
													"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
													"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
											"host": [
												"{{tazamaAdminUrl}}{{path-admin-api-version}}"
											],
											"path": [
												"{{path-entity-condition}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('debtorId');\r",
													"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
													"let cdtrId = pm.globals.get('creditorId');\r",
													"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ cdtrId,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ cdtrAcctId,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ 'fsp001',\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Post pacs.002 to TMS API - NO TIMEOUT EXPECTED",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`Alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"ALRT\";\r",
													"const expectedBlockingOutcome = \"block\";\r",
													"const expectedReviewFlag = true;\r",
													"const expectedTypologyAlert = false;\r",
													"const expectedTypologyInterdiction = false;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('debtorId');\r",
													"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
													"let cdtrId = pm.globals.get('creditorId');\r",
													"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ cdtrId,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ cdtrAcctId,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ 'fsp001',\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Post pacs.002 to TMS API - NO TIMEOUT EXPECTED",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`Alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"ALRT\";\r",
													"const expectedBlockingOutcome = \"block\";\r",
													"const expectedReviewFlag = true;\r",
													"const expectedTypologyAlert = true;\r",
													"const expectedTypologyInterdiction = false;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('debtorId');\r",
													"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
													"let cdtrId = pm.globals.get('creditorId');\r",
													"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ cdtrId,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ cdtrAcctId,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ 'fsp001',\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Post pacs.002 to TMS API - NO TIMEOUT EXPECTED",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`Alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"ALRT\";\r",
													"const expectedBlockingOutcome = \"block\";\r",
													"const expectedReviewFlag = true;\r",
													"const expectedTypologyAlert = true;\r",
													"const expectedTypologyInterdiction = true;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "overridable block with override",
							"item": [
								{
									"name": "Create New Entity Condition Manually - Unknown debtor entity",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"responseJSON = pm.response.json();\r",
													"let conditionResult = responseJSON.result.conditions;\r",
													"let conditionEntity = responseJSON.result.ntty;\r",
													"let requestMessage = responseJSON.message;\r",
													"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
													"let nttyId = pm.globals.get(\"cdtrNttyId\");\r",
													"let nttyIdSchme = pm.globals.get(\"cdtrNttyIdSchmeNm\");\r",
													"let tenantId = pm.globals.get(\"tenantId\");\r",
													"let targetEntityId = nttyId + nttyIdSchme;\r",
													"\r",
													"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
													"targetRequestMessage = \"New condition was saved successfully.\"\r",
													"\r",
													"pm.test(\"Status code is 200\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(\"Result message matches target result message\", function () {\r",
													"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
													"});\r",
													"\r",
													"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
													"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
													"});\r",
													"\r",
													"pm.test(\"Result conditions array only contains a single condition\", function () {\r",
													"    pm.expect(conditionResult.length).to.be.eql(1);\r",
													"});\r",
													"\r",
													"let firstElement = conditionResult[0];\r",
													"\r",
													"pm.test(\"Result condition has a non-empty condId\", function () {\r",
													"    pm.expect(firstElement.condId).to.exist.and.not.be.empty;\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.condTp).to.be.eql(targetConditionResult.condTp);\r",
													"});\r",
													"\r",
													"if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"    pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
													"        pm.expect(firstElement.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"    });\r",
													"} else {    // if not, one must have been defaulted\r",
													"    pm.test(\"Result condition has a non-empty incptnDtTm\", function () {\r",
													"        pm.expect(firstElement.incptnDtTm).to.exist.and.not.be.empty;\r",
													"    });\r",
													"}\r",
													"\r",
													"if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"    pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
													"        pm.expect(firstElement.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"    });\r",
													"} else {    // if not, one must not have been defaulted\r",
													"    pm.test(\"Result condition does not have an xprtnDtTm\", function () {\r",
													"        pm.expect(firstElement.xprtnDtTm).to.not.exist;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
													"    pm.expect(firstElement.usr).to.be.eql(targetConditionResult.usr);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition has a non-empty creDtTm\", function () {\r",
													"    pm.expect(firstElement.creDtTm).to.exist.and.not.be.empty;\r",
													"});\r",
													"\r",
													"// create an array that only includes the perspective descriptions so that we can evaluate them easily\r",
													"let perspectives = firstElement.prsptvs.map(({ prsptv }) => prsptv);\r",
													"\r",
													"if (targetConditionResult.prsptv === \"both\") {\r",
													"    pm.test(\"Result prsptv array contains only 2 perspectives\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(2);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_creditor_by\", \"governed_as_debtor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains both ${JSON.stringify(targetPerspectives)} perspectives`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"} else if (targetConditionResult.prsptv === \"debtor\") {\r",
													"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_debtor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"} else if (targetConditionResult.prsptv === \"creditor\") {\r",
													"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
													"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_creditor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"};\r",
													"\r",
													"for (let i = 0; i < firstElement.prsptvs.length; i++) {   // for each perspective\r",
													"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} contains a non-empty evtTp array`, function () {\r",
													"        pm.expect(firstElement.prsptvs[i].evtTp).to.be.an('array').and.not.be.empty;\r",
													"    });\r",
													"\r",
													"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} evtTp array matches submitted condition`, function () {\r",
													"        pm.expect(firstElement.prsptvs[i].evtTp).to.include.members(targetConditionResult.evtTp);\r",
													"    });\r",
													"\r",
													"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches submitted condition`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must have been defaulted\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches created condition incptDtTm`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.eql(firstElement.incptnDtTm);\r",
													"        });\r",
													"    }\r",
													"\r",
													"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} xprtnDtTm matches submitted condition`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must not have been defaulted\r",
													"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} does not have an xprtnDtTm`, function () {\r",
													"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.not.exist;\r",
													"        });\r",
													"    }\r",
													"\r",
													"}\r",
													"\r",
													"pm.test(\"Result condition ntty.id matches submitted condition\", function () {\r",
													"    pm.expect(conditionEntity.id).to.be.eql(targetConditionResult.ntty.id);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"    pm.expect(conditionEntity.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
													"});\r",
													"\r",
													"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetEntityId, false);;\r",
													"\r",
													"await pm.sendRequest(postRequest, (error, response) => {\r",
													"    if (utils.getLogLevel() === 'DEBUG') {\r",
													"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
													"    }\r",
													"    databaseConditionResult = response.json().data;\r",
													"\r",
													"    if (utils.getLogLevel() === 'DEBUG') {\r",
													"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
													"    }\r",
													"\r",
													"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
													"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
													"\r",
													"    pm.test(`Only one condition for entity [${targetEntityId}] exists in the database`, function () {\r",
													"        pm.expect(graphConditionList.length).to.eql(1);\r",
													"    });\r",
													"\r",
													"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
													"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
													"            pm.expect(conditionGraph.v[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
													"        });\r",
													"    }\r",
													"\r",
													"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
													"    });\r",
													"\r",
													"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"        pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
													"            pm.expect(conditionGraph.v[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must have been defaulted\r",
													"        pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
													"            pm.expect(conditionGraph.v[0].incptnDtTm).to.exist.and.not.be.empty;\r",
													"        });\r",
													"    }\r",
													"\r",
													"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"        pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
													"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must not have been defaulted\r",
													"        pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
													"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.not.exist;\r",
													"        });\r",
													"    }\r",
													"\r",
													"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].ntty.id).to.be.eql(targetConditionResult.ntty.id);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].ntty.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
													"        pm.expect(conditionGraph.v[0].usr).to.be.eql(targetConditionResult.usr);\r",
													"    });\r",
													"\r",
													"    let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, conditionGraph.v[0]._key);\r",
													"\r",
													"    pm.test(`Database \"governed_as_debtor_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database 'governed_as_creditor_by' edge exists\", function () {\r",
													"        pm.expect(edgeList).to.include.members([\"governed_as_creditor_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
													"    });\r",
													"\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"// Obliterate the current contents of the global variables\r",
													"pm.globals.clear();\r",
													"\r",
													"// Set up the transaction (in memory)\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ 3600000,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"\r",
													"// Retrieve the created pacs.008 message\r",
													"const submittedPacs008Message = utils.addTenantId(null, messageSet.pacs008);\r",
													"\r",
													"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
													"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
													"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
													"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
													"\r",
													"// Load deconstructued identifier variables into global variables\r",
													"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
													"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
													"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
													"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
													"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
													"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
													"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
													"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
													"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
													"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
													"\r",
													"// Set up the condition\r",
													"\r",
													"console.log(`Overridable block incepts at ${utils.getTimestampNow()}`);\r",
													"\r",
													"messageBody = {\r",
													"  \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09\",\"pacs.008.001.10\",\"pacs.002.001.12\"],\r",
													"  \"condTp\":\"overridable-block\",\r",
													"  \"prsptv\":\"creditor\",\r",
													"  \"condRsn\":\"Default Test Condition\",\r",
													"  \"ntty\":\r",
													"  {\r",
													"    \"id\": `${cdtrNttyId.id}`,\r",
													"    \"schmeNm\":\r",
													"    {\r",
													"      \"prtry\":\"TAZAMA_EID\"\r",
													"    }\r",
													"  },\r",
													"  \"forceCret\":true,\r",
													"  \"usr\":\"POSTMAN\"\r",
													"}\r",
													"\r",
													"// Set up body variables\r",
													"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
													"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
											"host": [
												"{{tazamaAdminUrl}}{{path-admin-api-version}}"
											],
											"path": [
												"{{path-entity-condition}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Create New Entity Condition Manually - set override",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"responseJSON = pm.response.json();\r",
													"let conditionResult = responseJSON.result.conditions;\r",
													"let conditionEntity = responseJSON.result.ntty;\r",
													"let requestMessage = responseJSON.message;\r",
													"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
													"let nttyId = pm.globals.get(\"cdtrNttyId\");\r",
													"let nttyIdSchme = pm.globals.get(\"cdtrNttyIdSchmeNm\");\r",
													"let tenantId = pm.globals.get(\"tenantId\");\r",
													"let targetEntityId = nttyId + nttyIdSchme;\r",
													"\r",
													"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
													"targetRequestMessage = \"1 conditions already exist for the entity\"\r",
													"\r",
													"pm.test(\"Status code is 200\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(\"Result message matches target result message\", function () {\r",
													"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
													"});\r",
													"\r",
													"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
													"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
													"});\r",
													"\r",
													"pm.test(\"Result conditions array contains two conditions\", function () {\r",
													"    pm.expect(conditionResult.length).to.be.eql(2);\r",
													"});\r",
													"\r",
													"let newElement = conditionResult[conditionResult.length - 1];  // the last element is the newly submitted condition\r",
													"\r",
													"pm.test(\"Result condition has a non-empty condId\", function () {\r",
													"    pm.expect(newElement.condId).to.exist.and.not.be.empty;\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
													"    pm.expect(newElement.condTp).to.be.eql(targetConditionResult.condTp);\r",
													"});\r",
													"\r",
													"if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"    pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
													"        pm.expect(newElement.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"    });\r",
													"} else {    // if not, one must have been defaulted\r",
													"    pm.test(\"Result condition has a non-empty incptnDtTm\", function () {\r",
													"        pm.expect(newElement.incptnDtTm).to.exist.and.not.be.empty;\r",
													"    });\r",
													"}\r",
													"\r",
													"if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"    pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
													"        pm.expect(newElement.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"    });\r",
													"} else {    // if not, one must not have been defaulted\r",
													"    pm.test(\"Result condition does not have an xprtnDtTm\", function () {\r",
													"        pm.expect(newElement.xprtnDtTm).to.not.exist;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
													"    pm.expect(newElement.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
													"    pm.expect(newElement.usr).to.be.eql(targetConditionResult.usr);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition has a non-empty creDtTm\", function () {\r",
													"    pm.expect(newElement.creDtTm).to.exist.and.not.be.empty;\r",
													"});\r",
													"\r",
													"// create an array that only includes the perspective descriptions so that we can evaluate them easily\r",
													"let perspectives = newElement.prsptvs.map(({ prsptv }) => prsptv);\r",
													"\r",
													"if (targetConditionResult.prsptv === \"both\") {\r",
													"    pm.test(\"Result prsptv array contains only 2 perspectives\", function () {\r",
													"        pm.expect(newElement.prsptvs.length).to.be.eql(2);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_creditor_by\", \"governed_as_debtor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains both ${JSON.stringify(targetPerspectives)} perspectives`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"} else if (targetConditionResult.prsptv === \"debtor\") {\r",
													"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
													"        pm.expect(newElement.prsptvs.length).to.be.eql(1);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_debtor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"} else if (targetConditionResult.prsptv === \"creditor\") {\r",
													"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
													"        pm.expect(newElement.prsptvs.length).to.be.eql(1);\r",
													"    });\r",
													"\r",
													"    let targetPerspectives = [\"governed_as_creditor_by\"];\r",
													"\r",
													"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
													"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
													"    });\r",
													"\r",
													"};\r",
													"\r",
													"for (let i = 0; i < newElement.prsptvs.length; i++) {   // for each perspective\r",
													"    pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} contains a non-empty evtTp array`, function () {\r",
													"        pm.expect(newElement.prsptvs[i].evtTp).to.be.an('array').and.not.be.empty;\r",
													"    });\r",
													"\r",
													"    pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} evtTp array matches submitted condition`, function () {\r",
													"        pm.expect(newElement.prsptvs[i].evtTp).to.include.members(targetConditionResult.evtTp);\r",
													"    });\r",
													"\r",
													"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"        pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} incptnDtTm matches submitted condition`, function () {\r",
													"            pm.expect(newElement.prsptvs[i].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must have been defaulted\r",
													"        pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} incptnDtTm matches created condition incptDtTm`, function () {\r",
													"            pm.expect(newElement.prsptvs[i].incptnDtTm).to.eql(newElement.incptnDtTm);\r",
													"        });\r",
													"    }\r",
													"\r",
													"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"        pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} xprtnDtTm matches submitted condition`, function () {\r",
													"            pm.expect(newElement.prsptvs[i].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must not have been defaulted\r",
													"        pm.test(`Result prsptv ${newElement.prsptvs[i].prsptv} does not have an xprtnDtTm`, function () {\r",
													"            pm.expect(newElement.prsptvs[i].xprtnDtTm).to.not.exist;\r",
													"        });\r",
													"    }\r",
													"\r",
													"}\r",
													"\r",
													"pm.test(\"Result condition ntty.id matches submitted condition\", function () {\r",
													"    pm.expect(conditionEntity.id).to.be.eql(targetConditionResult.ntty.id);\r",
													"});\r",
													"\r",
													"pm.test(\"Result condition ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"    pm.expect(conditionEntity.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
													"});\r",
													"\r",
													"// Now we want to test that the data in the database matches the submitted data AND the response data\r",
													"\r",
													"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetEntityId, false);;\r",
													"\r",
													"await pm.sendRequest(postRequest, (error, response) => {\r",
													"    if (utils.getLogLevel() === 'DEBUG') {\r",
													"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
													"    }\r",
													"    databaseConditionResult = response.json().data;\r",
													"\r",
													"    if (utils.getLogLevel() === 'DEBUG') {\r",
													"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
													"    }\r",
													"\r",
													"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
													"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
													"\r",
													"    let submittedCondition = graphConditionList.filter(condition => condition._id === `conditions/${newElement.condId}`);\r",
													"\r",
													"    // First we check that the submitted condition matches the database version\r",
													"\r",
													"    pm.test(`Only two conditions for entity [${targetEntityId}] exists in the database`, function () {\r",
													"        pm.expect(graphConditionList.length).to.eql(2);\r",
													"    });\r",
													"\r",
													"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
													"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
													"            pm.expect(submittedCondition[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
													"        });\r",
													"    }\r",
													"\r",
													"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
													"        pm.expect(submittedCondition[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
													"        pm.expect(submittedCondition[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
													"    });\r",
													"\r",
													"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
													"        pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
													"            pm.expect(submittedCondition[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must have been defaulted\r",
													"        pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
													"            pm.expect(submittedCondition[0].incptnDtTm).to.exist.and.not.be.empty;\r",
													"        });\r",
													"    }\r",
													"\r",
													"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
													"        pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
													"            pm.expect(submittedCondition[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
													"        });\r",
													"    } else {    // if not, one must not have been defaulted\r",
													"        pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
													"            pm.expect(submittedCondition[0].xprtnDtTm).to.not.exist;\r",
													"        });\r",
													"    }\r",
													"\r",
													"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
													"        pm.expect(submittedCondition[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
													"        pm.expect(submittedCondition[0].ntty.id).to.be.eql(targetConditionResult.ntty.id);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"        pm.expect(submittedCondition[0].ntty.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
													"        pm.expect(submittedCondition[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
													"        pm.expect(submittedCondition[0].usr).to.be.eql(targetConditionResult.usr);\r",
													"    });\r",
													"\r",
													"    let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, submittedCondition[0]._key);\r",
													"\r",
													"    pm.test(`Database \"governed_as_debtor_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(\"Database 'governed_as_creditor_by' edge exists\", function () {\r",
													"        pm.expect(edgeList).to.include.members([\"governed_as_creditor_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
													"    });\r",
													"\r",
													"    pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
													"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
													"    });\r",
													"\r",
													"    // Then we check the previous conditions in the response one-by-one against the database version\r",
													"    let previousConditionsFromResponse = graphConditionList.filter(condition => condition._id != `conditions/${newElement.condId}`);\r",
													"    let previousResponseConditionIds = previousConditionsFromResponse.map(({ condId }) => condId);\r",
													"    let previousConditionsFromDatabase = graphConditionList.filter(condition => condition._id != `conditions/${newElement.condId}`);\r",
													"    let previousDatabaseConditionIds = previousConditionsFromDatabase.map(({ condId }) => condId);\r",
													"\r",
													"    pm.test(`List of previous conditions in response match list of conditions from database`, function () {\r",
													"        pm.expect(previousResponseConditionIds).to.have.members(previousDatabaseConditionIds);\r",
													"    });\r",
													"\r",
													"    pm.test(`Only one previous condition for entity [${targetEntityId}] exists in the reponse`, function () {\r",
													"        pm.expect(previousConditionsFromResponse.length).to.eql(1);\r",
													"    });\r",
													"\r",
													"    pm.test(`Only one previous condition for entity [${targetEntityId}] exists in the database`, function () {\r",
													"        pm.expect(previousConditionsFromDatabase.length).to.eql(1);\r",
													"    });\r",
													"\r",
													"    for (let j = 0; j < previousConditionsFromResponse.length; j++) {\r",
													"\r",
													"        let justOneConditionFromResponse = previousConditionsFromResponse.filter(condition => condition._id === `conditions/${conditionResult[j].condId}`);\r",
													"        let sameConditionFromDatabase = previousConditionsFromDatabase.filter(condition => condition._id === `conditions/${conditionResult[j].condId}`);\r",
													"\r",
													"        for (let i = 0; i < sameConditionFromDatabase[0].evtTp.length; i++) {\r",
													"            pm.test(`Database condition.evtTp contains ${sameConditionFromDatabase[0].evtTp[i]}`, function () {\r",
													"                pm.expect(justOneConditionFromResponse[0].evtTp).to.include.members([sameConditionFromDatabase[0].evtTp[i]]);\r",
													"            });\r",
													"        }\r",
													"\r",
													"        pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
													"            pm.expect(justOneConditionFromResponse[0].condTp).to.be.eql(sameConditionFromDatabase[0].condTp);\r",
													"        });\r",
													"\r",
													"        pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
													"            pm.expect(justOneConditionFromResponse[0].prsptv).to.be.eql(sameConditionFromDatabase[0].prsptv);\r",
													"        });\r",
													"\r",
													"        if (sameConditionFromDatabase[0].incptnDtTm) { // was an inception date specified?\r",
													"            pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
													"                pm.expect(justOneConditionFromResponse[0].incptnDtTm).to.be.eql(sameConditionFromDatabase[0].incptnDtTm);\r",
													"            });\r",
													"        } else {    // if not, one must have been defaulted\r",
													"            pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
													"                pm.expect(justOneConditionFromResponse[0].incptnDtTm).to.exist.and.not.be.empty;\r",
													"            });\r",
													"        }\r",
													"\r",
													"        if (sameConditionFromDatabase[0].xprtnDtTm) { // was an expiration date specified?\r",
													"            pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
													"                pm.expect(justOneConditionFromResponse[0].xprtnDtTm).to.be.eql(sameConditionFromDatabase[0].xprtnDtTm);\r",
													"            });\r",
													"        } else {    // if not, one must not have been defaulted\r",
													"            pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
													"                pm.expect(justOneConditionFromResponse[0].xprtnDtTm).to.not.exist;\r",
													"            });\r",
													"        }\r",
													"\r",
													"        pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
													"            pm.expect(justOneConditionFromResponse[0].condRsn).to.be.eql(sameConditionFromDatabase[0].condRsn);\r",
													"        });\r",
													"\r",
													"        pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
													"            pm.expect(justOneConditionFromResponse[0].ntty.id).to.be.eql(sameConditionFromDatabase[0].ntty.id);\r",
													"        });\r",
													"\r",
													"        pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
													"            pm.expect(justOneConditionFromResponse[0].ntty.schmeNm.prtry).to.be.eql(sameConditionFromDatabase[0].ntty.schmeNm.prtry);\r",
													"        });\r",
													"\r",
													"        pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
													"            pm.expect(justOneConditionFromResponse[0].forceCret).to.be.eql(sameConditionFromDatabase[0].forceCret);\r",
													"        });\r",
													"\r",
													"        pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
													"            pm.expect(justOneConditionFromResponse[0].usr).to.be.eql(sameConditionFromDatabase[0].usr);\r",
													"        });\r",
													"\r",
													"        let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, justOneConditionFromResponse[0]._key);\r",
													"\r",
													"        pm.test(`Database \"governed_as_debtor_by\" edge does not exist`, function () {\r",
													"            pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_by\"]);\r",
													"        });\r",
													"\r",
													"        pm.test(\"Database 'governed_as_creditor_by' edge exists\", function () {\r",
													"            pm.expect(edgeList).to.include.members([\"governed_as_creditor_by\"]);\r",
													"        });\r",
													"\r",
													"        pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
													"            pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
													"        });\r",
													"\r",
													"        pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
													"            pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
													"        });\r",
													"    }\r",
													"\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"// Retrieve the created pacs.008 message\r",
													"const submittedPacs008Message = utils.addTenantId(null, JSON.parse(pm.globals.get(\"pacs008\")));\r",
													"\r",
													"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
													"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
													"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
													"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
													"\r",
													"// Load deconstructued identifier variables into global variables\r",
													"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
													"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
													"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
													"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
													"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
													"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
													"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
													"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
													"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
													"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
													"\r",
													"xprtnDtTm = utils.timestampAtTMinus(-10, \"m\");\r",
													"\r",
													"// Set up the condition\r",
													"\r",
													"console.log(`Override incepts at ${utils.getTimestampNow()}`);\r",
													"\r",
													"messageBody = {\r",
													"  \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09\",\"pacs.008.001.10\",\"pacs.002.001.12\"],\r",
													"  \"condTp\":\"override\",\r",
													"  \"prsptv\":\"creditor\",\r",
													"  \"xprtnDtTm\": xprtnDtTm,\r",
													"  \"condRsn\":\"Default Test Condition\",\r",
													"  \"ntty\":\r",
													"  {\r",
													"    \"id\": `${cdtrNttyId.id}`,\r",
													"    \"schmeNm\":\r",
													"    {\r",
													"      \"prtry\":\"TAZAMA_EID\"\r",
													"    }\r",
													"  },\r",
													"  \"forceCret\":true,\r",
													"  \"usr\":\"POSTMAN\"\r",
													"}\r",
													"\r",
													"// Set up body variables\r",
													"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
													"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
											"host": [
												"{{tazamaAdminUrl}}{{path-admin-api-version}}"
											],
											"path": [
												"{{path-entity-condition}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('debtorId');\r",
													"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
													"let cdtrId = pm.globals.get('creditorId');\r",
													"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
													"\r",
													"// Hacky workaround for testing the timeout of the submission of the pacs002 after this test\r",
													"pm.globals.set('responseTimedOut', true);\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ cdtrId,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ cdtrAcctId,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ 'fsp001',\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Post pacs.002 to TMS API - TIMEOUT EXPECTED",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"// Hacky workaround for testing the timeout of the submission of the pacs002\r",
													"pm.globals.set('responseTimedOut', false);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`No alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													"\r",
													"pm.test(`Request does not complete within specified timeout of ${pm.globals.get('timeoutLimit')}`, function () {\r",
													"    pm.expect(pm.response.responseTime).to.be.above(4000);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 1 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"NALT\";\r",
													"const expectedBlockingOutcome = \"override\";\r",
													"const expectedReviewFlag = false;\r",
													"const expectedTypologyAlert = false;\r",
													"const expectedTypologyInterdiction = false;\r",
													"const expectedResponseTimedOut = true;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });\r",
													"\r",
													"pm.test(`No response received at EFRuP interdiction service before timeout`, function () {\r",
													"        pm.expect(pm.globals.get('responseTimedOut')).to.be.eql(expectedResponseTimedOut);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('debtorId');\r",
													"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
													"let cdtrId = pm.globals.get('creditorId');\r",
													"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
													"\r",
													"// Hacky workaround for testing the timeout of the submission of the pacs002 after this test\r",
													"pm.globals.set('responseTimedOut', true);\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ cdtrId,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ cdtrAcctId,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ 'fsp001',\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Post pacs.002 to TMS API - TIMEOUT EXPECTED",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"// Hacky workaround for testing the timeout of the submission of the pacs002\r",
													"pm.globals.set('responseTimedOut', false);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`Alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													"\r",
													"pm.test(`Request does not complete within specified timeout of ${pm.globals.get('timeoutLimit')}`, function () {\r",
													"    pm.expect(pm.response.responseTime).to.be.above(4000);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {},
												"requests": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 2 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"ALRT\";\r",
													"const expectedBlockingOutcome = \"override\";\r",
													"const expectedReviewFlag = true;\r",
													"const expectedTypologyAlert = true;\r",
													"const expectedTypologyInterdiction = false;\r",
													"const expectedResponseTimedOut = true;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });\r",
													"\r",
													"pm.test(`No response received at EFRuP interdiction service before timeout`, function () {\r",
													"        pm.expect(pm.globals.get('responseTimedOut')).to.be.eql(expectedResponseTimedOut);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Post pacs.008 to TMS API",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
													"\r",
													"let dbtrId = pm.globals.get('debtorId');\r",
													"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
													"let cdtrId = pm.globals.get('creditorId');\r",
													"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
													"\r",
													"// Hacky workaround for testing the timeout of the submission of the pacs002 after this test\r",
													"pm.globals.set('responseTimedOut', true);\r",
													"\r",
													"// ## Set up transaction eco-system\r",
													"\r",
													"messageSet = utils.createTransactionSetInMemory(\r",
													"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
													"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
													"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
													"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
													"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
													"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
													"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
													"    /* Creditor ID - null defaults random UUID ---------------------- */ cdtrId,\r",
													"    /* Creditor Account ID - null defaults random UUID -------------- */ cdtrAcctId,\r",
													"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ 'fsp001',\r",
													"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
													"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
													"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
													"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
													"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
													"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
													"    /* Description - null defaults random UUID ---------------------- */ null,\r",
													"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
													"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
													"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
													"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
													"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
													"    );\r",
													"\r",
													"let messageBody = pm.globals.get('pacs008');\r",
													"pm.globals.set('messageBody', messageBody);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{{messageBody}}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
											"host": [
												"{{tazamaTMSUrl}}{{path-tms-api-version}}"
											],
											"path": [
												"{{path-pacs008}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Post pacs.002 to TMS API - TIMEOUT EXPECTED",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
													"const responseDestination = `relay-service-nats-ef`; // The NATS subject for the output retrieval\r",
													"const awaitReply = true; // Hold the phone for a callback\r",
													"\r",
													"let messageBody = pm.globals.get('pacs002');\r",
													"pm.globals.set('messageBody', messageBody);\r",
													"pm.globals.set('endpoint', endpoint);\r",
													"pm.globals.set('responseDestination', responseDestination);\r",
													"pm.globals.set('awaitReply', awaitReply);\r",
													""
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"console.log(resJson);\r",
													"\r",
													"// Hacky workaround for testing the timeout of the submission of the pacs002\r",
													"pm.globals.set('responseTimedOut', false);\r",
													"\r",
													"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
													"    pm.response.to.have.status(200);\r",
													"});\r",
													"\r",
													"pm.test(`No alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
													"    pm.expect(resJson.edResponse.ruleResult.subRuleRef).to.be.eq('block');\r",
													"});\r",
													"\r",
													"pm.test(`Request does not complete within specified timeout of ${pm.globals.get('timeoutLimit')}`, function () {\r",
													"    pm.expect(pm.response.responseTime).to.be.above(4000);\r",
													"});"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
											"host": [
												"{{natsUrl}}"
											],
											"path": [
												"{{nats-path-tms-api}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "Transaction 3 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
												],
												"type": "text/javascript",
												"packages": {}
											}
										},
										{
											"listen": "test",
											"script": {
												"exec": [
													"const resJson = pm.response.json();\r",
													"\r",
													"const rulesPerTypologyCount = [3];\r",
													"const totalExpectedTypologies = 1;\r",
													"const expectedAlertStatus = \"ALRT\";\r",
													"const expectedBlockingOutcome = \"override\";\r",
													"const expectedReviewFlag = true;\r",
													"const expectedTypologyAlert = true;\r",
													"const expectedTypologyInterdiction = true;\r",
													"const expectedResponseTimedOut = true;\r",
													"\r",
													"const interdictionTypologies = [\r",
													"  \"999\"\r",
													"];\r",
													"const ruleDescriptions = {\r",
													"  \"901\": \"Number of outgoing transactions - debtor\",\r",
													"  \"902\": \"Number of incoming transactions - creditor\",\r",
													"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
													"}\r",
													"const typologyDescriptions = {\r",
													"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
													"}\r",
													"\r",
													"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
													"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
													"\r",
													"typologyCount = typologyResultsUnique.count();\r",
													"ruleCount = ruleResultsUnique.count();\r",
													"\r",
													"foundEFRuP = false;\r",
													"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
													"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
													"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
													"        foundEFRuP = true;\r",
													"    }\r",
													"}\r",
													"\r",
													"ruleWeightingTotal = 0;\r",
													"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
													"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
													"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
													"    }    \r",
													"}\r",
													"\r",
													"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
													"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
													"});\r",
													"\r",
													"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
													"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
													"    pm.expect(foundEFRuP).to.be.true;\r",
													"});\r",
													"\r",
													"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
													"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
													"});\r",
													"\r",
													"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
													"    });\r",
													"\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
													"    });\r",
													"}\r",
													"\r",
													"if (expectedReviewFlag) {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
													"    });\r",
													"} else {\r",
													"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
													"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
													"    });\r",
													"}\r",
													"\r",
													"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
													"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
													"    });\r",
													"\r",
													"pm.test(`No response received at EFRuP interdiction service before timeout`, function () {\r",
													"        pm.expect(pm.globals.get('responseTimedOut')).to.be.eql(expectedResponseTimedOut);\r",
													"    });"
												],
												"type": "text/javascript",
												"packages": {}
											}
										}
									],
									"request": {
										"auth": {
											"type": "bearer",
											"bearer": [
												{
													"key": "token",
													"value": "{{auth-token}}",
													"type": "string"
												}
											]
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
											"host": [
												"{{arangoUrl}}"
											],
											"path": [
												"_db",
												"{{db_results}}",
												"_api",
												"cursor"
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "interdiction with override",
							"item": [
								{
									"name": "Before override",
									"item": [
										{
											"name": "Transaction 1 - Post pacs.008 to TMS API",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
															"\r",
															"let dbtrId = pm.globals.get('debtorId');\r",
															"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
															"let cdtrId = pm.globals.get('creditorId');\r",
															"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
															"\r",
															"// Hacky workaround for testing the timeout of the submission of the pacs002 after this test\r",
															"pm.globals.set('responseTimedOut', true);\r",
															"\r",
															"// ## Set up transaction eco-system\r",
															"\r",
															"messageSet = utils.createTransactionSetInMemory(\r",
															"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
															"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
															"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
															"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
															"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
															"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
															"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
															"    /* Creditor ID - null defaults random UUID ---------------------- */ null,\r",
															"    /* Creditor Account ID - null defaults random UUID -------------- */ null,\r",
															"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
															"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
															"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
															"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
															"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
															"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
															"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
															"    /* Description - null defaults random UUID ---------------------- */ null,\r",
															"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
															"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
															"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
															"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
															"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
															"    );\r",
															"\r",
															"let messageBody = pm.globals.get('pacs008');\r",
															"pm.globals.set('pacs008Stash', messageBody);\r",
															"pm.globals.set('messageBody', messageBody);"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{{messageBody}}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
													"host": [
														"{{tazamaTMSUrl}}{{path-tms-api-version}}"
													],
													"path": [
														"{{path-pacs008}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 1 - Post pacs.002 to TMS API",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"let messageBody = pm.globals.get('pacs002');\r",
															"pm.globals.set('messageBody', messageBody);"
														],
														"type": "text/javascript",
														"packages": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{{pacs002}}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs002}}",
													"host": [
														"{{tazamaTMSUrl}}{{path-tms-api-version}}"
													],
													"path": [
														"{{path-pacs002}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 1 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
														],
														"type": "text/javascript",
														"packages": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"const resJson = pm.response.json();\r",
															"\r",
															"const rulesPerTypologyCount = [3];\r",
															"const totalExpectedTypologies = 1;\r",
															"const expectedAlertStatus = \"NALT\";\r",
															"const expectedBlockingOutcome = \"none\";\r",
															"const expectedReviewFlag = false;\r",
															"const expectedTypologyAlert = false;\r",
															"const expectedTypologyInterdiction = false;\r",
															"\r",
															"const interdictionTypologies = [\r",
															"  \"999\"\r",
															"];\r",
															"const ruleDescriptions = {\r",
															"  \"901\": \"Number of outgoing transactions - debtor\",\r",
															"  \"902\": \"Number of incoming transactions - creditor\",\r",
															"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
															"}\r",
															"const typologyDescriptions = {\r",
															"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
															"}\r",
															"\r",
															"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
															"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
															"\r",
															"typologyCount = typologyResultsUnique.count();\r",
															"ruleCount = ruleResultsUnique.count();\r",
															"\r",
															"foundEFRuP = false;\r",
															"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
															"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
															"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
															"        foundEFRuP = true;\r",
															"    }\r",
															"}\r",
															"\r",
															"ruleWeightingTotal = 0;\r",
															"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
															"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
															"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
															"    }    \r",
															"}\r",
															"\r",
															"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
															"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
															"});\r",
															"\r",
															"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
															"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
															"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
															"    pm.expect(foundEFRuP).to.be.true;\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
															"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
															"});\r",
															"\r",
															"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedReviewFlag) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
															"    });\r",
															"} else {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
															"    });\r",
															"}\r",
															"\r",
															"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
															"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
															"    });"
														],
														"type": "text/javascript",
														"packages": {}
													}
												}
											],
											"request": {
												"auth": {
													"type": "bearer",
													"bearer": [
														{
															"key": "token",
															"value": "{{auth-token}}",
															"type": "string"
														}
													]
												},
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
													"host": [
														"{{arangoUrl}}"
													],
													"path": [
														"_db",
														"{{db_results}}",
														"_api",
														"cursor"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 2 - Post pacs.008 to TMS API",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
															"\r",
															"let dbtrId = pm.globals.get('debtorId');\r",
															"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
															"let cdtrId = pm.globals.get('creditorId');\r",
															"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
															"\r",
															"// Hacky workaround for testing the timeout of the submission of the pacs002 after this test\r",
															"pm.globals.set('responseTimedOut', true);\r",
															"\r",
															"// ## Set up transaction eco-system\r",
															"\r",
															"messageSet = utils.createTransactionSetInMemory(\r",
															"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
															"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
															"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
															"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
															"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
															"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
															"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
															"    /* Creditor ID - null defaults random UUID ---------------------- */ cdtrId,\r",
															"    /* Creditor Account ID - null defaults random UUID -------------- */ cdtrAcctId,\r",
															"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
															"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
															"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
															"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
															"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
															"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
															"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
															"    /* Description - null defaults random UUID ---------------------- */ null,\r",
															"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
															"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
															"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
															"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
															"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
															"    );\r",
															"\r",
															"let messageBody = pm.globals.get('pacs008');\r",
															"pm.globals.set('messageBody', messageBody);"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{{messageBody}}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
													"host": [
														"{{tazamaTMSUrl}}{{path-tms-api-version}}"
													],
													"path": [
														"{{path-pacs008}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 2 - Post pacs.002 to TMS API - TIMEOUT EXPECTED",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
															"const responseDestination = `relay-service-nats-tp`; // The NATS subject for the output retrieval\r",
															"const awaitReply = true; // Hold the phone for a callback\r",
															"\r",
															"let messageBody = pm.globals.get('pacs002');\r",
															"pm.globals.set('messageBody', messageBody);\r",
															"pm.globals.set('endpoint', endpoint);\r",
															"pm.globals.set('responseDestination', responseDestination);\r",
															"pm.globals.set('awaitReply', awaitReply);"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"const resJson = pm.response.json();\r",
															"console.log(resJson);\r",
															"\r",
															"// Hacky workaround for testing the timeout of the submission of the pacs002\r",
															"pm.globals.set('responseTimedOut', false);\r",
															"\r",
															"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});\r",
															"\r",
															"pm.test(`Interdiction alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
															"    pm.expect(resJson.edResponse.report.status).to.be.eql('ALRT');\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
													"host": [
														"{{natsUrl}}"
													],
													"path": [
														"{{nats-path-tms-api}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 2 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"const resJson = pm.response.json();\r",
															"\r",
															"const rulesPerTypologyCount = [3];\r",
															"const totalExpectedTypologies = 1;\r",
															"const expectedAlertStatus = \"ALRT\";\r",
															"const expectedBlockingOutcome = \"none\";\r",
															"const expectedReviewFlag = true;\r",
															"const expectedTypologyAlert = true;\r",
															"const expectedTypologyInterdiction = false;\r",
															"const expectedResponseTimedOut = true;\r",
															"\r",
															"const interdictionTypologies = [\r",
															"  \"999\"\r",
															"];\r",
															"const ruleDescriptions = {\r",
															"  \"901\": \"Number of outgoing transactions - debtor\",\r",
															"  \"902\": \"Number of incoming transactions - creditor\",\r",
															"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
															"}\r",
															"const typologyDescriptions = {\r",
															"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
															"}\r",
															"\r",
															"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
															"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
															"\r",
															"typologyCount = typologyResultsUnique.count();\r",
															"ruleCount = ruleResultsUnique.count();\r",
															"\r",
															"foundEFRuP = false;\r",
															"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
															"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
															"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
															"        foundEFRuP = true;\r",
															"    }\r",
															"}\r",
															"\r",
															"ruleWeightingTotal = 0;\r",
															"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
															"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
															"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
															"    }    \r",
															"}\r",
															"\r",
															"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
															"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
															"});\r",
															"\r",
															"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
															"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
															"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
															"    pm.expect(foundEFRuP).to.be.true;\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
															"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
															"});\r",
															"\r",
															"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedReviewFlag) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
															"    });\r",
															"} else {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
															"    });\r",
															"}\r",
															"\r",
															"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
															"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
															"    });\r",
															"\r",
															"pm.test(`No response received at EFRuP interdiction service before timeout`, function () {\r",
															"        pm.expect(pm.globals.get('responseTimedOut')).to.be.eql(expectedResponseTimedOut);\r",
															"    });"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"auth": {
													"type": "bearer",
													"bearer": [
														{
															"key": "token",
															"value": "{{auth-token}}",
															"type": "string"
														}
													]
												},
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
													"host": [
														"{{arangoUrl}}"
													],
													"path": [
														"_db",
														"{{db_results}}",
														"_api",
														"cursor"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 3 - Post pacs.008 to TMS API",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
															"\r",
															"let dbtrId = pm.globals.get('debtorId');\r",
															"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
															"let cdtrId = pm.globals.get('creditorId');\r",
															"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
															"\r",
															"// Hacky workaround for testing the timeout of the submission of the pacs002 after this test\r",
															"pm.globals.set('responseTimedOut', true);\r",
															"\r",
															"// ## Set up transaction eco-system\r",
															"\r",
															"messageSet = utils.createTransactionSetInMemory(\r",
															"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
															"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
															"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
															"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
															"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
															"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
															"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
															"    /* Creditor ID - null defaults random UUID ---------------------- */ cdtrId,\r",
															"    /* Creditor Account ID - null defaults random UUID -------------- */ cdtrAcctId,\r",
															"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
															"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
															"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
															"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
															"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
															"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
															"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
															"    /* Description - null defaults random UUID ---------------------- */ null,\r",
															"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
															"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
															"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
															"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
															"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
															"    );\r",
															"\r",
															"let messageBody = pm.globals.get('pacs008');\r",
															"pm.globals.set('messageBody', messageBody);"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{{messageBody}}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
													"host": [
														"{{tazamaTMSUrl}}{{path-tms-api-version}}"
													],
													"path": [
														"{{path-pacs008}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 3 - Post pacs.002 to TMS API - NO TIMEOUT EXPECTED",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
															"const responseDestination = `relay-service-nats-tp`; // The NATS subject for the output retrieval\r",
															"const awaitReply = true; // Hold the phone for a callback\r",
															"\r",
															"let messageBody = pm.globals.get('pacs002');\r",
															"pm.globals.set('messageBody', messageBody);\r",
															"pm.globals.set('endpoint', endpoint);\r",
															"pm.globals.set('responseDestination', responseDestination);\r",
															"pm.globals.set('awaitReply', awaitReply);\r",
															""
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"const resJson = pm.response.json();\r",
															"console.log(resJson);\r",
															"\r",
															"// Hacky workaround for testing the timeout of the submission of the pacs002\r",
															"pm.globals.set('responseTimedOut', false);\r",
															"\r",
															"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});\r",
															"\r",
															"pm.test(`Interdiction alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
															"    pm.expect(resJson.edResponse.typologyResult.review).to.be.true;\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
													"host": [
														"{{natsUrl}}"
													],
													"path": [
														"{{nats-path-tms-api}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 3 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
														],
														"type": "text/javascript",
														"packages": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"const resJson = pm.response.json();\r",
															"\r",
															"const rulesPerTypologyCount = [3];\r",
															"const totalExpectedTypologies = 1;\r",
															"const expectedAlertStatus = \"ALRT\";\r",
															"const expectedBlockingOutcome = \"none\";\r",
															"const expectedReviewFlag = true;\r",
															"const expectedTypologyAlert = true;\r",
															"const expectedTypologyInterdiction = true;\r",
															"const expectedResponseTimedOut = false;\r",
															"\r",
															"const interdictionTypologies = [\r",
															"  \"999\"\r",
															"];\r",
															"const ruleDescriptions = {\r",
															"  \"901\": \"Number of outgoing transactions - debtor\",\r",
															"  \"902\": \"Number of incoming transactions - creditor\",\r",
															"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
															"}\r",
															"const typologyDescriptions = {\r",
															"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
															"}\r",
															"\r",
															"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
															"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
															"\r",
															"typologyCount = typologyResultsUnique.count();\r",
															"ruleCount = ruleResultsUnique.count();\r",
															"\r",
															"foundEFRuP = false;\r",
															"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
															"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
															"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
															"        foundEFRuP = true;\r",
															"    }\r",
															"}\r",
															"\r",
															"ruleWeightingTotal = 0;\r",
															"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
															"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
															"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
															"    }    \r",
															"}\r",
															"\r",
															"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
															"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
															"});\r",
															"\r",
															"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
															"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
															"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
															"    pm.expect(foundEFRuP).to.be.true;\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
															"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
															"});\r",
															"\r",
															"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedReviewFlag) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
															"    });\r",
															"} else {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
															"    });\r",
															"}\r",
															"\r",
															"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
															"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
															"    });\r",
															"\r",
															"pm.test(`Response received at EFRuP interdiction service before timeout`, function () {\r",
															"        pm.expect(pm.globals.get('responseTimedOut')).to.be.eql(expectedResponseTimedOut);\r",
															"    });"
														],
														"type": "text/javascript",
														"packages": {}
													}
												}
											],
											"request": {
												"auth": {
													"type": "bearer",
													"bearer": [
														{
															"key": "token",
															"value": "{{auth-token}}",
															"type": "string"
														}
													]
												},
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
													"host": [
														"{{arangoUrl}}"
													],
													"path": [
														"_db",
														"{{db_results}}",
														"_api",
														"cursor"
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "After override",
									"item": [
										{
											"name": "Create New Entity Condition Manually - Existing debtor",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"responseJSON = pm.response.json();\r",
															"let conditionResult = responseJSON.result.conditions;\r",
															"let conditionEntity = responseJSON.result.ntty;\r",
															"let requestMessage = responseJSON.message;\r",
															"console.log(`Response condition: ${JSON.stringify(responseJSON)}`);\r",
															"let nttyId = pm.globals.get(\"cdtrNttyId\");\r",
															"let nttyIdSchme = pm.globals.get(\"cdtrNttyIdSchmeNm\");\r",
															"let tenantId = pm.globals.get(\"tenantId\");\r",
															"let targetEntityId = nttyId + nttyIdSchme;\r",
															"\r",
															"targetConditionResult = JSON.parse(pm.globals.get('messageBody'));\r",
															"targetRequestMessage = \"New condition was saved successfully.\"\r",
															"\r",
															"pm.test(\"Status code is 200\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});\r",
															"\r",
															"pm.test(\"Result message matches target result message\", function () {\r",
															"    pm.expect(requestMessage).to.be.eql(targetRequestMessage);\r",
															"});\r",
															"\r",
															"pm.test(\"Result conditions must be a non-empty array\", function () {\r",
															"    pm.expect(conditionResult).to.be.an('array').and.not.be.empty;\r",
															"});\r",
															"\r",
															"pm.test(\"Result conditions array only contains a single condition\", function () {\r",
															"    pm.expect(conditionResult.length).to.be.eql(1);\r",
															"});\r",
															"\r",
															"let firstElement = conditionResult[0];\r",
															"\r",
															"pm.test(\"Result condition has a non-empty condId\", function () {\r",
															"    pm.expect(firstElement.condId).to.exist.and.not.be.empty;\r",
															"});\r",
															"\r",
															"pm.test(\"Result condition.condTp matches submitted condition\", function () {\r",
															"    pm.expect(firstElement.condTp).to.be.eql(targetConditionResult.condTp);\r",
															"});\r",
															"\r",
															"if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
															"    pm.test(\"Result condition.incptnDtTm matches submitted condition\", function () {\r",
															"        pm.expect(firstElement.incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
															"    });\r",
															"} else {    // if not, one must have been defaulted\r",
															"    pm.test(\"Result condition has a non-empty incptnDtTm\", function () {\r",
															"        pm.expect(firstElement.incptnDtTm).to.exist.and.not.be.empty;\r",
															"    });\r",
															"}\r",
															"\r",
															"if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
															"    pm.test(\"Result condition.xprtnDtTm matches submitted condition\", function () {\r",
															"        pm.expect(firstElement.xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
															"    });\r",
															"} else {    // if not, one must not have been defaulted\r",
															"    pm.test(\"Result condition does not have an xprtnDtTm\", function () {\r",
															"        pm.expect(firstElement.xprtnDtTm).to.not.exist;\r",
															"    });\r",
															"}\r",
															"\r",
															"pm.test(\"Result condition.condRsn matches submitted condition\", function () {\r",
															"    pm.expect(firstElement.condRsn).to.be.eql(targetConditionResult.condRsn);\r",
															"});\r",
															"\r",
															"pm.test(\"Result condition.usr matches submitted condition\", function () {\r",
															"    pm.expect(firstElement.usr).to.be.eql(targetConditionResult.usr);\r",
															"});\r",
															"\r",
															"pm.test(\"Result condition has a non-empty creDtTm\", function () {\r",
															"    pm.expect(firstElement.creDtTm).to.exist.and.not.be.empty;\r",
															"});\r",
															"\r",
															"// create an array that only includes the perspective descriptions so that we can evaluate them easily\r",
															"let perspectives = firstElement.prsptvs.map(({ prsptv }) => prsptv);\r",
															"\r",
															"if (targetConditionResult.prsptv === \"both\") {\r",
															"    pm.test(\"Result prsptv array contains only 2 perspectives\", function () {\r",
															"        pm.expect(firstElement.prsptvs.length).to.be.eql(2);\r",
															"    });\r",
															"\r",
															"    let targetPerspectives = [\"governed_as_creditor_by\", \"governed_as_debtor_by\"];\r",
															"\r",
															"    pm.test(`Result prsptv array contains both ${JSON.stringify(targetPerspectives)} perspectives`, function () {\r",
															"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
															"    });\r",
															"\r",
															"} else if (targetConditionResult.prsptv === \"debtor\") {\r",
															"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
															"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
															"    });\r",
															"\r",
															"    let targetPerspectives = [\"governed_as_debtor_by\"];\r",
															"\r",
															"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
															"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
															"    });\r",
															"\r",
															"} else if (targetConditionResult.prsptv === \"creditor\") {\r",
															"    pm.test(\"Result prsptv array contains only 1 perspective\", function () {\r",
															"        pm.expect(firstElement.prsptvs.length).to.be.eql(1);\r",
															"    });\r",
															"\r",
															"    let targetPerspectives = [\"governed_as_creditor_by\"];\r",
															"\r",
															"    pm.test(`Result prsptv array contains only the ${JSON.stringify(targetPerspectives)} perspective`, function () {\r",
															"        pm.expect(perspectives).to.include.members(targetPerspectives);\r",
															"    });\r",
															"\r",
															"};\r",
															"\r",
															"for (let i = 0; i < firstElement.prsptvs.length; i++) {   // for each perspective\r",
															"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} contains a non-empty evtTp array`, function () {\r",
															"        pm.expect(firstElement.prsptvs[i].evtTp).to.be.an('array').and.not.be.empty;\r",
															"    });\r",
															"\r",
															"    pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} evtTp array matches submitted condition`, function () {\r",
															"        pm.expect(firstElement.prsptvs[i].evtTp).to.include.members(targetConditionResult.evtTp);\r",
															"    });\r",
															"\r",
															"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
															"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches submitted condition`, function () {\r",
															"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
															"        });\r",
															"    } else {    // if not, one must have been defaulted\r",
															"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} incptnDtTm matches created condition incptDtTm`, function () {\r",
															"            pm.expect(firstElement.prsptvs[i].incptnDtTm).to.eql(firstElement.incptnDtTm);\r",
															"        });\r",
															"    }\r",
															"\r",
															"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
															"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} xprtnDtTm matches submitted condition`, function () {\r",
															"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
															"        });\r",
															"    } else {    // if not, one must not have been defaulted\r",
															"        pm.test(`Result prsptv ${firstElement.prsptvs[i].prsptv} does not have an xprtnDtTm`, function () {\r",
															"            pm.expect(firstElement.prsptvs[i].xprtnDtTm).to.not.exist;\r",
															"        });\r",
															"    }\r",
															"\r",
															"}\r",
															"\r",
															"pm.test(\"Result condition ntty.id matches submitted condition\", function () {\r",
															"    pm.expect(conditionEntity.id).to.be.eql(targetConditionResult.ntty.id);\r",
															"});\r",
															"\r",
															"pm.test(\"Result condition ntty.schmeNm.prtry matches submitted condition\", function () {\r",
															"    pm.expect(conditionEntity.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
															"});\r",
															"\r",
															"const postRequest = utils.getConditionsFromDBPostRequest(tenantId, targetEntityId, false);;\r",
															"\r",
															"await pm.sendRequest(postRequest, (error, response) => {\r",
															"    if (utils.getLogLevel() === 'DEBUG') {\r",
															"        console.log(error ? error : JSON.stringify(response.json(), null, 2));\r",
															"    }\r",
															"    databaseConditionResult = response.json().data;\r",
															"\r",
															"    if (utils.getLogLevel() === 'DEBUG') {\r",
															"        console.log(`Database condition query result: ${JSON.stringify(databaseConditionResult)}`);\r",
															"    }\r",
															"\r",
															"    let conditionGraph = utils.getConditionsGraph(databaseConditionResult)\r",
															"    let graphConditionList = utils.getConditionsFromGraph(conditionGraph, true);\r",
															"\r",
															"    pm.test(`Only one condition for entity [${targetEntityId}] exists in the database`, function () {\r",
															"        pm.expect(graphConditionList.length).to.eql(1);\r",
															"    });\r",
															"\r",
															"    for (let i = 0; i < targetConditionResult.evtTp.length; i++) {\r",
															"        pm.test(`Database condition.evtTp contains ${targetConditionResult.evtTp[i]}`, function () {\r",
															"            pm.expect(conditionGraph.v[0].evtTp).to.include.members([targetConditionResult.evtTp[i]]);\r",
															"        });\r",
															"    }\r",
															"\r",
															"    pm.test(\"Database condition.condTp matches submitted condition\", function () {\r",
															"        pm.expect(conditionGraph.v[0].condTp).to.be.eql(targetConditionResult.condTp);\r",
															"    });\r",
															"\r",
															"    pm.test(\"Database condition.prsptv matches submitted condition\", function () {\r",
															"        pm.expect(conditionGraph.v[0].prsptv).to.be.eql(targetConditionResult.prsptv);\r",
															"    });\r",
															"\r",
															"    if (targetConditionResult.incptnDtTm) { // was an inception date specified?\r",
															"        pm.test(\"Database condition.incptnDtTm matches submitted condition\", function () {\r",
															"            pm.expect(conditionGraph.v[0].incptnDtTm).to.be.eql(targetConditionResult.incptnDtTm);\r",
															"        });\r",
															"    } else {    // if not, one must have been defaulted\r",
															"        pm.test(\"Database condition has a non-empty incptnDtTm\", function () {\r",
															"            pm.expect(conditionGraph.v[0].incptnDtTm).to.exist.and.not.be.empty;\r",
															"        });\r",
															"    }\r",
															"\r",
															"    if (targetConditionResult.xprtnDtTm) { // was an expiration date specified?\r",
															"        pm.test(\"Database condition.xprtnDtTm matches submitted condition\", function () {\r",
															"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.be.eql(targetConditionResult.xprtnDtTm);\r",
															"        });\r",
															"    } else {    // if not, one must not have been defaulted\r",
															"        pm.test(\"Database condition does not have an xprtnDtTm\", function () {\r",
															"            pm.expect(conditionGraph.v[0].xprtnDtTm).to.not.exist;\r",
															"        });\r",
															"    }\r",
															"\r",
															"    pm.test(\"Database condition.condRsn matches submitted condition\", function () {\r",
															"        pm.expect(conditionGraph.v[0].condRsn).to.be.eql(targetConditionResult.condRsn);\r",
															"    });\r",
															"\r",
															"    pm.test(\"Database condition.ntty.id matches submitted condition\", function () {\r",
															"        pm.expect(conditionGraph.v[0].ntty.id).to.be.eql(targetConditionResult.ntty.id);\r",
															"    });\r",
															"\r",
															"    pm.test(\"Database condition.ntty.schmeNm.prtry matches submitted condition\", function () {\r",
															"        pm.expect(conditionGraph.v[0].ntty.schmeNm.prtry).to.be.eql(targetConditionResult.ntty.schmeNm.prtry);\r",
															"    });\r",
															"\r",
															"    pm.test(\"Database condition.forceCret matches submitted condition\", function () {\r",
															"        pm.expect(conditionGraph.v[0].forceCret).to.be.eql(targetConditionResult.forceCret);\r",
															"    });\r",
															"\r",
															"    pm.test(\"Database condition.usr matches submitted condition\", function () {\r",
															"        pm.expect(conditionGraph.v[0].usr).to.be.eql(targetConditionResult.usr);\r",
															"    });\r",
															"\r",
															"    let edgeList = utils.getConditionPerspectivesFromGraph(conditionGraph, conditionGraph.v[0]._key);\r",
															"\r",
															"    pm.test(`Database \"governed_as_debtor_by\" edge does not exist`, function () {\r",
															"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_by\"]);\r",
															"    });\r",
															"\r",
															"    pm.test(\"Database 'governed_as_creditor_by' edge exists\", function () {\r",
															"        pm.expect(edgeList).to.include.members([\"governed_as_creditor_by\"]);\r",
															"    });\r",
															"\r",
															"    pm.test(`Database \"governed_as_debtor_account_by\" edge does not exist`, function () {\r",
															"        pm.expect(edgeList).to.not.include.members([\"governed_as_debtor_account_by\"]);\r",
															"    });\r",
															"\r",
															"    pm.test(`Database \"governed_as_creditor_account_by\" edge does not exist`, function () {\r",
															"        pm.expect(edgeList).to.not.include.members([\"governed_as_creditor_account_by\"]);\r",
															"    });\r",
															"\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
															"\r",
															"// Obliterate the current contents of the global variables\r",
															"// Retrieve the created pacs.008 message\r",
															"\r",
															"const submittedPacs008Message = JSON.parse(pm.globals.get('pacs008Stash'));\r",
															"pm.globals.set('pacs008', pm.globals.get('pacs008Stash'));\r",
															"\r",
															"const dbtrNttyId = utils.getDebtorIdFromPacs008(submittedPacs008Message);\r",
															"const dbtrAcctId = utils.getDebtorAccountIdFromPacs008(submittedPacs008Message);\r",
															"const cdtrNttyId = utils.getCreditorIdFromPacs008(submittedPacs008Message);\r",
															"const cdtrAcctId = utils.getCreditorAccountIdFromPacs008(submittedPacs008Message);\r",
															"\r",
															"// Load deconstructued identifier variables into global variables\r",
															"pm.globals.set(\"dbtrNttyId\", dbtrNttyId.id);\r",
															"pm.globals.set(\"dbtrNttyIdSchmeNm\", dbtrNttyId.schmeNm.prtry);\r",
															"pm.globals.set(\"dbtrAcctId\", dbtrAcctId.id);\r",
															"pm.globals.set(\"dbtrAcctIdSchmeNm\", dbtrAcctId.schmeNm.prtry);\r",
															"pm.globals.set(\"dbtrAgt\", dbtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
															"pm.globals.set(\"cdtrNttyId\", cdtrNttyId.id);\r",
															"pm.globals.set(\"cdtrNttyIdSchmeNm\", cdtrNttyId.schmeNm.prtry);\r",
															"pm.globals.set(\"cdtrAcctId\", cdtrAcctId.id);\r",
															"pm.globals.set(\"cdtrAcctIdSchmeNm\", cdtrAcctId.schmeNm.prtry);\r",
															"pm.globals.set(\"cdtrAgt\", cdtrAcctId.agt.finInstnId.clrSysMmbId.mmbId);\r",
															"\r",
															"xprtnDtTm = utils.timestampAtTMinus(-10, \"m\");\r",
															"\r",
															"// Set up the condition\r",
															"\r",
															"console.log(`Override incepts at ${utils.getTimestampNow()}`);\r",
															"\r",
															"messageBody = {\r",
															"  \"evtTp\":[\"pain.001.001.11\",\"pain.013.001.09\",\"pacs.008.001.10\",\"pacs.002.001.12\"],\r",
															"  \"condTp\":\"override\",\r",
															"  \"prsptv\":\"creditor\",\r",
															"  \"xprtnDtTm\": xprtnDtTm,\r",
															"  \"condRsn\":\"Default Test Condition\",\r",
															"  \"ntty\":\r",
															"  {\r",
															"    \"id\": `${cdtrNttyId.id}`,\r",
															"    \"schmeNm\":\r",
															"    {\r",
															"      \"prtry\":\"TAZAMA_EID\"\r",
															"    }\r",
															"  },\r",
															"  \"forceCret\":true,\r",
															"  \"usr\":\"POSTMAN\"\r",
															"}\r",
															"\r",
															"// Set up body variables\r",
															"pm.globals.set('messageBody', JSON.stringify(messageBody));\r",
															"console.log(`Message body: ${pm.variables.get('messageBody')}`);"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{{messageBody}}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/{{path-entity-condition}}",
													"host": [
														"{{tazamaAdminUrl}}{{path-admin-api-version}}"
													],
													"path": [
														"{{path-entity-condition}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 4 - Post pacs.008 to TMS API",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"utils.setPm(pm); // set the utils _pm to the pre-request script pm to access the utils functions\r",
															"\r",
															"let dbtrId = pm.globals.get('debtorId');\r",
															"let dbtrAcctId = pm.globals.get('debtorAccountId');\r",
															"let cdtrId = pm.globals.get('creditorId');\r",
															"let cdtrAcctId = pm.globals.get('creditorAccountId');\r",
															"\r",
															"// Hacky workaround for testing the timeout of the submission of the pacs002 after this test\r",
															"pm.globals.set('responseTimedOut', true);\r",
															"\r",
															"// ## Set up transaction eco-system\r",
															"\r",
															"messageSet = utils.createTransactionSetInMemory(\r",
															"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
															"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
															"    /* Timestamp Offset - null defaults 0 --------------------------- */ null,\r",
															"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
															"    /* Debtor ID - null defaults random UUID ------------------------ */ null,\r",
															"    /* Debtor Account ID - null defaults random UUID ---------------- */ null,\r",
															"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
															"    /* Creditor ID - null defaults random UUID ---------------------- */ cdtrId,\r",
															"    /* Creditor Account ID - null defaults random UUID -------------- */ cdtrAcctId,\r",
															"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
															"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
															"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
															"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
															"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
															"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
															"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
															"    /* Description - null defaults random UUID ---------------------- */ null,\r",
															"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
															"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
															"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
															"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
															"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
															"    );\r",
															"\r",
															"let messageBody = pm.globals.get('pacs008');\r",
															"pm.globals.set('messageBody', messageBody);"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{{messageBody}}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
													"host": [
														"{{tazamaTMSUrl}}{{path-tms-api-version}}"
													],
													"path": [
														"{{path-pacs008}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 4 - Post pacs.002 to TMS API - TIMEOUT EXPECTED",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"const endpoint = `http://${pm.environment.get(\"tazamaTMSContainerUrl\")}${pm.environment.get(\"path-tms-api-version\")}/${pm.environment.get(\"path-pacs002\")}`; // The TMS API endpoint to invoke\r",
															"const responseDestination = `relay-service-nats-tp`; // The NATS subject for the output retrieval\r",
															"const awaitReply = true; // Hold the phone for a callback\r",
															"\r",
															"let messageBody = pm.globals.get('pacs002');\r",
															"pm.globals.set('messageBody', messageBody);\r",
															"pm.globals.set('endpoint', endpoint);\r",
															"pm.globals.set('responseDestination', responseDestination);\r",
															"pm.globals.set('awaitReply', awaitReply);\r",
															""
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"const resJson = pm.response.json();\r",
															"console.log(resJson);\r",
															"\r",
															"// Hacky workaround for testing the timeout of the submission of the pacs002\r",
															"pm.globals.set('responseTimedOut', false);\r",
															"\r",
															"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
															"    pm.response.to.have.status(200);\r",
															"});\r",
															"\r",
															"pm.test(`No alert trapped at response destination ${pm.globals.get('responseDestination')}`, function () {\r",
															"    pm.expect(resJson.edResponse.ruleResult.typologyResult.review).to.be.true;\r",
															"});\r",
															"\r",
															"pm.test(`Request does not complete within specified timeout of ${pm.globals.get('timeoutLimit')}`, function () {\r",
															"    pm.expect(pm.response.responseTime).to.be.above(4000);\r",
															"});"
														],
														"type": "text/javascript",
														"packages": {},
														"requests": {}
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"transaction\": {{messageBody}},\r\n    \"endpoint\": \"{{endpoint}}\",\r\n    \"natsConsumer\": \"{{responseDestination}}\",\r\n    \"functionName\": \"{{messageIdPacs002}}\",\r\n    \"awaitReply\": {{awaitReply}}\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{natsUrl}}/{{nats-path-tms-api}}",
													"host": [
														"{{natsUrl}}"
													],
													"path": [
														"{{nats-path-tms-api}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "Transaction 4 - Fetch evaluation results with msgId - Rule 901/902 Network Map",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
														],
														"type": "text/javascript",
														"packages": {}
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"const resJson = pm.response.json();\r",
															"\r",
															"const rulesPerTypologyCount = [3];\r",
															"const totalExpectedTypologies = 1;\r",
															"const expectedAlertStatus = \"ALRT\";\r",
															"const expectedBlockingOutcome = \"override\";\r",
															"const expectedReviewFlag = true;\r",
															"const expectedTypologyAlert = true;\r",
															"const expectedTypologyInterdiction = true;\r",
															"const expectedResponseTimedOut = true;\r",
															"\r",
															"const interdictionTypologies = [\r",
															"  \"999\"\r",
															"];\r",
															"const ruleDescriptions = {\r",
															"  \"901\": \"Number of outgoing transactions - debtor\",\r",
															"  \"902\": \"Number of incoming transactions - creditor\",\r",
															"  \"EFRuP\": \"Event-Flow Rule Processor\"\r",
															"}\r",
															"const typologyDescriptions = {\r",
															"  \"999\": \"Test typology 999 with rule 901, 902 and the EFRuP\"\r",
															"}\r",
															"\r",
															"const typologyResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult.map((e) => [e.id, e])).values()];\r",
															"const ruleResultsUnique = [...new Map(resJson.result[0].report.tadpResult.typologyResult[0].ruleResults.map((e) => [e.id, e])).values()];\r",
															"\r",
															"typologyCount = typologyResultsUnique.count();\r",
															"ruleCount = ruleResultsUnique.count();\r",
															"\r",
															"foundEFRuP = false;\r",
															"for (let i = 0; i < ruleResultsUnique.length; i++) {\r",
															"    if (ruleResultsUnique[i].id == \"EFRuP@1.0.0\") {\r",
															"        blockingOutcome = ruleResultsUnique[i].subRuleRef;\r",
															"        foundEFRuP = true;\r",
															"    }\r",
															"}\r",
															"\r",
															"ruleWeightingTotal = 0;\r",
															"for (let i = 0; i < typologyResultsUnique[0].ruleResults.length; i++) {\r",
															"    if (ruleResultsUnique[i].id != \"EFRuP@1.0.0\") {\r",
															"        ruleWeightingTotal += typologyResultsUnique[0].ruleResults[i].wght;\r",
															"    }    \r",
															"}\r",
															"\r",
															"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
															"    pm.expect(resJson.result[0].report.status).to.equal(expectedAlertStatus);\r",
															"});\r",
															"\r",
															"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
															"    pm.expect(typologyCount).to.equal(totalExpectedTypologies);\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains ${rulesPerTypologyCount[0]} rule results`, function () {\r",
															"    pm.expect(typologyResultsUnique[0].ruleResults.length).to.equal(rulesPerTypologyCount[0]);\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} contains Event Flow Rule Processor rule results`, function () {\r",
															"    pm.expect(foundEFRuP).to.be.true;\r",
															"});\r",
															"\r",
															"pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
															"    pm.expect(typologyResultsUnique[0].result).to.equal(ruleWeightingTotal);\r",
															"});\r",
															"\r",
															"if (!expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedTypologyAlert && !expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) did not breach interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.lessThan(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedTypologyAlert && expectedTypologyInterdiction) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached alert threshold (${typologyResultsUnique[0].workflow.alertThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.alertThreshold);\r",
															"    });\r",
															"\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} result (${typologyResultsUnique[0].result}) breached interdiction threshold (${typologyResultsUnique[0].workflow.interdictionThreshold})`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].result).to.be.greaterThanOrEqual(typologyResultsUnique[0].workflow.interdictionThreshold);\r",
															"    });\r",
															"}\r",
															"\r",
															"if (expectedReviewFlag) {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is true`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].review).to.be.true;\r",
															"    });\r",
															"} else {\r",
															"    pm.test(`Typology ${typologyResultsUnique[0].cfg} review flag is false`, function () {\r",
															"        pm.expect(typologyResultsUnique[0].review).to.be.false;\r",
															"    });\r",
															"}\r",
															"\r",
															"pm.test(`Event Flow Rule Processor result is \"${expectedBlockingOutcome}\"`, function () {\r",
															"        pm.expect(blockingOutcome).to.be.eql(expectedBlockingOutcome);\r",
															"    });\r",
															"\r",
															"pm.test(`No response received at EFRuP interdiction service before timeout`, function () {\r",
															"        pm.expect(pm.globals.get('responseTimedOut')).to.be.eql(expectedResponseTimedOut);\r",
															"    });"
														],
														"type": "text/javascript",
														"packages": {}
													}
												}
											],
											"request": {
												"auth": {
													"type": "bearer",
													"bearer": [
														{
															"key": "token",
															"value": "{{auth-token}}",
															"type": "string"
														}
													]
												},
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{arangoUrl}}/_db/{{db_results}}/_api/cursor",
													"host": [
														"{{arangoUrl}}"
													],
													"path": [
														"_db",
														"{{db_results}}",
														"_api",
														"cursor"
													]
												}
											},
											"response": []
										}
									]
								}
							]
						}
					]
				}
			]
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"packages": {},
				"requests": {},
				"exec": [
					"const uuid = require('uuid');\r",
					"const lodash = require('lodash');\r",
					"\r",
					"const LOGLEVEL = \"ERROR\";\r",
					"const TENANT_DEFAULT = \"DEFAULT\";\r",
					"\r",
					"// Message creation defaults\r",
					"const DEBTOR_ID_TYPE = \"TAZAMA_EID\";\r",
					"const DEBTOR_ACCOUNT_TYPE = \"MSISDN\";\r",
					"const DEBTOR_AGENT_ID = \"fsp001\";\r",
					"const CREDITOR_ID_TYPE = \"TAZAMA_EID\";\r",
					"const CREDITOR_ACCOUNT_TYPE = \"MSISDN\";\r",
					"const CREDITOR_AGENT_ID = \"fsp002\";\r",
					"\r",
					"// Postman environment variables\r",
					"const POSTGRES_API_URL = `${pm.environment.get('hasuraUrl')}/v1/graphql`;\r",
					"const POSTGRES_API_SECRET = pm.environment.get('hasuraPassword');\r",
					"const DB_RAW_HISTORY = pm.environment.get('db_raw_history');\r",
					"const DB_EVENT_HISTORY = pm.environment.get('db_event_history');\r",
					"const DB_EVENT_HISTORY_ENTITY = pm.environment.get('db_event_history_entity');\r",
					"const DB_EVENT_HISTORY_ACCOUNT_HOLDER = pm.environment.get('db_event_history_account_holder');\r",
					"const DB_EVENT_HISTORY_ACCOUNT = pm.environment.get('db_event_history_account');\r",
					"const DB_EVENT_HISTORY_TRANSACTION = pm.environment.get('db_event_history_transaction');\r",
					"const DB_EVENT_HISTORY_CONDITION = pm.environment.get('db_event_history_condition');\r",
					"const DB_RAW_HISTORY_PAIN001 = pm.environment.get('db_raw_history_pain001');\r",
					"const DB_RAW_HISTORY_PAIN013 = pm.environment.get('db_raw_history_pain013');\r",
					"const DB_RAW_HISTORY_PACS008 = pm.environment.get('db_raw_history_pacs008');\r",
					"const DB_RAW_HISTORY_PACS002 = pm.environment.get('db_raw_history_pacs002');\r",
					"\r",
					"prep = {\r",
					"\r",
					"    /**\r",
					"       * Constructs a pain.001.001.11 message for initiating a customer credit transfer.\r",
					"       *\r",
					"       * @param {string} messageIdPain001 - Unique identifier for the message.\r",
					"       * @param {string} timestampPain001 - Timestamp of message creation.\r",
					"       * @param {string} debtorDoB - Date of birth of the debtor.\r",
					"       * @param {string} debtorId - Identifier for the debtor.\r",
					"       * @param {string} debtorAccountId - Account identifier for the debtor.\r",
					"       * @param {string} debtorAccountIdType - Account scheme name for the debtor.\r",
					"       * @param {string} endToEndId - Unique end-to-end transaction identifier.\r",
					"       * @param {string} transactionPurpose - Purpose of the transaction.\r",
					"       * @param {string} instructedCurrency - Currency code for the instructed amount.\r",
					"       * @param {number} instructedAmount - Instructed amount.\r",
					"       * @param {string} interbankSettlementCurrency - Currency code for the equivalent amount.\r",
					"       * @param {number} interbankSettlementAmount - Equivalent amount.\r",
					"       * @param {number} exchangeRateCurrency - Currency in which the rate of exchange is expressed in the currency exchange (assumed to match instructedCurrency).\r",
					"       * @param {number} exchangeRate - Exchange rate applied to the instructed amount to achieve the equivalent amount.\r",
					"       * @param {string} creditorId - Identifier for the creditor.\r",
					"       * @param {string} creditorAccountId - Account identifier for the creditor.\r",
					"       * @param {string} creditorAccountIdType - Account scheme name for the creditor.\r",
					"       * @param {string} transactionDescription - Description of the transaction.\r",
					"       * @param {string} transactionLat - Latitude coordinate of the transaction location.\r",
					"       * @param {string} transactionLong - Longitude coordinate of the transaction location.\r",
					"       * \r",
					"       * @returns {object} A pain.001.001.11 message object for customer credit transfer initiation.\r",
					"       */\r",
					"    prepPain001Msg: function (messageIdPain001, timestampPain001, debtorDoB, debtorId, debtorIdType, debtorAccountId, debtorAccountIdType, debtorAgentId, endToEndId, transactionPurpose, instructedCurrency, instructedAmount, interbankSettlementCurrency, interbankSettlementAmount, exchangeRateCurrency, exchangeRate, creditorId, creditorIdType, creditorAccountId, creditorAccountIdType, creditorAgentId, transactionDescription, transactionLat, transactionLong, dataCache) {\r",
					"\r",
					"        if (LOGLEVEL === \"DEBUG\") {\r",
					"            logStatement = {\r",
					"                \"messageIdPain001\": `${messageIdPain001}`,\r",
					"                \"timestampPain001\": `${timestampPain001}`,\r",
					"                \"debtorDoB\": `${debtorDoB}`,\r",
					"                \"debtorId\": `${debtorId}`,\r",
					"                \"debtorIdType\": `${debtorIdType}`,\r",
					"                \"debtorAccountId\": `${debtorAccountId}`,\r",
					"                \"debtorAccountIdType\": `${debtorAccountIdType}`,\r",
					"                \"debtorAgentId\": `${debtorAgentId}`,\r",
					"                \"endToEndId\": `${endToEndId}`,\r",
					"                \"transactionPurpose\": `${transactionPurpose}`,\r",
					"                \"instructedCurrency\": `${instructedCurrency}`,\r",
					"                \"instructedAmount\": `${instructedAmount}`,\r",
					"                \"interbankSettlementCurrency\": `${interbankSettlementCurrency}`,\r",
					"                \"interbankSettlementAmount\": `${interbankSettlementAmount}`,\r",
					"                \"exchangeRateCurrency\": `${exchangeRateCurrency}`,\r",
					"                \"exchangeRate\": `${exchangeRate}`,\r",
					"                \"creditorId\": `${creditorId}`,\r",
					"                \"creditorIdType\": `${creditorIdType}`,\r",
					"                \"creditorAccountId\": `${creditorAccountId}`,\r",
					"                \"creditorAccountIdType\": `${creditorAccountIdType}`,\r",
					"                \"creditorAgentId\": `${creditorAgentId}`,\r",
					"                \"transactionDescription\": `${transactionDescription}`,\r",
					"                \"transactionLat\": `${transactionLat}`,\r",
					"                \"transactionLong\": `${transactionLong}`\r",
					"            }\r",
					"            console.log(`prepPain001Msg() input parameters:`);\r",
					"            console.log(JSON.stringify(logStatement, null, 2));\r",
					"            console.log(`\"dataCache\": ${JSON.stringify(dataCache, null, 2)}`);\r",
					"        }\r",
					"\r",
					"        message = {\r",
					"            \"TxTp\": \"pain.001.001.11\",\r",
					"            \"CstmrCdtTrfInitn\": {\r",
					"                \"GrpHdr\": {\r",
					"                    \"MsgId\": `${messageIdPain001}`,\r",
					"                    \"CreDtTm\": `${timestampPain001}`,\r",
					"                    \"NbOfTxs\": 1,\r",
					"                    \"InitgPty\": {\r",
					"                        \"Nm\": \"April Blake Grant\",\r",
					"                        \"Id\": {\r",
					"                            \"PrvtId\": {\r",
					"                                \"DtAndPlcOfBirth\": {\r",
					"                                    \"BirthDt\": \"1968-02-01\",\r",
					"                                    \"CityOfBirth\": \"Unknown\",\r",
					"                                    \"CtryOfBirth\": \"ZZ\"\r",
					"                                },\r",
					"                                \"Othr\": [{\r",
					"                                    \"Id\": \"+27730975224\",\r",
					"                                    \"SchmeNm\": {\r",
					"                                        \"Prtry\": `${debtorAccountIdType}`\r",
					"                                    }\r",
					"                                }]\r",
					"                            }\r",
					"                        },\r",
					"                        \"CtctDtls\": {\r",
					"                            \"MobNb\": \"+27-730975224\"\r",
					"                        }\r",
					"                    }\r",
					"                },\r",
					"                \"PmtInf\": {\r",
					"                    \"PmtInfId\": \"5ab4fc7355de4ef8a75b78b00a681ed2\",\r",
					"                    \"PmtMtd\": \"TRA\",\r",
					"                    \"ReqdAdvcTp\": {\r",
					"                        \"DbtAdvc\": {\r",
					"                            \"Cd\": \"ADWD\",\r",
					"                            \"Prtry\": \"Advice with transaction details\"\r",
					"                        }\r",
					"                    },\r",
					"                    \"ReqdExctnDt\": {\r",
					"                        \"Dt\": \"2023-06-02\",\r",
					"                        \"DtTm\": \"2023-06-02T07:50:57.000Z\"\r",
					"                    },\r",
					"                    \"Dbtr\": {\r",
					"                        \"Nm\": \"April Blake Grant\",\r",
					"                        \"Id\": {\r",
					"                            \"PrvtId\": {\r",
					"                                \"DtAndPlcOfBirth\": {\r",
					"                                    \"BirthDt\": `${debtorDoB}`,\r",
					"                                    \"CityOfBirth\": \"Unknown\",\r",
					"                                    \"CtryOfBirth\": \"ZZ\"\r",
					"                                },\r",
					"                                \"Othr\": [{\r",
					"                                    \"Id\": `${debtorId}`,\r",
					"                                    \"SchmeNm\": {\r",
					"                                        \"Prtry\": `${DEBTOR_ID_TYPE}`\r",
					"                                    }\r",
					"                                }]\r",
					"                            }\r",
					"                        },\r",
					"                        \"CtctDtls\": {\r",
					"                            \"MobNb\": \"+27-730975224\"\r",
					"                        }\r",
					"                    },\r",
					"                    \"DbtrAcct\": {\r",
					"                        \"Id\": {\r",
					"                            \"Othr\": [{\r",
					"                                \"Id\": `${debtorAccountId}`,\r",
					"                                \"SchmeNm\": {\r",
					"                                    \"Prtry\": `${debtorAccountIdType}`\r",
					"                                }\r",
					"                            }]\r",
					"                        },\r",
					"                        \"Nm\": \"April Grant\"\r",
					"                    },\r",
					"                    \"DbtrAgt\": {\r",
					"                        \"FinInstnId\": {\r",
					"                            \"ClrSysMmbId\": {\r",
					"                                \"MmbId\": `${debtorAgentId}`\r",
					"                            }\r",
					"                        }\r",
					"                    },\r",
					"                    \"CdtTrfTxInf\": {\r",
					"                        \"PmtId\": {\r",
					"                            \"EndToEndId\": `${endToEndId}`\r",
					"                        },\r",
					"                        \"PmtTpInf\": {\r",
					"                            \"CtgyPurp\": {\r",
					"                                \"Prtry\": `${transactionPurpose}`\r",
					"                            }\r",
					"                        },\r",
					"                        \"Amt\": {\r",
					"                            \"InstdAmt\": {\r",
					"                                \"Amt\": {\r",
					"                                    \"Amt\": instructedAmount,\r",
					"                                    \"Ccy\": `${instructedCurrency}`\r",
					"                                }\r",
					"                            },\r",
					"                            \"EqvtAmt\": {\r",
					"                                \"Amt\": {\r",
					"                                    \"Amt\": interbankSettlementAmount,\r",
					"                                    \"Ccy\": `${interbankSettlementCurrency}`\r",
					"                                },\r",
					"                                \"CcyOfTrf\": `${exchangeRateCurrency}`\r",
					"                            }\r",
					"                        },\r",
					"                        \"XchgRateInf\": {\r",
					"                            \"UnitCcy\": `${exchangeRateCurrency}`,\r",
					"                            \"XchgRate\": exchangeRate\r",
					"                        },\r",
					"                        \"ChrgBr\": \"DEBT\",\r",
					"                        \"CdtrAgt\": {\r",
					"                            \"FinInstnId\": {\r",
					"                                \"ClrSysMmbId\": {\r",
					"                                    \"MmbId\": `${creditorAgentId}`\r",
					"                                }\r",
					"                            }\r",
					"                        },\r",
					"                        \"Cdtr\": {\r",
					"                            \"Nm\": \"Felicia Easton Quill\",\r",
					"                            \"Id\": {\r",
					"                                \"PrvtId\": {\r",
					"                                    \"DtAndPlcOfBirth\": {\r",
					"                                        \"BirthDt\": \"1935-05-08\",\r",
					"                                        \"CityOfBirth\": \"Unknown\",\r",
					"                                        \"CtryOfBirth\": \"ZZ\"\r",
					"                                    },\r",
					"                                    \"Othr\": [{\r",
					"                                        \"Id\": `${creditorId}`,\r",
					"                                        \"SchmeNm\": {\r",
					"                                            \"Prtry\": `${CREDITOR_ID_TYPE}`\r",
					"                                        }\r",
					"                                    }]\r",
					"                                }\r",
					"                            },\r",
					"                            \"CtctDtls\": {\r",
					"                                \"MobNb\": \"+27-707650428\"\r",
					"                            }\r",
					"                        },\r",
					"                        \"CdtrAcct\": {\r",
					"                            \"Id\": {\r",
					"                                \"Othr\": [{\r",
					"                                    \"Id\": `${creditorAccountId}`,\r",
					"                                    \"SchmeNm\": {\r",
					"                                        \"Prtry\": `${creditorAccountIdType}`\r",
					"                                    }\r",
					"                                }]\r",
					"                            },\r",
					"                            \"Nm\": \"Felicia Quill\"\r",
					"                        },\r",
					"                        \"Purp\": {\r",
					"                            \"Cd\": \"MP2P\"\r",
					"                        },\r",
					"                        \"RgltryRptg\": {\r",
					"                            \"Dtls\": {\r",
					"                                \"Tp\": \"BALANCE OF PAYMENTS\",\r",
					"                                \"Cd\": \"100\"\r",
					"                            }\r",
					"                        },\r",
					"                        \"RmtInf\": {\r",
					"                            \"Ustrd\": `${transactionDescription}`\r",
					"                        },\r",
					"                        \"SplmtryData\": {\r",
					"                            \"Envlp\": {\r",
					"                                \"Doc\": {\r",
					"                                    \"Dbtr\": {\r",
					"                                        \"FrstNm\": \"April\",\r",
					"                                        \"MddlNm\": \"Blake\",\r",
					"                                        \"LastNm\": \"Grant\",\r",
					"                                        \"MrchntClssfctnCd\": \"BLANK\"\r",
					"                                    },\r",
					"                                    \"Cdtr\": {\r",
					"                                        \"FrstNm\": \"Felicia\",\r",
					"                                        \"MddlNm\": \"Easton\",\r",
					"                                        \"LastNm\": \"Quill\",\r",
					"                                        \"MrchntClssfctnCd\": \"BLANK\"\r",
					"                                    },\r",
					"                                    \"DbtrFinSvcsPrvdrFees\": {\r",
					"                                        \"Ccy\": `${instructedCurrency}`,\r",
					"                                        \"Amt\": 0.00\r",
					"                                    },\r",
					"                                    \"Xprtn\": \"2021-11-30T10:38:56.000Z\"\r",
					"                                }\r",
					"                            }\r",
					"                        }\r",
					"                    }\r",
					"                },\r",
					"                \"SplmtryData\": {\r",
					"                    \"Envlp\": {\r",
					"                        \"Doc\": {\r",
					"                            \"InitgPty\": {\r",
					"                                \"InitrTp\": \"CONSUMER\",\r",
					"                                \"Glctn\": {\r",
					"                                    \"Lat\": `${transactionLat}`,\r",
					"                                    \"Long\": `${transactionLong}`\r",
					"                                }\r",
					"                            }\r",
					"                        }\r",
					"                    }\r",
					"                }\r",
					"            },\r",
					"            \"DataCache\": dataCache\r",
					"        };\r",
					"\r",
					"        if (LOGLEVEL === 'DEBUG') {\r",
					"            console.log(\"Prepared pain.001.001.11 message:\", JSON.stringify(message));\r",
					"        }\r",
					"\r",
					"        return message;\r",
					"    },\r",
					"\r",
					"    /**\r",
					"       * Constructs a pain.013.001.09 message for initiating a creditor payment activation request.\r",
					"       *\r",
					"       * @param {string} messageIdPain013 - Unique identifier for the message.\r",
					"       * @param {string} timestampPain013 - Timestamp of message creation.\r",
					"       * @param {string} debtorDoB - Date of birth of the debtor.\r",
					"       * @param {string} debtorId - Identifier for the debtor.\r",
					"       * @param {string} debtorAccountId - Account identifier for the debtor.\r",
					"       * @param {string} debtorAccountIdType - Account scheme name for the debtor.\r",
					"       * @param {string} endToEndId - Unique end-to-end transaction identifier.\r",
					"       * @param {string} currency - Currency code for the transaction amount.\r",
					"       * @param {number} amount - Transaction amount.\r",
					"       * @param {string} creditorId - Identifier for the creditor.\r",
					"       * @param {string} creditorAccountId - Account identifier for the creditor.\r",
					"       * @param {string} creditorAccountIdType - Account scheme name for the creditor.\r",
					"       * @param {string} transactionLat - Latitude coordinate of the transaction location.\r",
					"       * @param {string} transactionLong - Longitude coordinate of the transaction location.\r",
					"       * \r",
					"       * @returns {object} A pain.013.001.09 message object for creditor payment activation request.\r",
					"       */\r",
					"    prepPain013Msg: function (messageIdPain013, timestampPain013, debtorDoB, debtorId, debtorIdType, debtorAccountId, debtorAccountIdType, debtorAgentId, endToEndId, instructedCurrency, instructedAmount, interbankSettlementCurrency, interbankSettlementAmount, creditorId, creditorIdType, creditorAccountId, creditorAccountIdType, creditorAgentId, transactionLat, transactionLong, dataCache) {\r",
					"\r",
					"        if (LOGLEVEL === \"DEBUG\") {\r",
					"            logStatement = {\r",
					"                \"messageIdPain013\": `${messageIdPain013}`,\r",
					"                \"timestampPain013\": `${timestampPain013}`,\r",
					"                \"debtorDoB\": `${debtorDoB}`,\r",
					"                \"debtorId\": `${debtorId}`,\r",
					"                \"debtorIdType\": `${debtorIdType}`,\r",
					"                \"debtorAccountId\": `${debtorAccountId}`,\r",
					"                \"debtorAccountIdType\": `${debtorAccountIdType}`,\r",
					"                \"debtorAgentId\": `${debtorAgentId}`,\r",
					"                \"endToEndId\": `${endToEndId}`,\r",
					"                \"instructedCurrency\": `${instructedCurrency}`,\r",
					"                \"instructedAmount\": `${instructedAmount}`,\r",
					"                \"interbankSettlementCurrency\": `${interbankSettlementCurrency}`,\r",
					"                \"interbankSettlementAmount\": `${interbankSettlementAmount}`,\r",
					"                \"creditorId\": `${creditorId}`,\r",
					"                \"creditorIdType\": `${creditorIdType}`,\r",
					"                \"creditorAccountId\": `${creditorAccountId}`,\r",
					"                \"creditorAccountIdType\": `${creditorAccountIdType}`,\r",
					"                \"creditorAgentId\": `${creditorAgentId}`,\r",
					"                \"transactionLat\": `${transactionLat}`,\r",
					"                \"transactionLong\": `${transactionLong}`\r",
					"            }\r",
					"            console.log(`prepPain013Msg() input parameters:`);\r",
					"            console.log(JSON.stringify(logStatement, null, 2));\r",
					"            console.log(`\"dataCache\": ${JSON.stringify(dataCache, null, 2)}`);\r",
					"        }\r",
					"\r",
					"        message = {\r",
					"            \"TxTp\": \"pain.013.001.09\",\r",
					"            \"CdtrPmtActvtnReq\": {\r",
					"                \"GrpHdr\": {\r",
					"                    \"MsgId\": `${messageIdPain013}`,\r",
					"                    \"CreDtTm\": `${timestampPain013}`,\r",
					"                    \"NbOfTxs\": 1,\r",
					"                    \"InitgPty\": {\r",
					"                        \"Nm\": \"April Blake Grant\",\r",
					"                        \"Id\": {\r",
					"                            \"PrvtId\": {\r",
					"                                \"DtAndPlcOfBirth\": {\r",
					"                                    \"BirthDt\": \"1968-02-01\",\r",
					"                                    \"CityOfBirth\": \"Unknown\",\r",
					"                                    \"CtryOfBirth\": \"ZZ\"\r",
					"                                },\r",
					"                                \"Othr\": [{\r",
					"                                    \"Id\": \"+27730975224\",\r",
					"                                    \"SchmeNm\": {\r",
					"                                        \"Prtry\": `${debtorAccountIdType}`\r",
					"                                    }\r",
					"                                }]\r",
					"                            }\r",
					"                        },\r",
					"                        \"CtctDtls\": {\r",
					"                            \"MobNb\": \"+27-730975224\"\r",
					"                        }\r",
					"                    }\r",
					"                },\r",
					"                \"PmtInf\": {\r",
					"                    \"PmtInfId\": \"5ab4fc7355de4ef8a75b78b00a681ed2\",\r",
					"                    \"PmtMtd\": \"TRA\",\r",
					"                    \"ReqdAdvcTp\": {\r",
					"                        \"DbtAdvc\": {\r",
					"                            \"Cd\": \"ADWD\",\r",
					"                            \"Prtry\": \"Advice with transaction details\"\r",
					"                        }\r",
					"                    },\r",
					"                    \"ReqdExctnDt\": {\r",
					"                        \"DtTm\": \"2023-06-02T07:51:48.000Z\"\r",
					"                    },\r",
					"                    \"XpryDt\": {\r",
					"                        \"DtTm\": \"2021-11-30T10:38:56.000Z\"\r",
					"                    },\r",
					"                    \"Dbtr\": {\r",
					"                        \"Nm\": \"April Blake Grant\",\r",
					"                        \"Id\": {\r",
					"                            \"PrvtId\": {\r",
					"                                \"DtAndPlcOfBirth\": {\r",
					"                                    \"BirthDt\": `${debtorDoB}`,\r",
					"                                    \"CityOfBirth\": \"Unknown\",\r",
					"                                    \"CtryOfBirth\": \"ZZ\"\r",
					"                                },\r",
					"                                \"Othr\": [{\r",
					"                                    \"Id\": `${debtorId}`,\r",
					"                                    \"SchmeNm\": {\r",
					"                                        \"Prtry\": `${DEBTOR_ID_TYPE}`\r",
					"                                    }\r",
					"                                }]\r",
					"                            }\r",
					"                        },\r",
					"                        \"CtctDtls\": {\r",
					"                            \"MobNb\": \"+27-730975224\"\r",
					"                        }\r",
					"                    },\r",
					"                    \"DbtrAcct\": {\r",
					"                        \"Id\": {\r",
					"                            \"Othr\": [{\r",
					"                                \"Id\": `${debtorAccountId}`,\r",
					"                                \"SchmeNm\": {\r",
					"                                    \"Prtry\": `${debtorAccountIdType}`\r",
					"                                }\r",
					"                            }]\r",
					"                        },\r",
					"                        \"Nm\": \"April Grant\"\r",
					"                    },\r",
					"                    \"DbtrAgt\": {\r",
					"                        \"FinInstnId\": {\r",
					"                            \"ClrSysMmbId\": {\r",
					"                                \"MmbId\": `${debtorAgentId}`\r",
					"                            }\r",
					"                        }\r",
					"                    },\r",
					"                    \"CdtTrfTxInf\": {\r",
					"                        \"PmtId\": {\r",
					"                            \"EndToEndId\": `${endToEndId}`\r",
					"                        },\r",
					"                        \"PmtTpInf\": {\r",
					"                            \"CtgyPurp\": {\r",
					"                                \"Prtry\": \"TRANSFER BLANK\"\r",
					"                            }\r",
					"                        },\r",
					"                        \"Amt\": {\r",
					"                            \"InstdAmt\": {\r",
					"                                \"Amt\": {\r",
					"                                    \"Amt\": instructedAmount,\r",
					"                                    \"Ccy\": `${instructedCurrency}`\r",
					"                                }\r",
					"                            },\r",
					"                            \"EqvtAmt\": {\r",
					"                                \"Amt\": {\r",
					"                                    \"Amt\": interbankSettlementAmount,\r",
					"                                    \"Ccy\": `${interbankSettlementCurrency}`\r",
					"                                },\r",
					"                                \"CcyOfTrf\": `${instructedCurrency}`\r",
					"                            }\r",
					"                        },\r",
					"                        \"ChrgBr\": \"DEBT\",\r",
					"                        \"CdtrAgt\": {\r",
					"                            \"FinInstnId\": {\r",
					"                                \"ClrSysMmbId\": {\r",
					"                                    \"MmbId\": `${creditorAgentId}`\r",
					"                                }\r",
					"                            }\r",
					"                        },\r",
					"                        \"Cdtr\": {\r",
					"                            \"Nm\": \"Felicia Easton Quill\",\r",
					"                            \"Id\": {\r",
					"                                \"PrvtId\": {\r",
					"                                    \"DtAndPlcOfBirth\": {\r",
					"                                        \"BirthDt\": \"1935-05-08\",\r",
					"                                        \"CityOfBirth\": \"Unknown\",\r",
					"                                        \"CtryOfBirth\": \"ZZ\"\r",
					"                                    },\r",
					"                                    \"Othr\": [{\r",
					"                                        \"Id\": `${creditorId}`,\r",
					"                                        \"SchmeNm\": {\r",
					"                                            \"Prtry\": `${CREDITOR_ID_TYPE}`\r",
					"                                        }\r",
					"                                    }]\r",
					"                                }\r",
					"                            },\r",
					"                            \"CtctDtls\": {\r",
					"                                \"MobNb\": \"+27-707650428\"\r",
					"                            }\r",
					"                        },\r",
					"                        \"CdtrAcct\": {\r",
					"                            \"Id\": {\r",
					"                                \"Othr\": [{\r",
					"                                    \"Id\": `${creditorAccountId}`,\r",
					"                                    \"SchmeNm\": {\r",
					"                                        \"Prtry\": `${creditorAccountIdType}`\r",
					"                                    }\r",
					"                                }]\r",
					"                            },\r",
					"                            \"Nm\": \"Felicia Quill\"\r",
					"                        },\r",
					"                        \"Purp\": {\r",
					"                            \"Cd\": \"MP2P\"\r",
					"                        },\r",
					"                        \"RgltryRptg\": {\r",
					"                            \"Dtls\": {\r",
					"                                \"Tp\": \"BALANCE OF PAYMENTS\",\r",
					"                                \"Cd\": \"100\"\r",
					"                            }\r",
					"                        },\r",
					"                        \"SplmtryData\": {\r",
					"                            \"Envlp\": {\r",
					"                                \"Doc\": {\r",
					"                                    \"PyeeRcvAmt\": {\r",
					"                                        \"Amt\": {\r",
					"                                            \"Amt\": 0.00,\r",
					"                                            \"Ccy\": `${instructedCurrency}`\r",
					"                                        }\r",
					"                                    },\r",
					"                                    \"PyeeFinSvcsPrvdrFee\": {\r",
					"                                        \"Amt\": {\r",
					"                                            \"Amt\": 0.00,\r",
					"                                            \"Ccy\": `${instructedCurrency}`\r",
					"                                        }\r",
					"                                    },\r",
					"                                    \"PyeeFinSvcsPrvdrComssn\": {\r",
					"                                        \"Amt\": {\r",
					"                                            \"Amt\": 0.00,\r",
					"                                            \"Ccy\": `${instructedCurrency}`\r",
					"                                        }\r",
					"                                    }\r",
					"                                }\r",
					"                            }\r",
					"                        }\r",
					"                    }\r",
					"                },\r",
					"                \"SplmtryData\": {\r",
					"                    \"Envlp\": {\r",
					"                        \"Doc\": {\r",
					"                            \"InitgPty\": {\r",
					"                                \"Glctn\": {\r",
					"                                    \"Lat\": `${transactionLat}`,\r",
					"                                    \"Long\": `${transactionLong}`\r",
					"                                }\r",
					"                            }\r",
					"                        }\r",
					"                    }\r",
					"                }\r",
					"            },\r",
					"            \"DataCache\": dataCache\r",
					"        };\r",
					"\r",
					"        if (LOGLEVEL === 'DEBUG') {\r",
					"            console.log(\"Pain.013.001.09 Message:\", JSON.stringify(message));\r",
					"        }\r",
					"\r",
					"        return message;\r",
					"    },\r",
					"\r",
					"    /**\r",
					"       * Constructs a pacs.008.001.10 message for initiating a financial institution to financial institution customer credit transfer.\r",
					"       *\r",
					"       * @param {string} messageIdPacs008 - Unique identifier for the message.\r",
					"       * @param {string} timestampPacs008 - Timestamp of message creation.\r",
					"       * @param {string} endToEndId - Unique end-to-end transaction identifier.\r",
					"       * @param {string} instructedCurrency - Currency code for the instructed amount.\r",
					"       * @param {number} instructedAmount - Instructed amount.\r",
					"       * @param {string} interbankSettlementCurrency - Currency code for the interbank settlement amount.\r",
					"       * @param {number} interbankSettlementAmount - Interbank settlement amount.\r",
					"       * @param {number} exchangeRate - Exchange rate applied to the instructed amount to achieve the interbank settlement amount.\r",
					"       * @param {string} debtorDoB - Date of birth of the debtor.\r",
					"       * @param {string} debtorId - Identifier for the debtor.\r",
					"       * @param {string} debtorAccountId - Account identifier for the debtor.\r",
					"       * @param {string} debtorAccountIdType - Account scheme name for the debtor.\r",
					"       * @param {string} creditorId - Identifier for the creditor.\r",
					"       * @param {string} creditorAccountId - Account identifier for the creditor.\r",
					"       * @param {string} creditorAccountIdType - Account scheme name for the creditor.\r",
					"       * @param {string} transactionPurpose - Purpose of the transaction.\r",
					"       * @param {string} transactionDescription - Description of the transaction.\r",
					"       * @param {string} transactionLat - Latitude coordinate of the transaction location.\r",
					"       * @param {string} transactionLong - Longitude coordinate of the transaction location.\r",
					"       * \r",
					"       * @returns {object} A pacs.008.001.10 message object for financial institution to financial institution customer credit transfer.\r",
					"       */\r",
					"    prepPacs008Msg: function (messageIdPacs008, timestampPacs008, endToEndId, instructedCurrency, instructedAmount, interbankSettlementCurrency, interbankSettlementAmount, exchangeRate, debtorDoB, debtorId, debtorIdType, debtorAccountId, debtorAccountIdType, debtorAgentId, creditorId, creditorIdType, creditorAccountId, creditorAccountIdType, creditorAgentId, transactionPurpose, transactionDescription, transactionLat, transactionLong, dataCache) {\r",
					"\r",
					"        if (LOGLEVEL === \"DEBUG\") {\r",
					"            logStatement = {\r",
					"                \"messageIdPacs008\": `${messageIdPacs008}`,\r",
					"                \"timestampPacs008\": `${timestampPacs008}`,\r",
					"                \"endToEndId\": `${endToEndId}`,\r",
					"                \"instructedCurrency\": `${instructedCurrency}`,\r",
					"                \"instructedAmount\": `${instructedAmount}`,\r",
					"                \"interbankSettlementCurrency\": `${interbankSettlementCurrency}`,\r",
					"                \"interbankSettlementAmount\": `${interbankSettlementAmount}`,\r",
					"                \"exchangeRate\": `${exchangeRate}`,\r",
					"                \"debtorDoB\": `${debtorDoB}`,\r",
					"                \"debtorId\": `${debtorId}`,\r",
					"                \"debtorIdType\": `${debtorIdType}`,\r",
					"                \"debtorAccountId\": `${debtorAccountId}`,\r",
					"                \"debtorAccountIdType\": `${debtorAccountIdType}`,\r",
					"                \"debtorAgentId\": `${debtorAgentId}`,\r",
					"                \"creditorId\": `${creditorId}`,\r",
					"                \"creditorIdType\": `${creditorIdType}`,\r",
					"                \"creditorAccountId\": `${creditorAccountId}`,\r",
					"                \"creditorAccountIdType\": `${creditorAccountIdType}`,\r",
					"                \"creditorAgentId\": `${creditorAgentId}`,\r",
					"                \"transactionPurpose\": `${transactionPurpose}`,\r",
					"                \"transactionDescription\": `${transactionDescription}`,\r",
					"                \"transactionLat\": `${transactionLat}`,\r",
					"                \"transactionLong\": `${transactionLong}`\r",
					"            }\r",
					"            console.log(`prepPacs008Msg() input parameters:`);\r",
					"            console.log(JSON.stringify(logStatement, null, 2));\r",
					"            console.log(`\"dataCache\": ${JSON.stringify(dataCache, null, 2)}`);\r",
					"        }\r",
					"\r",
					"        message = {\r",
					"            \"TxTp\": \"pacs.008.001.10\",\r",
					"            \"FIToFICstmrCdtTrf\": {\r",
					"                \"GrpHdr\": {\r",
					"                    \"MsgId\": `${messageIdPacs008}`,\r",
					"                    \"CreDtTm\": `${timestampPacs008}`,\r",
					"                    \"NbOfTxs\": 1,\r",
					"                    \"SttlmInf\": {\r",
					"                        \"SttlmMtd\": \"CLRG\"\r",
					"                    }\r",
					"                },\r",
					"                \"CdtTrfTxInf\": {\r",
					"                    \"PmtId\": {\r",
					"                        \"InstrId\": \"5ab4fc7355de4ef8a75b78b00a681ed2\",\r",
					"                        \"EndToEndId\": `${endToEndId}`\r",
					"                    },\r",
					"                    \"IntrBkSttlmAmt\": {\r",
					"                        \"Amt\": {\r",
					"                            \"Amt\": interbankSettlementAmount,\r",
					"                            \"Ccy\": `${interbankSettlementCurrency}`\r",
					"                        }\r",
					"                    },\r",
					"                    \"InstdAmt\": {\r",
					"                        \"Amt\": {\r",
					"                            \"Amt\": instructedAmount,\r",
					"                            \"Ccy\": `${instructedCurrency}`\r",
					"                        }\r",
					"                    },\r",
					"                    \"XchgRate\": exchangeRate,\r",
					"                    \"ChrgBr\": \"DEBT\",\r",
					"                    \"ChrgsInf\": {\r",
					"                        \"Amt\": {\r",
					"                            \"Amt\": 0.00,\r",
					"                            \"Ccy\": `${instructedCurrency}`\r",
					"                        },\r",
					"                        \"Agt\": {\r",
					"                            \"FinInstnId\": {\r",
					"                                \"ClrSysMmbId\": {\r",
					"                                    \"MmbId\": `${debtorAgentId}`\r",
					"                                }\r",
					"                            }\r",
					"                        }\r",
					"                    },\r",
					"                    \"InitgPty\": {\r",
					"                        \"Nm\": \"April Blake Grant\",\r",
					"                        \"Id\": {\r",
					"                            \"PrvtId\": {\r",
					"                                \"DtAndPlcOfBirth\": {\r",
					"                                    \"BirthDt\": \"1968-02-01\",\r",
					"                                    \"CityOfBirth\": \"Unknown\",\r",
					"                                    \"CtryOfBirth\": \"ZZ\"\r",
					"                                },\r",
					"                                \"Othr\": [{\r",
					"                                    \"Id\": \"+27730975224\",\r",
					"                                    \"SchmeNm\": {\r",
					"                                        \"Prtry\": `${debtorAccountIdType}`\r",
					"                                    }\r",
					"                                }]\r",
					"                            }\r",
					"                        },\r",
					"                        \"CtctDtls\": {\r",
					"                            \"MobNb\": \"+27-730975224\"\r",
					"                        }\r",
					"                    },\r",
					"                    \"Dbtr\": {\r",
					"                        \"Nm\": \"April Blake Grant\",\r",
					"                        \"Id\": {\r",
					"                            \"PrvtId\": {\r",
					"                                \"DtAndPlcOfBirth\": {\r",
					"                                    \"BirthDt\": `${debtorDoB}`,\r",
					"                                    \"CityOfBirth\": \"Unknown\",\r",
					"                                    \"CtryOfBirth\": \"ZZ\"\r",
					"                                },\r",
					"                                \"Othr\": [{\r",
					"                                    \"Id\": `${debtorId}`,\r",
					"                                    \"SchmeNm\": {\r",
					"                                        \"Prtry\": `${DEBTOR_ID_TYPE}`\r",
					"                                    }\r",
					"                                }]\r",
					"                            }\r",
					"                        },\r",
					"                        \"CtctDtls\": {\r",
					"                            \"MobNb\": \"+27-730975224\"\r",
					"                        }\r",
					"                    },\r",
					"                    \"DbtrAcct\": {\r",
					"                        \"Id\": {\r",
					"                            \"Othr\": [{\r",
					"                                \"Id\": `${debtorAccountId}`,\r",
					"                                \"SchmeNm\": {\r",
					"                                    \"Prtry\": `${debtorAccountIdType}`\r",
					"                                }\r",
					"                            }]\r",
					"                        },\r",
					"                        \"Nm\": \"April Grant\"\r",
					"                    },\r",
					"                    \"DbtrAgt\": {\r",
					"                        \"FinInstnId\": {\r",
					"                            \"ClrSysMmbId\": {\r",
					"                                \"MmbId\": `${debtorAgentId}`\r",
					"                            }\r",
					"                        }\r",
					"                    },\r",
					"                    \"CdtrAgt\": {\r",
					"                        \"FinInstnId\": {\r",
					"                            \"ClrSysMmbId\": {\r",
					"                                \"MmbId\": `${creditorAgentId}`\r",
					"                            }\r",
					"                        }\r",
					"                    },\r",
					"                    \"Cdtr\": {\r",
					"                        \"Nm\": \"Felicia Easton Quill\",\r",
					"                        \"Id\": {\r",
					"                            \"PrvtId\": {\r",
					"                                \"DtAndPlcOfBirth\": {\r",
					"                                    \"BirthDt\": \"1935-05-08\",\r",
					"                                    \"CityOfBirth\": \"Unknown\",\r",
					"                                    \"CtryOfBirth\": \"ZZ\"\r",
					"                                },\r",
					"                                \"Othr\": [{\r",
					"                                    \"Id\": `${creditorId}`,\r",
					"                                    \"SchmeNm\": {\r",
					"                                        \"Prtry\": `${CREDITOR_ID_TYPE}`\r",
					"                                    }\r",
					"                                }]\r",
					"                            }\r",
					"                        },\r",
					"                        \"CtctDtls\": {\r",
					"                            \"MobNb\": \"+27-707650428\"\r",
					"                        }\r",
					"                    },\r",
					"                    \"CdtrAcct\": {\r",
					"                        \"Id\": {\r",
					"                            \"Othr\": [{\r",
					"                                \"Id\": `${creditorAccountId}`,\r",
					"                                \"SchmeNm\": {\r",
					"                                    \"Prtry\": `${creditorAccountIdType}`\r",
					"                                }\r",
					"                            }]\r",
					"                        },\r",
					"                        \"Nm\": \"Felicia Quill\"\r",
					"                    },\r",
					"                    \"Purp\": {\r",
					"                        \"Cd\": `${transactionPurpose}`\r",
					"                    }\r",
					"                },\r",
					"                \"RgltryRptg\": {\r",
					"                    \"Dtls\": {\r",
					"                        \"Tp\": \"BALANCE OF PAYMENTS\",\r",
					"                        \"Cd\": \"100\"\r",
					"                    }\r",
					"                },\r",
					"                \"RmtInf\": {\r",
					"                    \"Ustrd\": `${transactionDescription}`\r",
					"                },\r",
					"                \"SplmtryData\": {\r",
					"                    \"Envlp\": {\r",
					"                        \"Doc\": {\r",
					"                            \"Xprtn\": \"2021-11-30T10:38:56.000Z\",\r",
					"                            \"InitgPty\": {\r",
					"                                \"Glctn\":\r",
					"                                {\r",
					"                                    \"Lat\": `${transactionLat}`,\r",
					"                                    \"Long\": `${transactionLong}`\r",
					"                                }\r",
					"                            }\r",
					"                        }\r",
					"                    }\r",
					"                }\r",
					"            },\r",
					"            \"DataCache\": dataCache\r",
					"        }\r",
					"\r",
					"        if (LOGLEVEL === 'DEBUG') {\r",
					"            console.log(\"pacs.008.001.10 message details:\", JSON.stringify(message));\r",
					"        }\r",
					"\r",
					"        return message;\r",
					"    },\r",
					"\r",
					"    /**\r",
					"       * Constructs a pacs.002.001.12 message for financial institution to financial institution payment status reporting.\r",
					"       *\r",
					"       * @param {string} messageIdPacs002 - Unique identifier for the message.\r",
					"       * @param {string} timestampPacs002 - Timestamp of message creation.\r",
					"       * @param {string} endToEndId - Unique end-to-end transaction identifier.\r",
					"       * @param {string} pacs002Sts - Transaction status.\r",
					"       * \r",
					"       * @returns {object} A pacs.002.001.12 message object for financial institution to financial institution payment status reporting.\r",
					"       */\r",
					"    prepPacs002Msg: function (messageIdPacs002, timestampPacs002, endToEndId, pacs002Sts, debtorAgentId, creditorAgentId, dataCache) {\r",
					"\r",
					"        if (LOGLEVEL === \"DEBUG\") {\r",
					"            logStatement = {\r",
					"                \"messageIdPacs002\": `${messageIdPacs002}`,\r",
					"                \"timestampPacs002\": `${timestampPacs002}`,\r",
					"                \"endToEndId\": `${endToEndId}`,\r",
					"                \"pacs002Sts\": `${pacs002Sts}`,\r",
					"                \"debtorAgentId\": `${debtorAgentId}`,\r",
					"                \"creditorAgentId\": `${creditorAgentId}`\r",
					"            }\r",
					"            console.log(`prepPacs002Msg() input parameters:`);\r",
					"            console.log(JSON.stringify(logStatement, null, 2));\r",
					"            console.log(`\"dataCache\": ${JSON.stringify(dataCache, null, 2)}`);\r",
					"        }\r",
					"\r",
					"        message = {\r",
					"            \"TxTp\": \"pacs.002.001.12\",\r",
					"            \"FIToFIPmtSts\": {\r",
					"                \"GrpHdr\": {\r",
					"                    \"MsgId\": `${messageIdPacs002}`,\r",
					"                    \"CreDtTm\": `${timestampPacs002}`\r",
					"                },\r",
					"                \"TxInfAndSts\": {\r",
					"                    \"OrgnlInstrId\": \"5ab4fc7355de4ef8a75b78b00a681ed2\",\r",
					"                    \"OrgnlEndToEndId\": `${endToEndId}`,\r",
					"                    \"TxSts\": `${pacs002Sts}`,\r",
					"                    \"ChrgsInf\": [\r",
					"                        {\r",
					"                            \"Amt\": {\r",
					"                                \"Amt\": 0.00,\r",
					"                                \"Ccy\": \"USD\"\r",
					"                            },\r",
					"                            \"Agt\": {\r",
					"                                \"FinInstnId\": {\r",
					"                                    \"ClrSysMmbId\": {\r",
					"                                        \"MmbId\": `${debtorAgentId}`\r",
					"                                    }\r",
					"                                }\r",
					"                            }\r",
					"                        },\r",
					"                        {\r",
					"                            \"Amt\": {\r",
					"                                \"Amt\": 0.00,\r",
					"                                \"Ccy\": \"USD\"\r",
					"                            },\r",
					"                            \"Agt\": {\r",
					"                                \"FinInstnId\": {\r",
					"                                    \"ClrSysMmbId\": {\r",
					"                                        \"MmbId\": `${debtorAgentId}`\r",
					"                                    }\r",
					"                                }\r",
					"                            }\r",
					"                        },\r",
					"                        {\r",
					"                            \"Amt\": {\r",
					"                                \"Amt\": 0.00,\r",
					"                                \"Ccy\": \"USD\"\r",
					"                            },\r",
					"                            \"Agt\": {\r",
					"                                \"FinInstnId\": {\r",
					"                                    \"ClrSysMmbId\": {\r",
					"                                        \"MmbId\": `${creditorAgentId}`\r",
					"                                    }\r",
					"                                }\r",
					"                            }\r",
					"                        }\r",
					"                    ],\r",
					"                    \"AccptncDtTm\": \"2023-06-02T07:52:31.000Z\",\r",
					"                    \"InstgAgt\": {\r",
					"                        \"FinInstnId\": {\r",
					"                            \"ClrSysMmbId\": {\r",
					"                                \"MmbId\": `${debtorAgentId}`\r",
					"                            }\r",
					"                        }\r",
					"                    },\r",
					"                    \"InstdAgt\": {\r",
					"                        \"FinInstnId\": {\r",
					"                            \"ClrSysMmbId\": {\r",
					"                                \"MmbId\": `${creditorAgentId}`\r",
					"                            }\r",
					"                        }\r",
					"                    }\r",
					"                }\r",
					"            },\r",
					"            \"DataCache\": dataCache\r",
					"        };\r",
					"\r",
					"        if (LOGLEVEL === 'DEBUG') {\r",
					"            console.log(\"pacs.002.001.12 message details:\", JSON.stringify(message));\r",
					"        }\r",
					"\r",
					"        return message;\r",
					"    },\r",
					"\r",
					"    /**\r",
					"       * Constructs a DB-ready event entity.\r",
					"       *\r",
					"       * @param {string} tenantId - Identifier for the tenant.\r",
					"       * @param {string} entityKey - Identifier for the entity.\r",
					"       * @param {string} timestamp - Timestamp of entity creation.\r",
					"       * \r",
					"       * @returns {Array}  DB-ready entity containing an identifier and a creation timestamp.\r",
					"       */\r",
					"    prepEntity: function (tenantId, entityKey, timestamp) {\r",
					"\r",
					"        entity = {\r",
					"            \"id\": entityKey,\r",
					"            \"tenantid\": tenantId,\r",
					"            \"credttm\": timestamp\r",
					"        };\r",
					"\r",
					"        if (LOGLEVEL === 'DEBUG') {\r",
					"            console.log(\"Event entities:\", JSON.stringify(entity, null, 2));\r",
					"        }\r",
					"\r",
					"        return entity;\r",
					"    },\r",
					"\r",
					"    /**\r",
					"       * Constructs a DB-ready relationship between an account holder and their account.\r",
					"       *\r",
					"       * @param {string} tenantId - Identifier for the tenant.\r",
					"       * @param {string} entityKey - Identifier for the entity.\r",
					"       * @param {string} accountKey - Account identifier for the entity.\r",
					"       * @param {string} timestamp - Timestamp of relationship creation.\r",
					"       * \r",
					"       * @returns {Array} A DB-ready relationship, connecting an account holder to their account.\r",
					"       */\r",
					"    prepAccountHolder: function (tenantId, entityKey, accountKey, timestamp) {\r",
					"\r",
					"        accountHolder = {\r",
					"            \"tenantid\": tenantId,\r",
					"            \"source\": entityKey,\r",
					"            \"destination\": accountKey,\r",
					"            \"credttm\": timestamp\r",
					"        }\r",
					"\r",
					"        if (LOGLEVEL === 'DEBUG') {\r",
					"            console.log(\"Account details:\", JSON.stringify(accountHolder, null, 2));\r",
					"        }\r",
					"\r",
					"        return accountHolder;\r",
					"    },\r",
					"\r",
					"    /**\r",
					"       * Constructs a DB-ready account.\r",
					"       *\r",
					"       * @param {string} tenantId - Identifier for the tenant.\r",
					"       * @param {string} accountKey - Account identifier.\r",
					"       * \r",
					"       * @returns {Array} A DB-ready account object.\r",
					"       */\r",
					"    prepAccount: function (tenantId, accountKey) {\r",
					"\r",
					"        account = {\r",
					"            \"id\": accountKey,\r",
					"            \"tenantid\": tenantId\r",
					"        };\r",
					"\r",
					"        if (LOGLEVEL === 'DEBUG') {\r",
					"            console.log(\"Account details:\", JSON.stringify(account, null, 2));\r",
					"        }\r",
					"\r",
					"        return account;\r",
					"    },\r",
					"\r",
					"    /**\r",
					"       * Constructs an array of event entities for a debtor and a creditor.\r",
					"       *\r",
					"       * @param {string} tenantId - Identifier for the tenant.\r",
					"       * @param {string} debtorId - Identifier for the debtor.\r",
					"       * @param {string} creditorId - Identifier for the creditor.\r",
					"       * @param {string} timestamp - Timestamp of entity creation.\r",
					"       * \r",
					"       * @returns {Array} An array of graph entities, each containing an identifier and a creation timestamp.\r",
					"       */\r",
					"    prepEventEntities: function (tenantId, debtorId, creditorId, timestamp) {\r",
					"\r",
					"        entities = [prep.prepEntity(tenantId, debtorId, timestamp), prep.prepEntity(tenantId, creditorId, timestamp)];\r",
					"\r",
					"        if (LOGLEVEL === 'DEBUG') {\r",
					"            console.log(\"Event entities:\", JSON.stringify(entities, null, 2));\r",
					"        }\r",
					"\r",
					"        return entities;\r",
					"    },\r",
					"\r",
					"    /**\r",
					"       * Constructs an array of debtor and creditor accounts.\r",
					"       *\r",
					"       * @param {string} tenantId - Identifier for the tenant.\r",
					"       * @param {string} debtorAccountId - Account identifier for the debtor.\r",
					"       * @param {string} creditorAccountId - Account identifier for the creditor.\r",
					"       * \r",
					"       * @returns {Array} An array of graph nodes, each representing an account with a unique identifier.\r",
					"       */\r",
					"    prepEventAccounts: function (tenantId, debtorAccountId, creditorAccountId) {\r",
					"\r",
					"        accounts = [prep.prepAccount(tenantId, debtorAccountId), prep.prepAccount(tenantId, creditorAccountId)];\r",
					"\r",
					"        if (LOGLEVEL === 'DEBUG') {\r",
					"            console.log(\"Account details:\", JSON.stringify(accounts, null, 2));\r",
					"        }\r",
					"\r",
					"        return accounts;\r",
					"    },\r",
					"\r",
					"    /**\r",
					"       * Constructs an array of relationships between account holders and their accounts.\r",
					"       *\r",
					"       * @param {string} tenantId - Identifier for the tenant.\r",
					"       * @param {string} debtorId - Identifier for the debtor.\r",
					"       * @param {string} debtorAccountId - Account identifier for the debtor.\r",
					"       * @param {string} creditorId - Identifier for the creditor.\r",
					"       * @param {string} creditorAccountId - Account identifier for the creditor.\r",
					"       * @param {string} timestamp - Timestamp of relationship creation.\r",
					"       * \r",
					"       * @returns {Array} An array of graph relationships, each connecting an account holder to their account.\r",
					"       */\r",
					"    prepEventAccountHolders: function (tenantId, debtorId, debtorAccountId, creditorId, creditorAccountId, timestamp) {\r",
					"\r",
					"        accountHolders = [prep.prepAccountHolder(tenantId, debtorId, debtorAccountId, timestamp), prep.prepAccountHolder(tenantId, creditorId, creditorAccountId, timestamp)];\r",
					"\r",
					"        if (LOGLEVEL === 'DEBUG') {\r",
					"            console.log(\"Account holder details:\", JSON.stringify(accountHolders, null, 2));\r",
					"        }\r",
					"\r",
					"        return accountHolders;\r",
					"    },\r",
					"\r",
					"    /**\r",
					"       * Constructs an array of transactions between debtor and creditor accounts, including various transaction types.\r",
					"       *\r",
					"       * @param {string} tenantId - Identifier for the tenant.\r",
					"       * @param {string} debtorAccountId - Account identifier for the debtor.\r",
					"       * @param {string} creditorAccountId - Account identifier for the creditor.\r",
					"       * @param {string} currency - Currency code for the transaction amount.\r",
					"       * @param {number} amount - Transaction amount.\r",
					"       * @param {string} endToEndId - Unique end-to-end transaction identifier.\r",
					"       * @param {string} timestampPacs008 - Timestamp of pacs.008.001.10 message creation.\r",
					"       * @param {string} timestampPacs002 - Timestamp of pacs.002.001.12 message creation.\r",
					"       * @param {string} pacs002Sts - Transaction status for pacs.002.001.12 message.\r",
					"       * @param {string} timestampPain001 - Timestamp of pain.001.001.11 message creation.\r",
					"       * @param {string} timestampPain013 - Timestamp of pain.013.001.09 message creation.\r",
					"       * \r",
					"       * @returns {Array} An array of graph transactions, each representing a transaction between debtor and creditor accounts.\r",
					"       */\r",
					"    prepEventTransactions: function (tenantId, debtorAccountId, creditorAccountId, instructedCurrency, instructedAmount, interbankSettlementCurrency, interbankSettlementAmount, exchangeRateCurrency, exchangeRate, endToEndId, timestampPacs008, messageIdPacs008, timestampPacs002, messageIdPacs002, pacs002Sts, timestampPain001, messageIdPain001, timestampPain013, messageIdPain013) {\r",
					"\r",
					"        if (LOGLEVEL === \"DEBUG\") {\r",
					"            logStatement = {\r",
					"                \"tenantId\": `${tenantId}`,\r",
					"                \"debtorAccountId\": `${debtorAccountId}`,\r",
					"                \"creditorAccountId\": `${creditorAccountId}`,\r",
					"                \"instructedCurrency\": `${instructedCurrency}`,\r",
					"                \"instructedAmount\": `${instructedAmount}`,\r",
					"                \"interbankSettlementCurrency\": `${interbankSettlementCurrency}`,\r",
					"                \"interbankSettlementAmount\": `${interbankSettlementAmount}`,\r",
					"                \"exchangeRateCurrency\": `${exchangeRateCurrency}`,\r",
					"                \"exchangeRate\": `${exchangeRate}`,\r",
					"                \"endToEndId\": `${endToEndId}`,\r",
					"                \"timestampPacs008\": `${timestampPacs008}`,\r",
					"                \"messageIdPacs008\": `${messageIdPacs008}`,\r",
					"                \"timestampPacs002\": `${timestampPacs002}`,\r",
					"                \"messageIdPacs002\": `${messageIdPacs002}`,\r",
					"                \"pacs002Sts\": `${pacs002Sts}`,\r",
					"                \"timestampPain001\": `${timestampPain001}`,\r",
					"                \"messageIdPain001\": `${messageIdPain001}`,\r",
					"                \"timestampPain013\": `${timestampPain013}`,\r",
					"                \"messageIdPain013\": `${messageIdPain013}`\r",
					"            }\r",
					"            console.log(`Transaction DB prep input parameters:`);\r",
					"            console.log(JSON.stringify(logStatement, null, 2));\r",
					"        }\r",
					"\r",
					"        var transactions = [];\r",
					"\r",
					"        if (typeof timestampPain001 !== \"undefined\") {\r",
					"            transactions.push({\r",
					"                \"source\": debtorAccountId,\r",
					"                \"destination\": creditorAccountId,\r",
					"                \"transaction\": {\r",
					"                    \"TxTp\": \"pain.001.001.11\",\r",
					"                    \"TenantId\": tenantId,\r",
					"                    \"MsgId\": messageIdPain001,\r",
					"                    \"CreDtTm\": timestampPain001,\r",
					"                    \"Amt\": instructedAmount,\r",
					"                    \"Ccy\": instructedCurrency,\r",
					"                    \"EndToEndId\": endToEndId,\r",
					"                    /* pending implementation\r",
					"                    \"instdamt\": {\r",
					"                        \"amt\": instructedAmount,\r",
					"                        \"ccy\": instructedCurrency\r",
					"                    },\r",
					"                    \"intrbksttlmamt\": {\r",
					"                        \"amt\": interbankSettlementAmount,\r",
					"                        \"ccy\": interbankSettlementCurrency\r",
					"                    },\r",
					"                    \"xchgrate\": exchangeRate\r",
					"                    */\r",
					"                }\r",
					"            });\r",
					"            transactions.push({\r",
					"                \"source\": creditorAccountId,\r",
					"                \"destination\": debtorAccountId,\r",
					"                \"transaction\": {\r",
					"                    \"TxTp\": \"pain.013.001.09\",\r",
					"                    \"TenantId\": tenantId,\r",
					"                    \"MsgId\": messageIdPain013,\r",
					"                    \"CreDtTm\": timestampPain013,\r",
					"                    \"Amt\": instructedAmount,\r",
					"                    \"Ccy\": instructedCurrency,\r",
					"                    \"EndToEndId\": endToEndId,\r",
					"                    /* pending implementation\r",
					"                    \"instdamt\": {\r",
					"                        \"amt\": instructedAmount,\r",
					"                        \"ccy\": instructedCurrency\r",
					"                    },\r",
					"                    \"intrbksttlmamt\": {\r",
					"                        \"amt\": interbankSettlementAmount,\r",
					"                        \"ccy\": interbankSettlementCurrency\r",
					"                    },\r",
					"                    \"xchgrate\": exchangeRate\r",
					"                    */\r",
					"                }\r",
					"            });\r",
					"        }\r",
					"\r",
					"        transactions.push({\r",
					"            \"source\": debtorAccountId,\r",
					"            \"destination\": creditorAccountId,\r",
					"            \"transaction\": {\r",
					"                \"TxTp\": \"pacs.008.001.10\",\r",
					"                \"TenantId\": tenantId,\r",
					"                \"MsgId\": messageIdPacs008,\r",
					"                \"CreDtTm\": timestampPacs008,\r",
					"                \"Amt\": instructedAmount,\r",
					"                \"Ccy\": instructedCurrency,\r",
					"                \"EndToEndId\": endToEndId,\r",
					"                /* pending implementation\r",
					"                \"instdamt\": {\r",
					"                    \"amt\": instructedAmount,\r",
					"                    \"ccy\": instructedCurrency\r",
					"                },\r",
					"                \"intrbksttlmamt\": {\r",
					"                    \"amt\": interbankSettlementAmount,\r",
					"                    \"ccy\": interbankSettlementCurrency\r",
					"                },\r",
					"                \"xchgrate\": exchangeRate\r",
					"                */\r",
					"            }\r",
					"        });\r",
					"\r",
					"        if (typeof timestampPacs002 !== \"undefined\") {\r",
					"            transactions.push({\r",
					"                \"source\": creditorAccountId,\r",
					"                \"destination\": debtorAccountId,\r",
					"                \"transaction\": {\r",
					"                    \"TxTp\": \"pacs.002.001.12\",\r",
					"                    \"TenantId\": tenantId,\r",
					"                    \"MsgId\": messageIdPacs002,\r",
					"                    \"CreDtTm\": timestampPacs002,\r",
					"                    \"EndToEndId\": endToEndId,\r",
					"                    \"TxSts\": pacs002Sts,\r",
					"                }\r",
					"            });\r",
					"        }\r",
					"\r",
					"        if (LOGLEVEL === 'DEBUG') {\r",
					"            console.log(\"Transaction details:\", JSON.stringify(transactions, null, 2));\r",
					"        }\r",
					"\r",
					"        return transactions;\r",
					"    }\r",
					"}\r",
					"\r",
					"utils = {\r",
					"    // https://community.postman.com/t/how-to-reuse-function-in-2022/39077/4\r",
					"    setPm: function (scriptPm) {\r",
					"        try {\r",
					"            if (!scriptPm) {\r",
					"                throw new Error(\"The pm object is not provided.\");\r",
					"            }\r",
					"            _pm = scriptPm;\r",
					"            if ((LOGLEVEL === 'DEBUG') || (LOGLEVEL === 'INFO')) {\r",
					"                console.log(\"pm object successfully set.\");\r",
					"            }\r",
					"        } catch (error) {\r",
					"            console.error(\"Failed to set pm object:\", error.message);\r",
					"        }\r",
					"    },\r",
					"\r",
					"    /**\r",
					"       * Returns the LOGLEVEL value from this script to a test script.\r",
					"       * \r",
					"       * Example: `logLevel = utils.getLogLevel();`\r",
					"       *\r",
					"       */\r",
					"    getLogLevel: function () {\r",
					"        return LOGLEVEL;\r",
					"    },\r",
					"\r",
					"    /**\r",
					"       * Converts a time unit to its equivalent in milliseconds.\r",
					"       * \r",
					"       * Example: `weekInMilliseconds = 7 * utils.timeframe('d');`\r",
					"       *\r",
					"       * @param {string} unit - The time unit to convert. Supported units are 'd'/'days', 'h'/'hours', 'm'/'minutes', and 's'/'seconds'.\r",
					"       * @returns {number} The number of milliseconds corresponding to the given time unit.\r",
					"       */\r",
					"    timeframe: function (unit) {\r",
					"        switch (unit) {\r",
					"            case 'd':\r",
					"            case 'days':\r",
					"                milliseconds = 86400000;\r",
					"                break;\r",
					"            case 'h':\r",
					"            case 'hours':\r",
					"                milliseconds = 3600000;\r",
					"                break;\r",
					"            case 'm':\r",
					"            case 'minutes':\r",
					"                milliseconds = 60000;\r",
					"                break;\r",
					"            case 's':\r",
					"            case 'seconds':\r",
					"                milliseconds = 1000;\r",
					"                break;\r",
					"            default: milliseconds = 0;\r",
					"        }\r",
					"        return milliseconds;\r",
					"    },\r",
					"\r",
					"    /**\r",
					"     * Calculates a timestamp in the past relative to the current time.\r",
					"     * \r",
					"     * This function computes a timestamp by subtracting a specified duration \r",
					"     * (quantum * unit) from the current time and returns it in ISO 8601 format.\r",
					"     * \r",
					"     * Example: \r",
					"     * ```javascript\r",
					"     * // Get timestamp from 7 days ago\r",
					"     * pastDate = utils.timestampAtTMinus(7, 'd');\r",
					"     * // Returns: \"2025-10-26T20:30:00.000Z\" (if current date is 2025-11-02)\r",
					"     * \r",
					"     * // Get timestamp from 2 hours ago\r",
					"     * recentDate = utils.timestampAtTMinus(2, 'h');\r",
					"     * // Returns: \"2025-11-02T18:30:00.000Z\" (if current time is 20:30:00)\r",
					"     * ```\r",
					"     *\r",
					"     * @param {number} quantum - The quantity of time units to subtract from now.\r",
					"     * @param {string} unit - The time unit to use. Supported units are 'd'/'days', \r",
					"     *                        'h'/'hours', 'm'/'minutes', and 's'/'seconds'.\r",
					"     * @returns {string} An ISO 8601 formatted timestamp string (e.g., \"2025-11-02T20:30:00.000Z\") \r",
					"     *                   representing the calculated past time.\r",
					"     */\r",
					"    timestampAtTMinus: function (quantum, unit) {\r",
					"        elapsedTime = quantum * this.timeframe(unit);\r",
					"        return new Date(new Date(Date.now()) - elapsedTime).toISOString();\r",
					"    },\r",
					"\r",
					"    /**\r",
					"       * Generates a UUID (Universally Unique Identifier) in ISO format by removing hyphens from a standard UUID.\r",
					"       *\r",
					"       * @returns {string} A UUID in ISO format without hyphens.\r",
					"       */\r",
					"    createISOUUID: function () {\r",
					"        return uuid.v4().replace(/-/g, '');\r",
					"    },\r",
					"\r",
					"    /**\r",
					"       * Logs a structured message containing payment transaction details to the console.\r",
					"       * This function facilitates easy tracking and debugging of transaction data by displaying it in a structured JSON format.\r",
					"       *\r",
					"       *   @param {Object} dataCache - An object containing all the necessary transaction data.\r",
					"       *   @param {string} data.dbtrId - Debtor's identifier.\r",
					"       *   @param {string} data.cdtrId - Creditor's identifier.\r",
					"       *   @param {string} data.dbtrAcctId - Debtor's account identifier.\r",
					"       *   @param {string} data.cdtrAcctId - Creditor's account identifier.\r",
					"       *   @param {string} data.creDtTm - Creation date and time of the transaction, formatted as ISO 8601.\r",
					"       *   @param {number} data.amt - Transaction amount.\r",
					"       *   @param {string} data.curr - Currency of the transaction amount.\r",
					"       *   @param {string} data.endToEndId - End-to-end identifier that uniquely references the transaction.\r",
					"       *\r",
					"       * @example\r",
					"       * logDataCache({\r",
					"       *   dbtrId: '123',\r",
					"       *   cdtrId: '456',\r",
					"       *   dbtrAcctId: '78910',\r",
					"       *   cdtrAcctId: '111213',\r",
					"       *   creDtTm: '2020-12-31T23:59:59',\r",
					"       *  \"instdAmt\": {\r",
					"       *      \"amt\": 1000,\r",
					"       *      \"ccy\": \"USD\"\r",
					"       *  },\r",
					"       *  \"intrBkSttlmAmt\": {\r",
					"       *      \"amt\": 18351.11,\r",
					"       *      \"ccy\": \"ZAR\"\r",
					"       *  },\r",
					"       *  \"xchgRate\": 18.35111,\r",
					"       *   endToEndId: 'E2E123456789'\r",
					"       * });\r",
					"       */\r",
					"    logDataCache: function (dataCache) {\r",
					"        console.log(JSON.stringify({ DataCache: dataCache }, null, 2));\r",
					"    },\r",
					"\r",
					"    /**\r",
					"       * Returns the current timestamp in ISO 8601 format.\r",
					"       *\r",
					"       * This function retrieves the current date and time, creates a new `Date` object, \r",
					"       * and converts it into an ISO 8601 string representation, which is commonly \r",
					"       * used for timestamps in APIs and logging.\r",
					"       *\r",
					"       * @returns {string} The current timestamp in ISO 8601 format (e.g., \"2024-11-22T10:35:00.000Z\").\r",
					"       *\r",
					"       * @example\r",
					"       * const timestamp = getTimestampNow();\r",
					"       * console.log(timestamp); \r",
					"       * // Output: \"2024-11-22T10:35:00.000Z\"\r",
					"       */\r",
					"    getTimestampNow: function () {\r",
					"        return new Date(new Date(Date.now())).toISOString();\r",
					"    },\r",
					"\r",
					"    /**\r",
					"     * Normalize UTC timezone from +00:00 to Z\r",
					"     * @param {string} dateStr - Date string to normalize\r",
					"     * @returns {string} - Normalized date string\r",
					"     * \r",
					"     * @example\r",
					"     * utils.normalizeUTC(\"2025-10-29T10:30:00+00:00\") // \"2025-10-29T10:30:00Z\"\r",
					"     * utils.normalizeUTC(\"2025-10-29T10:30:00Z\") // \"2025-10-29T10:30:00Z\" (unchanged)\r",
					"     */\r",
					"    normalizeUTC: function (dateStr) {\r",
					"        return dateStr ? dateStr.replace(/\\+00:00$/, \"Z\") : dateStr;\r",
					"    },\r",
					"\r",
					"    /**\r",
					"     * Saves data to a PostgreSQL table via Hasura API endpoints.\r",
					"     * \r",
					"     * This function sends a POST request to insert data into the specified PostgreSQL table\r",
					"     * in a multi-database setup. It uses the 'Prefer: return=representation' header to get \r",
					"     * the created record back in the response. Designed for use in Postman pre-request \r",
					"     * scripts to populate test data during test execution.\r",
					"     *\r",
					"     * @param {Object} data - The data object to be inserted into the table. Must be a valid JavaScript object that can be JSON serialized.\r",
					"     * @param {string} database - The database name (e.g., 'DB_EVENT_HISTORY', 'DB_RAW_HISTORY').\r",
					"     * @param {string} table - The name of the table where the data will be inserted. Must match an existing table name in the database schema.\r",
					"     * @returns {Object} Returns the pm.sendRequest promise for chaining or error handling.\r",
					"     *\r",
					"     * @example\r",
					"     * // Save to event history database\r",
					"     * const pacs008message = prep.prepPacs008Msg(...);\r",
					"     * await utils.saveData(pacs008message, DB_RAW_HISTORY, DB_RAW_HISTORY_PACS008)\r",
					"     *   .then(response => console.log('Success:', response.json()))\r",
					"     *   .catch(error => console.error('Failed:', error));\r",
					"     * \r",
					"     * @example\r",
					"     * // Save to raw history database\r",
					"     * const accountData = prep.prepAccount('tenant-001', 'acct_987654321IBAN');\r",
					"     * await utils.saveData(accountData, DB_EVENT_HISTORY, DB_EVENT_HISTORY_ACCOUNT);\r",
					"     */\r",
					"    saveData: function (data, database, table) {\r",
					"\r",
					"        if (LOGLEVEL === \"DEBUG\") {\r",
					"            console.log('Database:', database);\r",
					"            console.log('Table:', table);\r",
					"            console.log('Data:', JSON.stringify(data));\r",
					"        }\r",
					"\r",
					"        // Wrap single objects in array for Hasura\r",
					"        const dataArray = Array.isArray(data) ? data : [data];\r",
					"\r",
					"        // Build GraphQL mutation\r",
					"        const graphqlMutation = `\r",
					"        mutation InsertData($objects: [${table}_insert_input!]!) {\r",
					"            insert_${table}(objects: $objects) {\r",
					"                affected_rows\r",
					"            }\r",
					"        }\r",
					"    `;\r",
					"\r",
					"        const postRequest = {\r",
					"            url: POSTGRES_API_URL,\r",
					"            method: 'POST',\r",
					"            header: {\r",
					"                'Content-Type': 'application/json',\r",
					"                'x-hasura-role': 'anonymous'\r",
					"            },\r",
					"            body: {\r",
					"                mode: 'raw',\r",
					"                raw: JSON.stringify({\r",
					"                    query: graphqlMutation,\r",
					"                    variables: {\r",
					"                        objects: dataArray\r",
					"                    }\r",
					"                })\r",
					"            }\r",
					"        };\r",
					"\r",
					"        if (LOGLEVEL === \"DEBUG\") {\r",
					"            console.log('GraphQL Query:', graphqlMutation);\r",
					"            console.log('Request body:', postRequest.body.raw);\r",
					"        }\r",
					"\r",
					"        return new Promise((resolve, reject) => {\r",
					"            _pm.sendRequest(postRequest, (error, response) => {\r",
					"                if (error) {\r",
					"                    console.error('Request ERROR:', JSON.stringify(error, null, 2));\r",
					"                    reject(error);\r",
					"                } else {\r",
					"                    if (LOGLEVEL === \"DEBUG\") {\r",
					"                        console.log('Response code:', response.code);\r",
					"                        console.log('Response body:', response.text());\r",
					"                    }\r",
					"\r",
					"                    if (response.code >= 400) {\r",
					"                        console.error('HTTP Error:', response.code);\r",
					"                        reject(new Error(`HTTP ${response.code}: ${response.text()}`));\r",
					"                    } else {\r",
					"                        const body = response.json();\r",
					"                        if (body.errors) {\r",
					"                            console.error('GraphQL Errors:', JSON.stringify(body.errors, null, 2));\r",
					"                            reject(new Error(JSON.stringify(body.errors)));\r",
					"                        } else {\r",
					"                            if (LOGLEVEL === 'DEBUG') {\r",
					"                                console.log('Records created:', JSON.stringify(body.data, null, 2));\r",
					"                            }\r",
					"                            resolve(response);\r",
					"                        }\r",
					"                    }\r",
					"                }\r",
					"            });\r",
					"        });\r",
					"    },\r",
					"\r",
					"    /**\r",
					"     * Get field list for a table from GraphQL schema\r",
					"     * @param {string} tableName - The table name to introspect\r",
					"     * @returns {Promise<Array>} - Resolves with array of field names\r",
					"     * \r",
					"     * @example\r",
					"     * // Using async/await\r",
					"     * const fields = await utils.getTableFields(\"pacs008\");\r",
					"     * console.log('Fields:', fields); // ['creditoraccountid', 'credttm', 'debtoraccountid', ...]\r",
					"     * \r",
					"     * @example\r",
					"     * // Using Promise chain\r",
					"     * utils.getTableFields(\"pacs008\").then(fields => {\r",
					"     *     console.log('Fields:', fields);\r",
					"     *     console.log('As JSON:', JSON.stringify(fields));\r",
					"     * });\r",
					"     * \r",
					"     * @example\r",
					"     * // Error handling\r",
					"     * utils.getTableFields(\"pacs008\")\r",
					"     *     .then(fields => console.log('Success:', fields))\r",
					"     *     .catch(error => console.error('Failed:', error));\r",
					"     */\r",
					"    getTableFields: function (tableName) {\r",
					"        const introspectionQuery = {\r",
					"            query: `query IntrospectionQuery($typeName: String!) { __type(name: $typeName) { name fields { name type { name kind ofType { name kind }}}}}`,\r",
					"            variables: {\r",
					"                typeName: tableName\r",
					"            }\r",
					"        };\r",
					"\r",
					"        // Make the introspection request\r",
					"        const introspectionRequest = {\r",
					"            url: POSTGRES_API_URL,\r",
					"            method: 'POST',\r",
					"            header: [\r",
					"                { key: 'Content-Type', value: 'application/json' },\r",
					"                { key: 'x-hasura-admin-secret', value: POSTGRES_API_SECRET }\r",
					"            ],\r",
					"            body: {\r",
					"                mode: 'raw',\r",
					"                raw: JSON.stringify(introspectionQuery),\r",
					"                options: {\r",
					"                    raw: {\r",
					"                        language: 'json'\r",
					"                    }\r",
					"                }\r",
					"            }\r",
					"        };\r",
					"\r",
					"        return new Promise((resolve, reject) => {\r",
					"            _pm.sendRequest(introspectionRequest, (err, response) => {\r",
					"                if (err) {\r",
					"                    console.error('Error fetching schema:', err);\r",
					"                    reject(err);\r",
					"                    return;\r",
					"                }\r",
					"\r",
					"                const result = response.json();\r",
					"\r",
					"                if (result.errors) {\r",
					"                    const error = new Error('GraphQL errors: ' + JSON.stringify(result.errors));\r",
					"                    console.error(error.message);\r",
					"                    reject(error);\r",
					"                    return;\r",
					"                }\r",
					"\r",
					"                if (!result.data || !result.data.__type) {\r",
					"                    const error = new Error(`Table \"${tableName}\" not found in schema`);\r",
					"                    console.error(error.message);\r",
					"                    reject(error);\r",
					"                    return;\r",
					"                }\r",
					"\r",
					"                const fields = result.data.__type.fields;\r",
					"\r",
					"                // Filter to only scalar fields (exclude objects/arrays)\r",
					"                const scalarFields = fields.filter(field => {\r",
					"                    const fieldType = field.type.kind === 'NON_NULL' ? field.type.ofType : field.type;\r",
					"                    return fieldType.kind === 'SCALAR' || fieldType.kind === 'ENUM';\r",
					"                });\r",
					"\r",
					"                // Extract field names\r",
					"                const fieldNames = scalarFields.map(f => f.name);\r",
					"\r",
					"                resolve(fieldNames);\r",
					"            });\r",
					"        });\r",
					"    },\r",
					"\r",
					"    /**\r",
					"     * Extract data array from Hasura query response\r",
					"     * @param {Object} response - The Hasura GraphQL response object\r",
					"     * @param {string} tableName - Table name to extract specific table data\r",
					"     * @returns {Array} - Returns the table array\r",
					"     * \r",
					"     * @example\r",
					"     * // Extract specific table's array\r",
					"     * const data = utils.extractData(response, 'pacs008');\r",
					"     * // Returns: [{ creditoraccountid: \"...\", ... }]\r",
					"     */\r",
					"    extractData: function (response, tableName) {\r",
					"        return response.data[tableName];\r",
					"    },\r",
					"\r",
					"    /**\r",
					"       * Creates one or more new accounts for a given entity and updates the database with the new account(s) and their relationship to the entity.\r",
					"       *\r",
					"       * @param {number|null|undefined} [numberOfAccounts=0] - The number of new accounts to create. Defaults to 0.\r",
					"       * @param {string} tenantId - Mandatory. Reference identifier for the tenant.\r",
					"       * @param {string} entityKey - Mandatory. Identifier for the entity to which the account will be associated.\r",
					"       * @param {string|null|undefined} [accountKey] - Optional. Identifier(s) for the new account(s). If omitted or null, a unique account identifier will be generated for each account.\r",
					"       * @param {string|null|undefined} timestamp - Timestamp for the creation of the account. Defaults to the current timestamp.\r",
					"       */\r",
					"    createAccounts: async function (numberOfAccounts, tenantId, entityKey, accountKey, timestamp) {\r",
					"\r",
					"        if (LOGLEVEL === \"DEBUG\") {\r",
					"            logStatement = {\r",
					"                \"numberOfAccounts\": `${numberOfAccounts}`,\r",
					"                \"tenantId\": `${tenantId}`,\r",
					"                \"entityKey\": `${entityKey}`,\r",
					"                \"accountKey\": `${accountKey}`,\r",
					"                \"timestamp\": `${timestamp}`\r",
					"            }\r",
					"            console.log(`Message creation parameters:`);\r",
					"            console.log(JSON.stringify(logStatement, null, 2));\r",
					"        }\r",
					"\r",
					"        // Essential defaults\r",
					"        numberOfAccounts = numberOfAccounts ?? 1;\r",
					"        timestamp = timestamp ?? new Date(new Date(Date.now())).toISOString();\r",
					"\r",
					"        accountKeys = [];\r",
					"        accounts = [];\r",
					"        account_holders = [];\r",
					"\r",
					"        if (accountKey === null || accountKey === undefined) {\r",
					"            for (let step = 0; step < numberOfAccounts; step++) {\r",
					"                genAccountKey = `acct_${uuid.v4().replace(/-/g, '')}${DEBTOR_ACCOUNT_TYPE}`;\r",
					"                accounts.push(prep.prepAccount(tenantId, genAccountKey));\r",
					"                account_holders.push(prep.prepAccountHolder(tenantId, entityKey, genAccountKey, timestamp));\r",
					"            }\r",
					"        } else {\r",
					"            accounts.push(prep.prepAccount(tenantId, accountKey));\r",
					"            account_holders.push(prep.prepAccountHolder(tenantId, entityKey, accountKey, timestamp));\r",
					"        }\r",
					"\r",
					"        if (LOGLEVEL === 'DEBUG') {\r",
					"            console.log(`Creating ${numberOfAccounts} account(s) for entity ${entityKey} under tenant ${tenantId}.`);\r",
					"            console.log('Accounts to be created:', JSON.stringify(accounts, null, 2));\r",
					"            console.log('Account holder relationships to be created:', JSON.stringify(account_holders, null, 2));\r",
					"        }\r",
					"\r",
					"        try {\r",
					"            for (const account of accounts) {\r",
					"                await utils.saveData(account, DB_EVENT_HISTORY, DB_EVENT_HISTORY_ACCOUNT);\r",
					"                if ((LOGLEVEL === 'DEBUG') || (LOGLEVEL === 'INFO')) {\r",
					"                    console.log('Account created:', account.id);\r",
					"                }\r",
					"            }\r",
					"\r",
					"            for (const account_holder of account_holders) {\r",
					"                await utils.saveData(account_holder, DB_EVENT_HISTORY, DB_EVENT_HISTORY_ACCOUNT_HOLDER);\r",
					"                if ((LOGLEVEL === 'DEBUG') || (LOGLEVEL === 'INFO')) {\r",
					"                    console.log('Account holder relationship created:', account_holder.source, '->', account_holder.destination);\r",
					"                }\r",
					"            }\r",
					"        } catch (error) {\r",
					"            console.error('Failed to create accounts/account_holders:', error);\r",
					"            throw error;\r",
					"        }\r",
					"    },\r",
					"\r",
					"    /**\r",
					"       * Creates a new entity in the graph database with the given entity identifier.\r",
					"       *\r",
					"       * @param {string} tenantId - Mandatory. Identifier for the tenant.\r",
					"       * @param {string} entityKey - Mandatory. Identifier for the new entity.\r",
					"       */\r",
					"    createEntity: async function (tenantId, entityKey) {\r",
					"\r",
					"        // Essential defaults\r",
					"        const timestamp = new Date(new Date(Date.now())).toISOString();\r",
					"        const entity = prep.prepEntity(tenantId, entityKey, timestamp);\r",
					"\r",
					"        try {\r",
					"            await utils.saveData(entity, DB_EVENT_HISTORY, DB_EVENT_HISTORY_ENTITY);\r",
					"            if ((LOGLEVEL === 'DEBUG') || (LOGLEVEL === 'INFO')) {\r",
					"                console.log('Entity created:', entity.id);\r",
					"            }\r",
					"        } catch (error) {\r",
					"            console.error('Failed to create entity:', error);\r",
					"            throw error;\r",
					"        }\r",
					"\r",
					"    },\r",
					"\r",
					"    /**\r",
					"       * Appends the supplied tenantId to the object as object.tenantId.\r",
					"       *\r",
					"       * This function adds the supplied tenantId string to the supplied object and returns it. \r",
					"       * If the tenantId is not supplied, the default tenantId will be added instead. \r",
					"       *\r",
					"       * @returns {object} The updated object.\r",
					"       *\r",
					"       * @example\r",
					"       * const messageSet = createTransactionSetInMemory();\r",
					"       * let pacs002WithTenantId = addTenantId(\"tenant-001\", messageSet[1]); \r",
					"       * // Output:\r",
					"       * // {\r",
					"       * //   \"TenantId\": \"tenant-001\",\r",
					"       * //   \"TxTp\": \"pacs.002.001.12\",\r",
					"       * //   ...,\r",
					"       * // }\r",
					"       */\r",
					"    addTenantId: function (tenantId, obj) {\r",
					"        tenantId = tenantId ? tenantId : TENANT_DEFAULT;\r",
					"        obj.TenantId = tenantId;\r",
					"        return obj;\r",
					"    },\r",
					"\r",
					"    /**\r",
					"     * Generates composite keys for debtor and creditor entities and accounts.\r",
					"     * \r",
					"     * This function creates unique identifier keys by concatenating entity/account IDs \r",
					"     * with their corresponding type identifiers. These composite keys are used throughout \r",
					"     * the system to uniquely identify entities and accounts across different message types \r",
					"     * and database operations.\r",
					"     *\r",
					"     * @param {string} debtorId - The debtor's entity identifier.\r",
					"     * @param {string} debtorAccountId - The debtor's account identifier.\r",
					"     * @param {string} debtorAgentId - The debtor's financial institution identifier.\r",
					"     * @param {string} creditorId - The creditor's entity identifier.\r",
					"     * @param {string} creditorAccountId - The creditor's account identifier.\r",
					"     * @param {string} creditorAgentId - The creditor's financial institution identifier.\r",
					"     * \r",
					"     * @returns {Object} An object containing composite keys for all parties:\r",
					"     * @returns {string} returns.debtorId - Composite key: debtorId + DEBTOR_ID_TYPE\r",
					"     * @returns {string} returns.debtorAccountId - Composite key: debtorAccountId + DEBTOR_ACCOUNT_TYPE + debtorAgentId\r",
					"     * @returns {string} returns.creditorId - Composite key: creditorId + CREDITOR_ID_TYPE\r",
					"     * @returns {string} returns.creditorAccountId - Composite key: creditorAccountId + CREDITOR_ACCOUNT_TYPE + creditorAgentId\r",
					"     * \r",
					"     * @example\r",
					"     * const keys = utils.getKeys(\r",
					"     *   'dbtr_123', \r",
					"     *   'dbtrAcct_456', \r",
					"     *   'fsp001',\r",
					"     *   'cdtr_789', \r",
					"     *   'cdtrAcct_012', \r",
					"     *   'fsp002'\r",
					"     * );\r",
					"     * // Returns:\r",
					"     * // {\r",
					"     * //   debtorId: 'dbtr_123TAZAMA_EID',\r",
					"     * //   debtorAccountId: 'dbtrAcct_456MSISDNfsp001',\r",
					"     * //   creditorId: 'cdtr_789TAZAMA_EID',\r",
					"     * //   creditorAccountId: 'cdtrAcct_012MSISDNfsp002'\r",
					"     * // }\r",
					"     */\r",
					"    getKeys: function (debtorId, debtorAccountId, debtorAgentId, creditorId, creditorAccountId, creditorAgentId) {\r",
					"\r",
					"        let keys = {\r",
					"            debtorKey: `${debtorId}${DEBTOR_ID_TYPE}`,\r",
					"            debtorAccountKey: `${debtorAccountId}${DEBTOR_ACCOUNT_TYPE}${debtorAgentId}`,\r",
					"            creditorKey: `${creditorId}${CREDITOR_ID_TYPE}`,\r",
					"            creditorAccountKey: `${creditorAccountId}${CREDITOR_ACCOUNT_TYPE}${creditorAgentId}`\r",
					"        }\r",
					"\r",
					"        if (LOGLEVEL === 'DEBUG') {\r",
					"            console.log(\"Generated composite keys:\", JSON.stringify(keys, null, 2));\r",
					"        }\r",
					"\r",
					"        return (keys)\r",
					"    },\r",
					"\r",
					"    /**\r",
					"       * Creates a new set of transactions for testing purposes, including all necessary data, and stores it in memory so that the transactions can be submitted to the API in sequence as valid messages.\r",
					"       * The transaction set will always contain a pacs.008 and a pacs.002 message.\r",
					"       * The messages in the set will be linked through the same EndToEndId.\r",
					"       * The function stashes created data in global variables can be retrieved with the `pm.globals.get()` method.\r",
					"       *\r",
					"       * @param {string|null|undefined} [tenantId=null] - Reference identifier for the tenant. Defaults to DEFAULT. The tenantId is not appended to the object.\r",
					"       * @param {boolean|null|undefined} [activePain001=false] - Determines if quoting is enabled in the deployment. Defaults to false.\r",
					"       * @param {number|null|undefined} [timestampEpoch=0] - Epoch timestamp for adjusting transaction timestamps. Defaults to 0.\r",
					"       * @param {number|null|undefined} [timestampInterval=300000] - The default interval between consecutive message timestamps. Defaults to 300000 (5 minutes).\r",
					"       * @param {string|null|undefined} [debtorId=null] - Reference identifier for the debtor. If provided, this ID will be used. Defaults to null, which means a new ID will be generated.\r",
					"       * @param {string|null|undefined} [debtorAccountId=null] - Reference account identifier for the debtor. If provided, this ID will be used. Defaults to null, which means a new ID will be generated.\r",
					"       * @param {string|null|undefined} [debtorAgentId=null] - Identifier for the debtor's agent. If provided, this ID will be used. Defaults to 'fsp001'.\r",
					"       * @param {string|null|undefined} [creditorId=null] - Reference identifier for the creditor. If provided, this ID will be used. Defaults to null, which means a new ID will be generated.\r",
					"       * @param {string|null|undefined} [creditorAccountId=null] - Reference account identifier for the creditor. If provided, this ID will be used. Defaults to null, which means a new ID will be generated.\r",
					"       * @param {string|null|undefined} [creditorAgentId=null] - Identifier for the creditor's agent. If provided, this ID will be used. Defaults to 'fsp002'.\r",
					"       * @param {string|null|undefined} [instructedCurrency='XTS'] - Currency code for the transaction amount. Defaults to 'XTS'.\r",
					"       * @param {number|null|undefined} [instructedAmount] - Transaction amount. Defaults to a random value between 10 and 1000.\r",
					"       * @param {string|null|undefined} [interbankSettlementCurrency='XTS'] - Currency code for the transaction amount that the creditor will receive. Defaults to instructedCurrency.\r",
					"       * @param {number|null|undefined} [interbankSettlementAmount] - Transaction amount that the creditor will receive. Defaults to instructedAmount.\r",
					"       * @param {string|null|undefined} [exchangeRateCurrency='XTS'] - Currency code for the exchange rate. Defaults to instructedCurrency.\r",
					"       * @param {number|null|undefined} [exchangeRate] - Echange rate to convert instructedAmount to interbankSettlementAmount. Defaults to 1.0.\r",
					"       * @param {string|null|undefined} [transactionDescription='Generic payment description'] - Description of the transaction. Defaults to 'Generic payment description'.\r",
					"       * @param {string|null|undefined} [pacs002Sts='ACCC'] - Transaction status for pacs.002.001.12 message. Defaults to 'ACCC' (a successful transaction).\r",
					"       * @param {number|null|undefined} [debtorAge=25] - Age of the debtor. Defaults to 25.\r",
					"       * @param {string|null|undefined} [transactionPurpose] - Purpose of the transaction. Defaults to 'TRANSFER' if pain.001/013 ingestion is enabled, otherwise 'MP2P'.\r",
					"       * @param {number|null|undefined} [transactionLat=-3.1609] - Latitude coordinate of the transaction location. Defaults to -3.1609.\r",
					"       * @param {number|null|undefined} [transactionLong=38.3588] - Longitude coordinate of the transaction location. Defaults to 38.3588.\r",
					"       */\r",
					"    createTransactionSetInMemory: function (tenantId, activePain001, timestampEpoch, timestampInterval, debtorId, debtorAccountId, debtorAgentId, creditorId, creditorAccountId, creditorAgentId, instructedCurrency, instructedAmount, interbankSettlementCurrency, interbankSettlementAmount, exchangeRateCurrency, exchangeRate, transactionDescription, pacs002Sts, debtorAge, transactionPurpose, transactionLat, transactionLong) {\r",
					"\r",
					"        if (LOGLEVEL === 'DEBUG') {\r",
					"            logStatement = {\r",
					"                \"tenantId\": `${tenantId}`,\r",
					"                \"activePain001\": `${activePain001}`,\r",
					"                \"timestampEpoch\": `${timestampEpoch}`,\r",
					"                \"timestampInterval\": `${timestampInterval}`,\r",
					"                \"debtorId\": `${debtorId}`,\r",
					"                \"debtorAccountId\": `${debtorAccountId}`,\r",
					"                \"debtorAgentId\": `${debtorAgentId}`,\r",
					"                \"creditorId\": `${creditorId}`,\r",
					"                \"creditorAccountId\": `${creditorAccountId}`,\r",
					"                \"creditorAgentId\": `${creditorAgentId}`,\r",
					"                \"instructedCurrency\": `${instructedCurrency}`,\r",
					"                \"instructedAmount\": `${instructedAmount}`,\r",
					"                \"interbankSettlementCurrency\": `${interbankSettlementCurrency}`,\r",
					"                \"interbankSettlementAmount\": `${interbankSettlementAmount}`,\r",
					"                \"exchangeRateCurrency\": `${exchangeRateCurrency}`,\r",
					"                \"exchangeRate\": `${exchangeRate}`,\r",
					"                \"transactionDescription\": `${transactionDescription}`,\r",
					"                \"pacs002Sts\": `${pacs002Sts}`,\r",
					"                \"debtorAge\": `${debtorAge}`,\r",
					"                \"transactionPurpose\": `${transactionPurpose}`,\r",
					"                \"transactionLat\": `${transactionLat}`,\r",
					"                \"transactionLong\": `${transactionLong}`\r",
					"            }\r",
					"            console.log(`Input parameters at start:`);\r",
					"            console.log(JSON.stringify(logStatement, null, 2));\r",
					"        }\r",
					"\r",
					"        // Essential defaults\r",
					"        tenantId = tenantId ?? TENANT_DEFAULT;\r",
					"        if ((LOGLEVEL === 'DEBUG') || (LOGLEVEL === 'INFO')) {\r",
					"            console.log(`Tenant context is: ${tenantId}`)\r",
					"        }\r",
					"        activePain001 = activePain001 ?? false;\r",
					"        if ((LOGLEVEL === 'DEBUG') || (LOGLEVEL === 'INFO')) {\r",
					"            activePain001 ? console.log(\"pain.001/013 ingestion is enabled\") : console.log(\"pain.001/013 ingestion is disabled\");\r",
					"        }\r",
					"        timestampEpoch = timestampEpoch ?? 0;\r",
					"        timestampInterval = timestampInterval ?? 300000; // 300,000 milliseconds = 5 minutes\r",
					"\r",
					"        // Entities and accounts\r",
					"        debtorId = debtorId ?? 'dbtr_' + uuid.v4().replace(/-/g, '');\r",
					"        debtorAccountId = debtorAccountId ?? 'dbtrAcct_' + uuid.v4().replace(/-/g, '');\r",
					"        debtorAgentId = debtorAgentId ?? DEBTOR_AGENT_ID;\r",
					"        creditorId = creditorId ?? 'cdtr_' + uuid.v4().replace(/-/g, '');\r",
					"        creditorAccountId = creditorAccountId ?? 'cdtrAcct_' + uuid.v4().replace(/-/g, '');\r",
					"        creditorAgentId = creditorAgentId ?? CREDITOR_AGENT_ID;\r",
					"\r",
					"        // Amounts\r",
					"        instructedCurrency = instructedCurrency ?? 'XTS';\r",
					"        instructedAmount = instructedAmount ?? Math.round((Math.random() * (1000 - 10) + 10) * 100) / 100;\r",
					"        interbankSettlementCurrency = interbankSettlementCurrency ?? instructedCurrency;\r",
					"        interbankSettlementAmount = interbankSettlementAmount ?? instructedAmount;\r",
					"        exchangeRateCurrency = exchangeRateCurrency ?? instructedCurrency;\r",
					"        exchangeRate = exchangeRate ?? 1.0;\r",
					"\r",
					"        // Metadata\r",
					"        transactionDescription = transactionDescription ?? uuid.v4();\r",
					"        pacs002Sts = pacs002Sts ?? 'ACCC';\r",
					"        debtorAge = debtorAge ?? 25;\r",
					"        if (activePain001) {\r",
					"            transactionPurpose = transactionPurpose ?? 'TRANSFER' // or 'WITHDRAWAL', or 'PAYMENT'\r",
					"        } else {\r",
					"            transactionPurpose = transactionPurpose ?? 'MP2P' // or 'MP2B', or 'CASH'\r",
					"        }\r",
					"        transactionLat = transactionLat ?? -3.1609\r",
					"        transactionLong = transactionLong ?? 38.3588\r",
					"\r",
					"        // Transformations\r",
					"        const { debtorKey, debtorAccountKey, creditorKey, creditorAccountKey } = utils.getKeys(debtorId, debtorAccountId, debtorAgentId, creditorId, creditorAccountId, creditorAgentId);\r",
					"        let debtorDoB = new Date(new Date().setDate(new Date().getDate() - (debtorAge * 366))).toISOString().substring(0, 10);\r",
					"        let timestampPacs008 = new Date(new Date(Date.now() - timestampEpoch - timestampInterval * 1)).toISOString();\r",
					"        let timestampPacs002 = new Date(new Date(Date.now() - timestampEpoch - timestampInterval * 0)).toISOString();\r",
					"\r",
					"        if ((LOGLEVEL === 'DEBUG') || (LOGLEVEL === 'INFO')) {\r",
					"            console.log(\"pacs.002 payload timestamp: \" + timestampPacs002);\r",
					"        }\r",
					"\r",
					"        let endToEndId = uuid.v4().replace(/-/g, '');\r",
					"        let messageIdPacs008 = uuid.v4().replace(/-/g, '');\r",
					"        let messageIdPacs002 = uuid.v4().replace(/-/g, '');\r",
					"\r",
					"        var timestampPain001;\r",
					"        var timestampPain013;\r",
					"        var messageIdPain001;\r",
					"        var messageIdPain013;\r",
					"\r",
					"        var pain001;\r",
					"        var pain013;\r",
					"        var baseCreDtTm;\r",
					"        if (activePain001) {\r",
					"            messageIdPain001 = uuid.v4().replace(/-/g, '');\r",
					"            messageIdPain013 = uuid.v4().replace(/-/g, '');\r",
					"            timestampPain001 = new Date(new Date(Date.now() - timestampEpoch - timestampInterval * 3)).toISOString();\r",
					"            timestampPain013 = new Date(new Date(Date.now() - timestampEpoch - timestampInterval * 2)).toISOString();\r",
					"            baseCreDtTm = timestampPain001;\r",
					"        } else {\r",
					"            baseCreDtTm = timestampPacs008;\r",
					"        }\r",
					"\r",
					"        if (LOGLEVEL === 'DEBUG') {\r",
					"            logStatement = {\r",
					"                \"tenantId\": `${tenantId}`,\r",
					"                \"activePain001\": `${activePain001}`,\r",
					"                \"timestampEpoch\": `${timestampEpoch}`,\r",
					"                \"timestampInterval\": `${timestampInterval}`,\r",
					"                \"debtorId\": `${debtorId}`,\r",
					"                \"debtorKey\": `${debtorKey}`,\r",
					"                \"debtorAccountId\": `${debtorAccountId}`,\r",
					"                \"debtorAccountKey\": `${debtorAccountKey}`,\r",
					"                \"debtorAgentId\": `${debtorAgentId}`,\r",
					"                \"creditorId\": `${creditorId}`,\r",
					"                \"creditorKey\": `${creditorKey}`,\r",
					"                \"creditorAccountId\": `${creditorAccountId}`,\r",
					"                \"creditorAccountKey\": `${creditorAccountKey}`,\r",
					"                \"creditorAgentId\": `${creditorAgentId}`,\r",
					"                \"instructedCurrency\": `${instructedCurrency}`,\r",
					"                \"instructedAmount\": `${instructedAmount}`,\r",
					"                \"interbankSettlementCurrency\": `${interbankSettlementCurrency}`,\r",
					"                \"interbankSettlementAmount\": `${interbankSettlementAmount}`,\r",
					"                \"exchangeRateCurrency\": `${exchangeRateCurrency}`,\r",
					"                \"exchangeRate\": `${exchangeRate}`,\r",
					"                \"transactionDescription\": `${transactionDescription}`,\r",
					"                \"pacs002Sts\": `${pacs002Sts}`,\r",
					"                \"debtorAge\": `${debtorAge}`,\r",
					"                \"transactionPurpose\": `${transactionPurpose}`,\r",
					"                \"transactionLat\": `${transactionLat}`,\r",
					"                \"transactionLong\": `${transactionLong}`\r",
					"            }\r",
					"            console.log(`Input parameters at start:`);\r",
					"            console.log(JSON.stringify(logStatement, null, 2));\r",
					"        }\r",
					"\r",
					"        const dataCache = {\r",
					"            \"dbtrId\": `${debtorKey}`,\r",
					"            \"cdtrId\": `${creditorKey}`,\r",
					"            \"dbtrAcctId\": `${debtorAccountKey}`,\r",
					"            \"cdtrAcctId\": `${creditorAccountKey}`,\r",
					"            \"creDtTm\": `${baseCreDtTm}`,\r",
					"            \"instdAmt\": {\r",
					"                \"amt\": instructedAmount,\r",
					"                \"ccy\": `${instructedCurrency}`\r",
					"            },\r",
					"            \"intrBkSttlmAmt\": {\r",
					"                \"amt\": interbankSettlementAmount,\r",
					"                \"ccy\": `${interbankSettlementCurrency}`\r",
					"            },\r",
					"            \"xchgRate\": exchangeRate\r",
					"        };\r",
					"\r",
					"        var messageSet = {\r",
					"            \"pain001\": {},\r",
					"            \"pain013\": {},\r",
					"            \"pacs008\": {},\r",
					"            \"pacs002\": {}\r",
					"        }\r",
					"\r",
					"        if (activePain001) {\r",
					"            pain001 = [prep.prepPain001Msg(messageIdPain001, timestampPain001, debtorDoB, debtorId, DEBTOR_ID_TYPE, debtorAccountId, DEBTOR_ACCOUNT_TYPE, debtorAgentId, endToEndId, transactionPurpose, instructedCurrency, instructedAmount, interbankSettlementCurrency, interbankSettlementAmount, exchangeRateCurrency, exchangeRate, creditorId, CREDITOR_ID_TYPE, creditorAccountId, CREDITOR_ACCOUNT_TYPE, creditorAgentId, transactionDescription, transactionLat, transactionLong, dataCache)];\r",
					"            messageSet.pain001 = pain001[0];\r",
					"            pain013 = [prep.prepPain013Msg(messageIdPain013, timestampPain013, debtorDoB, debtorId, DEBTOR_ID_TYPE, debtorAccountId, DEBTOR_ACCOUNT_TYPE, debtorAgentId, endToEndId, instructedCurrency, instructedAmount, interbankSettlementCurrency, interbankSettlementAmount, creditorId, CREDITOR_ID_TYPE, creditorAccountId, CREDITOR_ACCOUNT_TYPE, creditorAgentId, transactionLat, transactionLong, dataCache)];\r",
					"            messageSet.pain013 = pain013[0];\r",
					"        }\r",
					"\r",
					"        const pacs008 = [prep.prepPacs008Msg(messageIdPacs008, timestampPacs008, endToEndId, instructedCurrency, instructedAmount, interbankSettlementCurrency, interbankSettlementAmount, exchangeRate, debtorDoB, debtorId, DEBTOR_ID_TYPE, debtorAccountId, DEBTOR_ACCOUNT_TYPE, debtorAgentId, creditorId, CREDITOR_ID_TYPE, creditorAccountId, CREDITOR_ACCOUNT_TYPE, creditorAgentId, transactionPurpose, transactionDescription, transactionLat, transactionLong, dataCache)];\r",
					"        const pacs002 = [prep.prepPacs002Msg(messageIdPacs002, timestampPacs002, endToEndId, pacs002Sts, debtorAgentId, creditorAgentId, dataCache)];\r",
					"\r",
					"        messageSet.pacs008 = pacs008[0];\r",
					"        messageSet.pacs002 = pacs002[0];\r",
					"\r",
					"        if ((LOGLEVEL === 'DEBUG') || (LOGLEVEL === 'INFO')) {\r",
					"            console.log('pacs.008 message: ' + JSON.stringify(pacs008[0]), null, 2);\r",
					"            console.log('pacs.002 trigger payload: ' + JSON.stringify(pacs002[0]), null, 2);\r",
					"        }\r",
					"\r",
					"        _pm.globals.set('tenantId', tenantId);\r",
					"        _pm.globals.set(\"pacs008\", JSON.stringify(pacs008[0]));\r",
					"        _pm.globals.set(\"pacs002\", JSON.stringify(pacs002[0]));\r",
					"        _pm.globals.set(\"dataCache\", JSON.stringify(dataCache));\r",
					"        _pm.globals.set('debtorId', debtorId);\r",
					"        _pm.globals.set('debtorAccountId', debtorAccountId);\r",
					"        _pm.globals.set('debtorAgentId', debtorAgentId);\r",
					"        _pm.globals.set('debtorDoB', debtorDoB);\r",
					"        _pm.globals.set('creditorId', creditorId);\r",
					"        _pm.globals.set('creditorAccountId', creditorAccountId);\r",
					"        _pm.globals.set('creditorAgentId', creditorAgentId);\r",
					"        _pm.globals.set('timestampPacs008', timestampPacs008);\r",
					"        _pm.globals.set('timestampPacs002', timestampPacs002);\r",
					"        _pm.globals.set('endToEndId', endToEndId);\r",
					"        _pm.globals.set('pacs002Sts', pacs002Sts);\r",
					"        _pm.globals.set('instructedCurrency', instructedCurrency);\r",
					"        _pm.globals.set('instructedAmount', instructedAmount);\r",
					"        _pm.globals.set('interbankSettlementCurrency', interbankSettlementCurrency);\r",
					"        _pm.globals.set('interbankSettlementAmount', interbankSettlementAmount);\r",
					"        _pm.globals.set('exchangeRateCurrency', exchangeRateCurrency);\r",
					"        _pm.globals.set('exchangeRate', exchangeRate);\r",
					"        _pm.globals.set('transactionDescription', transactionDescription);\r",
					"        _pm.globals.set('transactionPurpose', transactionPurpose);\r",
					"        _pm.globals.set('transactionLat', transactionLat);\r",
					"        _pm.globals.set('transactionLong', transactionLong);\r",
					"        _pm.globals.set('messageIdPacs008', messageIdPacs008);\r",
					"        _pm.globals.set('messageIdPacs002', messageIdPacs002);\r",
					"        _pm.globals.set('baseTimestamp', timestampPacs008);\r",
					"        _pm.globals.set('debtorKey', debtorKey);\r",
					"        _pm.globals.set('debtorAccountKey', debtorAccountKey);\r",
					"        _pm.globals.set('creditorKey', creditorKey);\r",
					"        _pm.globals.set('creditorAccountKey', creditorAccountKey);\r",
					"        if (activePain001) {\r",
					"            _pm.globals.set(\"pain001\", JSON.stringify(pain001[0]));\r",
					"            _pm.globals.set(\"pain013\", JSON.stringify(pain013[0]));\r",
					"            _pm.globals.set('timestampPain001', timestampPain001);\r",
					"            _pm.globals.set('timestampPain013', timestampPain013);\r",
					"            _pm.globals.set('messageIdPain001', messageIdPain001);\r",
					"            _pm.globals.set('messageIdPain013', messageIdPain013);\r",
					"            _pm.globals.set('baseTimestamp', timestampPain001);\r",
					"        }\r",
					"\r",
					"        if ((LOGLEVEL === 'DEBUG') || (LOGLEVEL === 'INFO')) {\r",
					"            if (activePain001) {\r",
					"                logStatement = {\r",
					"                    \"pain001\": `${messageIdPain001} at ${timestampPain001}`,\r",
					"                    \"pain013\": `${messageIdPain013} at ${timestampPain013}`,\r",
					"                    \"pacs008\": `${messageIdPacs008} at ${timestampPacs008}`,\r",
					"                    \"pacs002\": `${messageIdPacs002} at ${timestampPacs002}`\r",
					"                }\r",
					"                console.log(`Message IDs:`);\r",
					"                console.log(JSON.stringify(logStatement, null, 2));\r",
					"            } else {\r",
					"                logStatement = {\r",
					"                    \"pain001\": `disabled`,\r",
					"                    \"pain013\": `disabled`,\r",
					"                    \"pacs008\": `${messageIdPacs008} at ${timestampPacs008}`,\r",
					"                    \"pacs002\": `${messageIdPacs002} at ${timestampPacs002}`\r",
					"                }\r",
					"                console.log(`Message IDs:`);\r",
					"                console.log(JSON.stringify(logStatement, null, 2));\r",
					"            }\r",
					"            utils.logDataCache(dataCache);\r",
					"        }\r",
					"\r",
					"        return (messageSet);\r",
					"    },\r",
					"\r",
					"    /**\r",
					"       * Creates a new set of transactions for testing purposes, including all necessary database operations, as if the transactions had been submitted to the TMS API are waiting to be sent to the Event Director. The function stores the pacs.002 message and DataCache object in Postman global environment variables so that the payload for a specific processor can be composed as required to test the function of that processor via a direct POST using the Nats-Utilities program.\r",
					"       * The transaction set will always contain a pacs.008 and a pacs.002 message.\r",
					"       * The messages in the set will be linked through the same EndToEndId.\r",
					"       * The function stashes created data in global variables can be retrieved with the `pm.globals.get()` method.\r",
					"       *\r",
					"       * @param {string|null|undefined} [tenantId=null] - Reference identifier for the tenant. Defaults to DEFAULT. The tenantId is appended to the object.\r",
					"       * @param {number|null|undefined} [numberOfSets=1] - The number of transaction sets to create. Defaults to 1.\r",
					"       * @param {boolean|null|undefined} [activePain001=false] - Determines if quoting is enabled in the deployment. Defaults to false.\r",
					"       * @param {number|null|undefined} [timestampEpoch=0] - Epoch timestamp for adjusting transaction timestamps. Defaults to 0.\r",
					"       * @param {number|null|undefined} [timestampInterval=300000] - The default interval between consecutive message timestamps. Defaults to 300000 (5 minutes).\r",
					"       * @param {number|null|undefined} [timestampIterationLeap=timestampEpoch/numberOfSets] - the elapsed time between multiple messages.\r",
					"       * @param {string|null|undefined} [debtorId=null] - Reference identifier for the debtor. If provided, this ID will be used. Defaults to null, which means a new ID will be generated.\r",
					"       * @param {string|null|undefined} [debtorAccountId=null] - Reference account identifier for the debtor. If provided, this ID will be used. Defaults to null, which means a new ID will be generated.\r",
					"       * @param {string|null|undefined} [debtorAgentId=null] - Identifier for the debtor's agent. If provided, this ID will be used. Defaults to 'fsp001'.\r",
					"       * @param {string|null|undefined} [creditorId=null] - Reference identifier for the creditor. If provided, this ID will be used. Defaults to null, which means a new ID will be generated.\r",
					"       * @param {string|null|undefined} [creditorAccountId=null] - Reference account identifier for the creditor. If provided, this ID will be used. Defaults to null, which means a new ID will be generated.\r",
					"       * @param {string|null|undefined} [creditorAgentId=null] - Identifier for the creditor's agent. If provided, this ID will be used. Defaults to 'fsp002'.\r",
					"       * @param {string|null|undefined} [instructedCurrency='XTS'] - Currency code for the transaction amount. Defaults to 'XTS'.\r",
					"       * @param {number|null|undefined} [instructedAmount] - Transaction amount. Defaults to a random value between 10 and 1000.\r",
					"       * @param {string|null|undefined} [interbankSettlementCurrency='XTS'] - Currency code for the transaction amount that the creditor will receive. Defaults to instructedCurrency.\r",
					"       * @param {number|null|undefined} [interbankSettlementAmount] - Transaction amount that the creditor will receive. Defaults to instructedAmount.\r",
					"       * @param {string|null|undefined} [exchangeRateCurrency='XTS'] - Currency code for the exchange rate. Defaults to instructedCurrency.\r",
					"       * @param {number|null|undefined} [exchangeRate] - Echange rate to convert instructedAmount to interbankSettlementAmount. Defaults to 1.0.\r",
					"       * @param {string|null|undefined} [transactionDescription='Generic payment description'] - Description of the transaction. Defaults to 'Generic payment description'.\r",
					"       * @param {string|null|undefined} [pacs002Sts='ACCC'] - Transaction status for pacs.002.001.12 message. Defaults to 'ACCC' (a successful transaction).\r",
					"       * @param {number|null|undefined} [debtorAge=25] - Age of the debtor. Defaults to 25.\r",
					"       * @param {string|null|undefined} [transactionPurpose] - Purpose of the transaction. Defaults to 'TRANSFER' if pain.001/013 ingestion is enabled, otherwise 'MP2P'.\r",
					"       * @param {number|null|undefined} [transactionLat=-3.1609] - Latitude coordinate of the transaction location. Defaults to -3.1609.\r",
					"       * @param {number|null|undefined} [transactionLong=38.3588] - Longitude coordinate of the transaction location. Defaults to 38.3588.\r",
					"       */\r",
					"    createTransactionSetsInDatabase: async function (tenantId, numberOfSets, activePain001, timestampEpoch, timestampInterval, timestampIterationLeap, forceCreateDBObjects, debtorId, debtorAccountId, debtorAgentId, creditorId, creditorAccountId, creditorAgentId, instructedCurrency, instructedAmount, interbankSettlementCurrency, interbankSettlementAmount, exchangeRateCurrency, exchangeRate, transactionDescription, pacs002Sts, debtorAge, transactionPurpose, transactionLat, transactionLong) {\r",
					"\r",
					"        if (LOGLEVEL === 'DEBUG') {\r",
					"            logStatement = {\r",
					"                \"tenantId\": `${tenantId}`,\r",
					"                \"numberOfSets\": `${numberOfSets}`,\r",
					"                \"activePain001\": `${activePain001}`,\r",
					"                \"timestampEpoch\": `${timestampEpoch}`,\r",
					"                \"timestampInterval\": `${timestampInterval}`,\r",
					"                \"timestampIterationLeap\": `${timestampIterationLeap}`,\r",
					"                \"forceCreateDBObjects\": `${forceCreateDBObjects}`,\r",
					"                \"debtorId\": `${debtorId}`,\r",
					"                \"debtorAccountId\": `${debtorAccountId}`,\r",
					"                \"debtorAgentId\": `${debtorAgentId}`,\r",
					"                \"creditorId\": `${creditorId}`,\r",
					"                \"creditorAccountId\": `${creditorAccountId}`,\r",
					"                \"creditorAgentId\": `${creditorAgentId}`,\r",
					"                \"instructedCurrency\": `${instructedCurrency}`,\r",
					"                \"instructedAmount\": `${instructedAmount}`,\r",
					"                \"interbankSettlementCurrency\": `${interbankSettlementCurrency}`,\r",
					"                \"interbankSettlementAmount\": `${interbankSettlementAmount}`,\r",
					"                \"exchangeRateCurrency\": `${exchangeRateCurrency}`,\r",
					"                \"exchangeRate\": `${exchangeRate}`,\r",
					"                \"transactionDescription\": `${transactionDescription}`,\r",
					"                \"pacs002Sts\": `${pacs002Sts}`,\r",
					"                \"debtorAge\": `${debtorAge}`,\r",
					"                \"transactionPurpose\": `${transactionPurpose}`,\r",
					"                \"transactionLat\": `${transactionLat}`,\r",
					"                \"transactionLong\": `${transactionLong}`\r",
					"            }\r",
					"            console.log(`Input parameters at start:`);\r",
					"            console.log(JSON.stringify(logStatement, null, 2));\r",
					"        }\r",
					"\r",
					"        // Essential defaults\r",
					"        tenantId = tenantId ?? TENANT_DEFAULT;\r",
					"        if ((LOGLEVEL === 'DEBUG') || (LOGLEVEL === 'INFO')) {\r",
					"            console.log(`Tenant context is: ${tenantId}`)\r",
					"        }\r",
					"        numberOfSets = numberOfSets ?? 1;\r",
					"        activePain001 = activePain001 ?? false;\r",
					"        if ((LOGLEVEL === 'DEBUG') || (LOGLEVEL === 'INFO')) {\r",
					"            activePain001 ? console.log(\"pain.001/013 ingestion is enabled\") : console.log(\"pain.001/013 ingestion is disabled\");\r",
					"        }\r",
					"        timestampEpoch = timestampEpoch ?? 0;\r",
					"        timestampInterval = timestampInterval ?? 300000; // 300,000 milliseconds = 5 minutes\r",
					"        // Time parameters\r",
					"        if (numberOfSets == 1) {\r",
					"            timestampIterationLeap = 0  // no off-set between transactions required if we're only producing a single transaction\r",
					"        } else {\r",
					"            // If \r",
					"            timestampIterationLeap = timestampIterationLeap ?? Math.trunc(timestampEpoch / numberOfSets)\r",
					"        }\r",
					"        forceCreateDBObjects = forceCreateDBObjects ?? false;\r",
					"        debtorAgentId = debtorAgentId ?? DEBTOR_AGENT_ID;\r",
					"        creditorAgentId = creditorAgentId ?? CREDITOR_AGENT_ID;\r",
					"\r",
					"        // Metadata\r",
					"        transactionDescription = transactionDescription ?? uuid.v4();\r",
					"        pacs002Sts = pacs002Sts ?? 'ACCC';\r",
					"        debtorAge = debtorAge ?? 25;\r",
					"        if (activePain001) {\r",
					"            transactionPurpose = transactionPurpose ?? 'TRANSFER' // or 'WITHDRAWAL', or 'PAYMENT'\r",
					"        } else {\r",
					"            transactionPurpose = transactionPurpose ?? 'MP2P' // or 'MP2B', or 'CASH'\r",
					"        }\r",
					"        transactionLat = transactionLat ?? -3.1609\r",
					"        transactionLong = transactionLong ?? 38.3588\r",
					"\r",
					"        // Transformations\r",
					"\r",
					"        let debtorDoB = new Date(new Date().setDate(new Date().getDate() - (debtorAge * 366))).toISOString().substring(0, 10);\r",
					"\r",
					"        var messageSets = [];\r",
					"        var messageSet = {\r",
					"            \"pain001\": {},\r",
					"            \"pain013\": {},\r",
					"            \"pacs008\": {},\r",
					"            \"pacs002\": {}\r",
					"        }\r",
					"\r",
					"        if (LOGLEVEL === 'DEBUG') {\r",
					"            logStatement = {\r",
					"                \"tenantId\": `${tenantId}`,\r",
					"                \"numberOfSets\": `${numberOfSets}`,\r",
					"                \"activePain001\": `${activePain001}`,\r",
					"                \"timestampEpoch\": `${timestampEpoch}`,\r",
					"                \"timestampInterval\": `${timestampInterval}`,\r",
					"                \"timestampIterationLeap\": `${timestampIterationLeap}`,\r",
					"                \"forceCreateDBObjects\": `${forceCreateDBObjects}`,\r",
					"                \"debtorId\": `${debtorId}`,\r",
					"                \"debtorAccountId\": `${debtorAccountId}`,\r",
					"                \"debtorAgentId\": `${debtorAgentId}`,\r",
					"                \"creditorId\": `${creditorId}`,\r",
					"                \"creditorAccountId\": `${creditorAccountId}`,\r",
					"                \"creditorAgentId\": `${creditorAgentId}`,\r",
					"                \"instructedCurrency\": `${instructedCurrency}`,\r",
					"                \"instructedAmount\": `${instructedAmount}`,\r",
					"                \"interbankSettlementCurrency\": `${interbankSettlementCurrency}`,\r",
					"                \"interbankSettlementAmount\": `${interbankSettlementAmount}`,\r",
					"                \"exchangeRateCurrency\": `${exchangeRateCurrency}`,\r",
					"                \"exchangeRate\": `${exchangeRate}`,\r",
					"                \"transactionDescription\": `${transactionDescription}`,\r",
					"                \"pacs002Sts\": `${pacs002Sts}`,\r",
					"                \"debtorAge\": `${debtorAge}`,\r",
					"                \"transactionPurpose\": `${transactionPurpose}`,\r",
					"                \"transactionLat\": `${transactionLat}`,\r",
					"                \"transactionLong\": `${transactionLong}`\r",
					"            }\r",
					"            console.log(`Input parameters after defaults:`);\r",
					"            console.log(JSON.stringify(logStatement, null, 2))\r",
					"        }\r",
					"\r",
					"        for (let step = 0; step < numberOfSets; step++) {\r",
					"\r",
					"            // Amounts\r",
					"            let stepInstructedCurrency = instructedCurrency ?? 'XTS';\r",
					"            let stepInstructedAmount = instructedAmount ?? Math.round((Math.random() * (1000 - 10) + 10) * 100) / 100;\r",
					"            let stepInterbankSettlementCurrency = interbankSettlementCurrency ?? stepInstructedCurrency;\r",
					"            let stepInterbankSettlementAmount = interbankSettlementAmount ?? stepInstructedAmount;\r",
					"            let stepExchangeRateCurrency = exchangeRateCurrency ?? stepInstructedCurrency;\r",
					"            let stepExchangeRate = exchangeRate ?? 1.0;\r",
					"\r",
					"            // Entities and accounts\r",
					"\r",
					"            let stepDebtorId = debtorId ?? 'dbtr_' + uuid.v4().replace(/-/g, '');\r",
					"            let stepDebtorAccountId = debtorAccountId ?? 'dbtrAcct_' + uuid.v4().replace(/-/g, '');\r",
					"            let stepCreditorId = creditorId ?? 'cdtr_' + uuid.v4().replace(/-/g, '');\r",
					"            let stepCreditorAccountId = creditorAccountId ?? 'cdtrAcct_' + uuid.v4().replace(/-/g, '');\r",
					"\r",
					"            let { debtorKey, debtorAccountKey, creditorKey, creditorAccountKey } = utils.getKeys(stepDebtorId, stepDebtorAccountId, debtorAgentId, stepCreditorId, stepCreditorAccountId, creditorAgentId);\r",
					"\r",
					"            let timestampPacs008 = new Date(new Date(Date.now() - timestampEpoch + (timestampIterationLeap * step) - timestampInterval * 1)).toISOString();\r",
					"            let timestampPacs002 = new Date(new Date(Date.now() - timestampEpoch + (timestampIterationLeap * step) - timestampInterval * 0)).toISOString();\r",
					"            let endToEndId = uuid.v4().replace(/-/g, '');\r",
					"            let messageIdPacs008 = uuid.v4().replace(/-/g, '');\r",
					"            let messageIdPacs002 = uuid.v4().replace(/-/g, '');\r",
					"\r",
					"            if ((!debtorId) || (debtorId && forceCreateDBObjects && step == 0)) {\r",
					"                await utils.createEntity(tenantId, debtorKey);\r",
					"            }\r",
					"            if ((!creditorId) || (creditorId && forceCreateDBObjects && step == 0)) {\r",
					"                await utils.createEntity(tenantId, creditorKey);\r",
					"            }\r",
					"            if ((!debtorAccountId) || (debtorAccountId && forceCreateDBObjects && step == 0)) {\r",
					"                await utils.createAccounts(1, tenantId, debtorKey, debtorAccountKey, timestampPacs008);\r",
					"            }\r",
					"            if ((!creditorAccountId) || (creditorAccountId && forceCreateDBObjects && step == 0)) {\r",
					"                await utils.createAccounts(1, tenantId, creditorKey, creditorAccountKey, timestampPacs008);\r",
					"            }\r",
					"\r",
					"            var messageIdPain001;\r",
					"            var messageIdPain013;\r",
					"            var timestampPain001;\r",
					"            var timestampPain013;\r",
					"            var pain001;\r",
					"            var pain013;\r",
					"            var baseCreDtTm;\r",
					"\r",
					"            if (activePain001) {\r",
					"                messageIdPain001 = uuid.v4().replace(/-/g, '');\r",
					"                messageIdPain013 = uuid.v4().replace(/-/g, '');\r",
					"                timestampPain001 = new Date(new Date(Date.now() - timestampEpoch + (timestampIterationLeap * step) - timestampInterval * 3)).toISOString();\r",
					"                timestampPain013 = new Date(new Date(Date.now() - timestampEpoch + (timestampIterationLeap * step) - timestampInterval * 2)).toISOString();\r",
					"                baseCreDtTm = timestampPain001;\r",
					"            } else {\r",
					"                baseCreDtTm = timestampPacs008;\r",
					"            }\r",
					"\r",
					"            var dataCache = {\r",
					"                \"dbtrId\": `${debtorKey}`,\r",
					"                \"cdtrId\": `${creditorKey}`,\r",
					"                \"dbtrAcctId\": `${debtorAccountKey}`,\r",
					"                \"cdtrAcctId\": `${creditorAccountKey}`,\r",
					"                \"creDtTm\": `${baseCreDtTm}`,\r",
					"                \"instdAmt\": {\r",
					"                    \"amt\": stepInstructedAmount,\r",
					"                    \"ccy\": `${stepInstructedCurrency}`\r",
					"                },\r",
					"                \"intrBkSttlmAmt\": {\r",
					"                    \"amt\": stepInterbankSettlementAmount,\r",
					"                    \"ccy\": `${stepInterbankSettlementCurrency}`\r",
					"                },\r",
					"                \"xchgRate\": stepExchangeRate\r",
					"            };\r",
					"\r",
					"            if (LOGLEVEL === 'DEBUG') {\r",
					"                logStatement = {\r",
					"                    \"tenantId\": `${tenantId}`,\r",
					"                    \"messageIdPain001\": `${messageIdPain001}`,\r",
					"                    \"timestampPain001\": `${timestampPain001}`,\r",
					"                    \"messageIdPain013\": `${messageIdPain013}`,\r",
					"                    \"timestampPain013\": `${timestampPain013}`,\r",
					"                    \"messageIdPacs008\": `${messageIdPacs008}`,\r",
					"                    \"timestampPacs008\": `${timestampPacs008}`,\r",
					"                    \"messageIdPacs002\": `${messageIdPacs002}`,\r",
					"                    \"timestampPacs002\": `${timestampPacs002}`,\r",
					"                    \"debtorDoB\": `${debtorDoB}`,\r",
					"                    \"forceCreateDBObjects\": `${forceCreateDBObjects}`,\r",
					"                    \"debtorId\": `${stepDebtorId}`,\r",
					"                    \"debtorKey\": `${debtorKey}`,\r",
					"                    \"debtorAccountId\": `${stepDebtorAccountId}`,\r",
					"                    \"debtorAccountKey\": `${debtorAccountKey}`,\r",
					"                    \"creditorId\": `${stepCreditorId}`,\r",
					"                    \"creditorKey\": `${creditorKey}`,\r",
					"                    \"creditorAccountId\": `${stepCreditorAccountId}`,\r",
					"                    \"creditorAccountKey\": `${creditorAccountKey}`,\r",
					"                    \"endToEndId\": `${endToEndId}`,\r",
					"                    \"transactionPurpose\": `${transactionPurpose}`,\r",
					"                    \"stepInstructedCurrency\": `${stepInstructedCurrency}`,\r",
					"                    \"stepInstructedAmount\": `${stepInstructedAmount}`,\r",
					"                    \"stepInterbankSettlementCurrency\": `${stepInterbankSettlementCurrency}`,\r",
					"                    \"stepInterbankSettlementAmount\": `${stepInterbankSettlementAmount}`,\r",
					"                    \"stepExchangeRateCurrency\": `${stepExchangeRateCurrency}`,\r",
					"                    \"exchangeRate\": `${exchangeRate}`,\r",
					"                    \"transactionDescription\": `${transactionDescription}`,\r",
					"                    \"transactionLat\": `${transactionLat}`,\r",
					"                    \"transactionLong\": `${transactionLong}`,\r",
					"                    \"pacs002Sts\": `${pacs002Sts}`\r",
					"                }\r",
					"                console.log(`Message creation parameters:`);\r",
					"                console.log(JSON.stringify(logStatement, null, 2));\r",
					"                console.log(`\"dataCache\": ${JSON.stringify(dataCache, null, 2)}`);\r",
					"            }\r",
					"\r",
					"            if (activePain001) {\r",
					"                pain001 = utils.addTenantId(tenantId, prep.prepPain001Msg(messageIdPain001, timestampPain001, debtorDoB, stepDebtorId, DEBTOR_ID_TYPE, stepDebtorAccountId, DEBTOR_ACCOUNT_TYPE, debtorAgentId, endToEndId, transactionPurpose, stepInstructedCurrency, stepInstructedAmount, stepInterbankSettlementCurrency, stepInterbankSettlementAmount, stepExchangeRateCurrency, exchangeRate, stepCreditorId, CREDITOR_ID_TYPE, stepCreditorAccountId, CREDITOR_ACCOUNT_TYPE, creditorAgentId, transactionDescription, transactionLat, transactionLong, dataCache));\r",
					"                pain013 = utils.addTenantId(tenantId, prep.prepPain013Msg(messageIdPain013, timestampPain013, debtorDoB, stepDebtorId, DEBTOR_ID_TYPE, stepDebtorAccountId, DEBTOR_ACCOUNT_TYPE, debtorAgentId, endToEndId, stepInstructedCurrency, stepInstructedAmount, stepInterbankSettlementCurrency, stepInterbankSettlementAmount, stepCreditorId, CREDITOR_ID_TYPE, stepCreditorAccountId, CREDITOR_ACCOUNT_TYPE, creditorAgentId, transactionLat, transactionLong, dataCache));\r",
					"            }\r",
					"\r",
					"            let pacs008 = utils.addTenantId(tenantId, prep.prepPacs008Msg(messageIdPacs008, timestampPacs008, endToEndId, stepInstructedCurrency, stepInstructedAmount, stepInterbankSettlementCurrency, stepInterbankSettlementAmount, stepExchangeRate, debtorDoB, stepDebtorId, DEBTOR_ID_TYPE, stepDebtorAccountId, DEBTOR_ACCOUNT_TYPE, debtorAgentId, stepCreditorId, CREDITOR_ID_TYPE, stepCreditorAccountId, CREDITOR_ACCOUNT_TYPE, creditorAgentId, transactionPurpose, transactionDescription, transactionLat, transactionLong, dataCache));\r",
					"            let pacs002 = utils.addTenantId(tenantId, prep.prepPacs002Msg(messageIdPacs002, timestampPacs002, endToEndId, pacs002Sts, debtorAgentId, creditorAgentId, dataCache));\r",
					"\r",
					"            var transactions = [];\r",
					"\r",
					"            if (activePain001) {\r",
					"                transactions = prep.prepEventTransactions(tenantId, debtorAccountKey, creditorAccountKey, stepInstructedCurrency, stepInstructedAmount, stepInterbankSettlementCurrency, stepInterbankSettlementAmount, stepExchangeRateCurrency, stepExchangeRate, endToEndId, timestampPacs008, messageIdPacs008, timestampPacs002, messageIdPacs002, pacs002Sts, timestampPain001, messageIdPain001, timestampPain013, messageIdPain013);\r",
					"\r",
					"                await utils.saveData({ document: { ...pain001 } }, DB_RAW_HISTORY, DB_RAW_HISTORY_PAIN001)\r",
					"                    .then(response => {\r",
					"                        if (LOGLEVEL === 'DEBUG') {\r",
					"                            console.log('Pain001 created:', response.json());\r",
					"                        }\r",
					"                    })\r",
					"                    .catch(error => console.error('Failed to create Pain001:', error));\r",
					"                await utils.saveData({ document: { ...pain013 } }, DB_RAW_HISTORY, DB_RAW_HISTORY_PAIN013)\r",
					"                    .then(response => {\r",
					"                        if (LOGLEVEL === 'DEBUG') {\r",
					"                            console.log('Pain013 created:', response.json());\r",
					"                        }\r",
					"                    })\r",
					"                    .catch(error => console.error('Failed to create Pain013:', error));\r",
					"                await utils.saveData(transactions, DB_EVENT_HISTORY, DB_EVENT_HISTORY_TRANSACTION)\r",
					"                    .then(response => {\r",
					"                        if (LOGLEVEL === 'DEBUG') {\r",
					"                            console.log('Transactions created:', response.json());\r",
					"                        }\r",
					"                    })\r",
					"                    .catch(error => console.error('Failed to create transactions:', error));\r",
					"            } else {\r",
					"                transactions = prep.prepEventTransactions(tenantId, debtorAccountKey, creditorAccountKey, stepInstructedCurrency, stepInstructedAmount, stepInterbankSettlementCurrency, stepInterbankSettlementAmount, stepExchangeRateCurrency, stepExchangeRate, endToEndId, timestampPacs008, messageIdPacs008, timestampPacs002, messageIdPacs002, pacs002Sts);\r",
					"\r",
					"                await utils.saveData({ document: { ...pacs008 } }, DB_RAW_HISTORY, DB_RAW_HISTORY_PACS008)\r",
					"                    .then(response => {\r",
					"                        if (LOGLEVEL === 'DEBUG') {\r",
					"                            console.log('Pacs008 created:', response.json());\r",
					"                        }\r",
					"                    })\r",
					"                    .catch(error => console.error('Failed to create Pacs008:', error));\r",
					"                await utils.saveData({ document: { ...pacs002 } }, DB_RAW_HISTORY, DB_RAW_HISTORY_PACS002)\r",
					"                    .then(response => {\r",
					"                        if (LOGLEVEL === 'DEBUG') {\r",
					"                            console.log('Pacs002 created:', response.json());\r",
					"                        }\r",
					"                    })\r",
					"                    .catch(error => console.error('Failed to create Pacs002:', error));\r",
					"                await utils.saveData(transactions, DB_EVENT_HISTORY, DB_EVENT_HISTORY_TRANSACTION)\r",
					"                    .then(response => {\r",
					"                        if (LOGLEVEL === 'DEBUG') {\r",
					"                            console.log('Transactions created:', response.json());\r",
					"                        }\r",
					"                    })\r",
					"                    .catch(error => console.error('Failed to create transactions:', error));\r",
					"            }\r",
					"\r",
					"            if (activePain001) {\r",
					"                if ((LOGLEVEL === 'DEBUG') || (LOGLEVEL === 'INFO')) {\r",
					"                    console.log(`Created transaction set ${step + 1}/${numberOfSets} from ${debtorAccountKey} to ${creditorAccountKey} with EndToEndId ${endToEndId}`);\r",
					"                }\r",
					"                messageSet.pain001 = pain001;\r",
					"                messageSet.pain013 = pain013;\r",
					"            } else {\r",
					"                if ((LOGLEVEL === 'DEBUG') || (LOGLEVEL === 'INFO')) {\r",
					"                    console.log(`Created transaction set ${step + 1}/${numberOfSets} from ${debtorAccountKey} to ${creditorAccountKey} with EndToEndId ${endToEndId}`);\r",
					"                }\r",
					"            }\r",
					"\r",
					"            messageSet.pacs008 = pacs008;\r",
					"            messageSet.pacs002 = pacs002;\r",
					"            messageSets.push(messageSet);\r",
					"\r",
					"            if ((LOGLEVEL === 'DEBUG') || (LOGLEVEL === 'INFO')) {\r",
					"                if (activePain001) {\r",
					"                    logStatement = {\r",
					"                        \"pain001\": `${messageIdPain001} at ${timestampPain001}`,\r",
					"                        \"pain013\": `${messageIdPain013} at ${timestampPain013}`,\r",
					"                        \"pacs008\": `${messageIdPacs008} at ${timestampPacs008}`,\r",
					"                        \"pacs002\": `${messageIdPacs002} at ${timestampPacs002}`\r",
					"                    }\r",
					"                    console.log(`Message IDs:`);\r",
					"                    console.log(JSON.stringify(logStatement, null, 2));\r",
					"                } else {\r",
					"                    logStatement = {\r",
					"                        \"pain001\": `disabled`,\r",
					"                        \"pain013\": `disabled`,\r",
					"                        \"pacs008\": `${messageIdPacs008} at ${timestampPacs008}`,\r",
					"                        \"pacs002\": `${messageIdPacs002} at ${timestampPacs002}`\r",
					"                    }\r",
					"                    console.log(`Message IDs:`);\r",
					"                    console.log(JSON.stringify(logStatement, null, 2));\r",
					"                }\r",
					"                console.log(messageSets);\r",
					"                utils.logDataCache(dataCache);\r",
					"            }\r",
					"        }\r",
					"\r",
					"        return (messageSets);\r",
					"    },\r",
					"\r",
					"    getRuleProcessorBody: function (ruleId, ruleCfgVer, messageBody, dataCache, collectFrom) {\r",
					"        ruleId = ruleId ?? '901@1.0.0';\r",
					"        ruleCfgVer = ruleCfgVer ?? '1.0.0';\r",
					"        const natsSub = `sub-rule-${ruleId}`;\r",
					"        const natsPub = collectFrom ?? `pub-rule-${ruleId}`;\r",
					"        const msgId = messageBody.FIToFIPmtSts.GrpHdr.MsgId;\r",
					"        return JSON.stringify({\r",
					"            \"destination\": natsSub,\r",
					"            \"consumer\": natsPub,\r",
					"            \"functionName\": msgId,\r",
					"            \"awaitReply\": true,\r",
					"            \"message\": {\r",
					"                \"transaction\": messageBody,\r",
					"                \"DataCache\": dataCache,\r",
					"                \"networkMap\": {\r",
					"                    \"name\": \"Rule processor ingestion\",\r",
					"                    \"active\": true,\r",
					"                    \"cfg\": \"1.0.0\",\r",
					"                    \"messages\": [\r",
					"                        {\r",
					"                            \"id\": \"004@1.0.0\",\r",
					"                            \"cfg\": \"1.0.0\",\r",
					"                            \"txTp\": \"pacs.002.001.12\",\r",
					"                            \"typologies\": [\r",
					"                                {\r",
					"                                    \"id\": \"typology-processor@1.0.0\",\r",
					"                                    \"cfg\": \"999@1.0.0\",\r",
					"                                    \"rules\": [\r",
					"                                        {\r",
					"                                            \"id\": ruleId,\r",
					"                                            \"cfg\": ruleCfgVer\r",
					"                                        }\r",
					"                                    ]\r",
					"                                }\r",
					"                            ]\r",
					"                        }\r",
					"                    ]\r",
					"                },\r",
					"                \"metaData\": {\r",
					"                    \"prcgTmDP\": 999,\r",
					"                    \"prcgTmED\": 999,\r",
					"                    \"traceParent\": `00-postman-${msgId}-01`\r",
					"                }\r",
					"            }\r",
					"        });\r",
					"    },\r",
					"\r",
					"    getTypologyProcessorBody: function (ruleResult, typologyCfg, messageBody, dataCache, collectFrom, awaitReply) {\r",
					"        ruleResult = ruleResult ?? { id: '901@1.0.0', cfg: '1.0.0', subRuleRef: '.01', prcgTm: 999 };\r",
					"        typologyCfg = typologyCfg ?? '999@1.0.0';\r",
					"        awaitReply = awaitReply ?? false;\r",
					"        const natsSub = `pub-rule-${ruleResult.id}`;\r",
					"        const natsPub = collectFrom ? collectFrom : `typology-${typologyCfg}`;\r",
					"        const msgId = messageBody.FIToFIPmtSts.GrpHdr.MsgId;\r",
					"        return JSON.stringify({\r",
					"            \"destination\": natsSub,\r",
					"            \"consumer\": natsPub,\r",
					"            \"functionName\": msgId,\r",
					"            \"awaitReply\": awaitReply,\r",
					"            \"message\": {\r",
					"                \"transaction\": messageBody,\r",
					"                \"DataCache\": dataCache,\r",
					"                \"networkMap\": {\r",
					"                    \"name\": \"Typology processor ingestion\",\r",
					"                    \"active\": true,\r",
					"                    \"cfg\": \"1.0.0\",\r",
					"                    \"messages\": [\r",
					"                        {\r",
					"                            \"id\": \"004@1.0.0\",\r",
					"                            \"cfg\": \"1.0.0\",\r",
					"                            \"txTp\": \"pacs.002.001.12\",\r",
					"                            \"typologies\": [\r",
					"                                {\r",
					"                                    \"id\": \"typology-processor@1.0.0\",\r",
					"                                    \"cfg\": typologyCfg,\r",
					"                                    \"rules\": [\r",
					"                                        {\r",
					"                                            \"id\": ruleResult.id,\r",
					"                                            \"cfg\": ruleResult.cfg\r",
					"                                        }\r",
					"                                    ]\r",
					"                                }\r",
					"                            ]\r",
					"                        }\r",
					"                    ]\r",
					"                },\r",
					"                \"metaData\": {\r",
					"                    \"prcgTmDP\": 999,\r",
					"                    \"prcgTmED\": 999,\r",
					"                    \"traceParent\": `00-postman-${msgId}-01`\r",
					"                },\r",
					"                ruleResult\r",
					"            }\r",
					"        });\r",
					"    },\r",
					"\r",
					"    getTADProcBody: function (typologyResult, messageBody, dataCache, awaitReply) {\r",
					"        typologyResult = typologyResult ?? {\r",
					"            \"id\": \"typology-processor@1.0.0\",\r",
					"            \"cfg\": \"999@1.0.0\",\r",
					"            \"result\": 100,\r",
					"            \"ruleResults\": [\r",
					"                {\r",
					"                    \"id\": \"901@1.0.0\",\r",
					"                    \"cfg\": \"1.0.0\",\r",
					"                    \"subRuleRef\": \".01\",\r",
					"                    \"prcgTm\": 999,\r",
					"                    \"wght\": 100\r",
					"                }\r",
					"            ],\r",
					"            \"prcgTm\": 999,\r",
					"            \"review\": false,\r",
					"            \"workflow\": {\r",
					"                \"alertThreshold\": 200,\r",
					"                \"interdictionThreshold\": 400\r",
					"            }\r",
					"        };\r",
					"        awaitReply = awaitReply ?? false;\r",
					"        const typologyCfg = typologyResult.cfg;\r",
					"        const ruleResult = typologyResult.ruleResults;\r",
					"        const natsPub = `typology-${typologyCfg}`;\r",
					"        const natsSub = `cms`;\r",
					"        const msgId = messageBody.FIToFIPmtSts.GrpHdr.MsgId;\r",
					"        return JSON.stringify({\r",
					"            \"destination\": natsPub,\r",
					"            \"consumer\": natsSub,\r",
					"            \"functionName\": msgId,\r",
					"            \"awaitReply\": awaitReply,\r",
					"            \"message\": {\r",
					"                \"transaction\": messageBody,\r",
					"                \"DataCache\": dataCache,\r",
					"                \"networkMap\": {\r",
					"                    \"name\": \"Typology processor ingestion\",\r",
					"                    \"active\": true,\r",
					"                    \"cfg\": \"1.0.0\",\r",
					"                    \"messages\": [\r",
					"                        {\r",
					"                            \"id\": \"004@1.0.0\",\r",
					"                            \"cfg\": \"1.0.0\",\r",
					"                            \"txTp\": \"pacs.002.001.12\",\r",
					"                            \"typologies\": [\r",
					"                                {\r",
					"                                    \"id\": \"typology-processor@1.0.0\",\r",
					"                                    \"cfg\": typologyCfg,\r",
					"                                    \"rules\": [\r",
					"                                        {\r",
					"                                            \"id\": ruleResult[0].id,\r",
					"                                            \"cfg\": ruleResult[0].cfg\r",
					"                                        }\r",
					"                                    ]\r",
					"                                }\r",
					"                            ]\r",
					"                        }\r",
					"                    ]\r",
					"                },\r",
					"                \"metaData\": {\r",
					"                    \"prcgTmDP\": 999,\r",
					"                    \"prcgTmED\": 999,\r",
					"                    \"traceParent\": `00-postman-${msgId}-01`\r",
					"                },\r",
					"                typologyResult\r",
					"            }\r",
					"        });\r",
					"    },\r",
					"\r",
					"    getDebtorIdFromPacs008: function (pacs008Message) {\r",
					"\r",
					"        debtorId = {\r",
					"            \"id\": pacs008Message.FIToFICstmrCdtTrf.CdtTrfTxInf.Dbtr.Id.PrvtId.Othr[0].Id,\r",
					"            \"schmeNm\": {\r",
					"                \"prtry\": pacs008Message.FIToFICstmrCdtTrf.CdtTrfTxInf.Dbtr.Id.PrvtId.Othr[0].SchmeNm.Prtry\r",
					"            }\r",
					"        }\r",
					"\r",
					"        if (LOGLEVEL === \"DEBUG\") {\r",
					"            console.log(`Debtor ID object: ${JSON.stringify(debtorId, null, 2)}`);\r",
					"        }\r",
					"\r",
					"        return debtorId;\r",
					"\r",
					"    },\r",
					"\r",
					"    getDebtorAccountIdFromPacs008: function (pacs008Message) {\r",
					"\r",
					"        debtorAccountId = {\r",
					"            \"id\": pacs008Message.FIToFICstmrCdtTrf.CdtTrfTxInf.DbtrAcct.Id.Othr[0].Id,\r",
					"            \"schmeNm\": {\r",
					"                \"prtry\": pacs008Message.FIToFICstmrCdtTrf.CdtTrfTxInf.DbtrAcct.Id.Othr[0].SchmeNm.Prtry\r",
					"            },\r",
					"            \"agt\": {\r",
					"                \"finInstnId\": {\r",
					"                    \"clrSysMmbId\": {\r",
					"                        \"mmbId\": pacs008Message.FIToFICstmrCdtTrf.CdtTrfTxInf.DbtrAgt.FinInstnId.ClrSysMmbId.MmbId\r",
					"                    }\r",
					"                }\r",
					"            }\r",
					"        };\r",
					"\r",
					"        if (LOGLEVEL === \"DEBUG\") {\r",
					"            console.log(`Debtor Account ID object: ${JSON.stringify(debtorAccountId, null, 2)}`);\r",
					"        }\r",
					"\r",
					"        return debtorAccountId;\r",
					"    },\r",
					"\r",
					"    getCreditorIdFromPacs008: function (pacs008Message) {\r",
					"\r",
					"        creditorId = {\r",
					"            \"id\": pacs008Message.FIToFICstmrCdtTrf.CdtTrfTxInf.Cdtr.Id.PrvtId.Othr[0].Id,\r",
					"            \"schmeNm\": {\r",
					"                \"prtry\": pacs008Message.FIToFICstmrCdtTrf.CdtTrfTxInf.Cdtr.Id.PrvtId.Othr[0].SchmeNm.Prtry\r",
					"            }\r",
					"        }\r",
					"\r",
					"        if (LOGLEVEL === \"DEBUG\") {\r",
					"            console.log(`Creditor ID object: ${JSON.stringify(creditorId, null, 2)}`);\r",
					"        }\r",
					"\r",
					"        return creditorId;\r",
					"    },\r",
					"\r",
					"    getCreditorAccountIdFromPacs008: function (pacs008Message) {\r",
					"\r",
					"        creditorAccountId = {\r",
					"            \"id\": pacs008Message.FIToFICstmrCdtTrf.CdtTrfTxInf.CdtrAcct.Id.Othr[0].Id,\r",
					"            \"schmeNm\": {\r",
					"                \"prtry\": pacs008Message.FIToFICstmrCdtTrf.CdtTrfTxInf.CdtrAcct.Id.Othr[0].SchmeNm.Prtry\r",
					"            },\r",
					"            \"agt\": {\r",
					"                \"finInstnId\": {\r",
					"                    \"clrSysMmbId\": {\r",
					"                        \"mmbId\": pacs008Message.FIToFICstmrCdtTrf.CdtTrfTxInf.CdtrAgt.FinInstnId.ClrSysMmbId.MmbId\r",
					"                    }\r",
					"                }\r",
					"            }\r",
					"        }\r",
					"        if (LOGLEVEL === \"DEBUG\") {\r",
					"            console.log(`Creditor Account ID object: ${JSON.stringify(creditorAccountId, null, 2)}`);\r",
					"        }\r",
					"\r",
					"        return creditorAccountId;\r",
					"\r",
					"    },\r",
					"\r",
					"    getCreateAccountConditionBody: function (evtTp, condTp, prsptv, incptDtTm, xprtnDtTm, condRsn, acct, forceCret, usr) {\r",
					"\r",
					"        evtTp = evtTp ?? [\"pain.001.001.11\", \"pain.013.001.09\", \"pacs.008.001.10\", \"pacs.002.001.12\"];\r",
					"        condTp = condTp ?? \"non-overridable-block\"; // \"override\" / \"overridable-block\"\r",
					"        prsptv = prsptv ?? \"both\";\r",
					"        condRsn = condRsn ?? \"Default Test Condition\";\r",
					"        acct = acct ?? {\r",
					"            \"id\": utils.createISOUUID(),\r",
					"            \"schmeNm\": {\r",
					"                \"prtry\": \"TAZAMA_AID\"\r",
					"            },\r",
					"            \"agt\": {\r",
					"                \"finInstnId\": {\r",
					"                    \"clrSysMmbId\": {\r",
					"                        \"mmbId\": \"fsp001\"\r",
					"                    }\r",
					"                }\r",
					"            }\r",
					"        };\r",
					"        forceCret = forceCret ? forceCret : true;\r",
					"        usr = usr ?? \"POSTMAN\";\r",
					"\r",
					"        let messageBody = {\r",
					"            \"evtTp\": evtTp,\r",
					"            \"condTp\": condTp,\r",
					"            \"prsptv\": prsptv,\r",
					"            \"condRsn\": condRsn,\r",
					"            \"acct\": acct,\r",
					"            \"forceCret\": forceCret,\r",
					"            \"usr\": usr\r",
					"        };\r",
					"\r",
					"        if (condTp.localeCompare(\"override\") === 0) {\r",
					"            xprtnDtTm = xprtnDtTm ?? new Date(new Date(Date.now() + utils.timeframe(\"days\"))).toISOString();\r",
					"        }\r",
					"\r",
					"        incptDtTm = incptDtTm ? messageBody = lodash.assign({ \"incptDtTm\": incptDtTm }, messageBody) : false;\r",
					"        xprtnDtTm = xprtnDtTm ? messageBody = lodash.assign({ \"xprtnDtTm\": xprtnDtTm }, messageBody) : false;\r",
					"\r",
					"        return JSON.stringify(messageBody);\r",
					"    },\r",
					"\r",
					"    getCreateEntityConditionBody: function (evtTp, condTp, prsptv, incptDtTm, xprtnDtTm, condRsn, ntty, forceCret, usr) {\r",
					"\r",
					"        evtTp = evtTp ?? [\"pain.001.001.11\", \"pain.013.001.09\", \"pacs.008.001.10\", \"pacs.002.001.12\"];\r",
					"        condTp = condTp ?? \"non-overridable-block\"; // \"override\" / \"overridable-block\"\r",
					"        prsptv = prsptv ?? \"both\"; // \"debtor\" / \"creditor\"\r",
					"        condRsn = condRsn ?? \"Default Test Condition\";\r",
					"        ntty = ntty ?? {\r",
					"            \"id\": utils.createISOUUID(),\r",
					"            \"schmeNm\": {\r",
					"                \"prtry\": \"TAZAMA_EID\"\r",
					"            }\r",
					"        };\r",
					"        forceCret = forceCret ? forceCret : true;\r",
					"        usr = usr ?? \"POSTMAN\";\r",
					"\r",
					"        let messageBody = {\r",
					"            \"evtTp\": evtTp,\r",
					"            \"condTp\": condTp,\r",
					"            \"prsptv\": prsptv,\r",
					"            \"condRsn\": condRsn,\r",
					"            \"ntty\": ntty,\r",
					"            \"forceCret\": forceCret,\r",
					"            \"usr\": usr\r",
					"        };\r",
					"\r",
					"        if (condTp.localeCompare(\"override\") === 0) {\r",
					"            xprtnDtTm = xprtnDtTm ?? new Date(new Date(Date.now() + utils.timeframe(\"days\"))).toISOString();\r",
					"        }\r",
					"\r",
					"        incptDtTm = incptDtTm ? messageBody = lodash.assign({ \"incptDtTm\": incptDtTm }, messageBody) : false;\r",
					"        xprtnDtTm = xprtnDtTm ? messageBody = lodash.assign({ \"xprtnDtTm\": xprtnDtTm }, messageBody) : false;\r",
					"\r",
					"        return JSON.stringify(messageBody);\r",
					"\r",
					"    },\r",
					"\r",
					"    getConditionsFromDBPostRequest: function (tenantId, id, activeOnly) {\r",
					"\r",
					"        var variables = {\r",
					"            tenantId: tenantId,\r",
					"            id: id\r",
					"        }\r",
					"\r",
					"        var activeFilter = {\r",
					"            \"param\": \"\",\r",
					"            \"filter\": \"\"\r",
					"        }\r",
					"\r",
					"        if (activeOnly) {\r",
					"            variables.now = new Date().toISOString();\r",
					"            activeFilter.param = `, $now: timestamptz!`;\r",
					"            activeFilter.filter = `_or: [ { xprtndttm: { _is_null: true } }, { xprtndttm: { _gt: $now } } ]`;\r",
					"        }\r",
					"\r",
					"        const query = `query GetGovernedRelationships($tenantId: String!, $id: String!${activeFilter.param}) {\r",
					"            governed_as_debtor_by(\r",
					"                where: {\r",
					"                    tenantid: { _eq: $tenantId }\r",
					"                    source: { _eq: $id }\r",
					"                    ${activeFilter.filter}\r",
					"                }\r",
					"            ) {\r",
					"                source\r",
					"                destination\r",
					"                evttp\r",
					"                incptndttm\r",
					"                xprtndttm\r",
					"                tenantid\r",
					"                condition {\r",
					"                    id\r",
					"                    tenantid\r",
					"                    condition\r",
					"                }\r",
					"                entity {\r",
					"                    id\r",
					"                    tenantid\r",
					"                    credttm\r",
					"                }\r",
					"            }\r",
					"            governed_as_creditor_by(\r",
					"                where: {\r",
					"                    tenantid: { _eq: $tenantId }\r",
					"                    source: { _eq: $id }\r",
					"                    ${activeFilter.filter}\r",
					"                }\r",
					"            ) {\r",
					"                source\r",
					"                destination\r",
					"                evttp\r",
					"                incptndttm\r",
					"                xprtndttm\r",
					"                tenantid\r",
					"                condition {\r",
					"                    id\r",
					"                    tenantid\r",
					"                    condition\r",
					"                }\r",
					"                entity {\r",
					"                    id\r",
					"                    tenantid\r",
					"                    credttm\r",
					"                }\r",
					"            }\r",
					"            governed_as_debtor_account_by(\r",
					"                where: {\r",
					"                    tenantid: { _eq: $tenantId }\r",
					"                    source: { _eq: $id }\r",
					"                    ${activeFilter.filter}\r",
					"                }\r",
					"            ) {\r",
					"                source\r",
					"                destination\r",
					"                evttp\r",
					"                incptndttm\r",
					"                xprtndttm\r",
					"                tenantid\r",
					"                condition {\r",
					"                    id\r",
					"                    tenantid\r",
					"                    condition\r",
					"                }\r",
					"                account {\r",
					"                    id\r",
					"                    tenantid\r",
					"                }\r",
					"            }\r",
					"            governed_as_creditor_account_by(\r",
					"                where: {\r",
					"                    tenantid: { _eq: $tenantId }\r",
					"                    source: { _eq: $id }\r",
					"                    ${activeFilter.filter}\r",
					"                }\r",
					"            ) {\r",
					"                source\r",
					"                destination\r",
					"                evttp\r",
					"                incptndttm\r",
					"                xprtndttm\r",
					"                tenantid\r",
					"                condition {\r",
					"                    id\r",
					"                    tenantid\r",
					"                    condition\r",
					"                }\r",
					"                account {\r",
					"                    id\r",
					"                    tenantid\r",
					"                }\r",
					"            }\r",
					"        }`;\r",
					"\r",
					"        const postRequest = {\r",
					"            url: POSTGRES_API_URL,\r",
					"            method: 'POST',\r",
					"            header: {\r",
					"                'Content-Type': 'application/json',\r",
					"                'x-hasura-role': 'anonymous'\r",
					"            },\r",
					"            body: {\r",
					"                mode: 'raw',\r",
					"                raw: JSON.stringify({\r",
					"                    query: query,\r",
					"                    variables: variables\r",
					"                })\r",
					"            }\r",
					"        };\r",
					"\r",
					"        if (LOGLEVEL === \"DEBUG\") {\r",
					"            console.log('GraphQL Query:', query);\r",
					"            console.log('Request body:', postRequest);\r",
					"        }\r",
					"\r",
					"        return postRequest;\r",
					"    },\r",
					"\r",
					"    getConditionsGraph: function (graph) {\r",
					"\r",
					"        let conditionsGraph = { v: [], e: [] }\r",
					"\r",
					"        const allConditions = [\r",
					"            ...(graph.governed_as_creditor_account_by?.map(item => item.condition) ?? []),\r",
					"            ...(graph.governed_as_debtor_account_by?.map(item => item.condition) ?? []),\r",
					"            ...(graph.governed_as_creditor_by?.map(item => item.condition) ?? []),\r",
					"            ...(graph.governed_as_debtor_by?.map(item => item.condition) ?? [])\r",
					"        ];\r",
					"\r",
					"        const uniqueConditions = Array.from(\r",
					"            new Map(allConditions.map(cond => [cond.id, cond])).values()\r",
					"        );\r",
					"\r",
					"        uniqueConditions.forEach(item => {\r",
					"            item._key = `${item.id}`;\r",
					"            item._id = `conditions/${item.id}`;\r",
					"            item.usr = item.condition.usr;\r",
					"            if (item.condition.hasOwnProperty(\"acct\")) {\r",
					"                item.acct = item.condition.acct;\r",
					"            }\r",
					"            if (item.condition.hasOwnProperty(\"ntty\")) {\r",
					"                item.ntty = item.condition.ntty;\r",
					"            }\r",
					"            item.evtTp = item.condition.evtTp;\r",
					"            item.condId = item.condition.condId;\r",
					"            item.condTp = item.condition.condTp;\r",
					"            item.prsptv = item.condition.prsptv;\r",
					"            item.condRsn = item.condition.condRsn;\r",
					"            item.creDtTm = item.condition.creDtTm;\r",
					"            item.tenantId = item.condition.tenantId;\r",
					"            item.forceCret = item.condition.forceCret;\r",
					"            item.incptnDtTm = item.condition.incptnDtTm;\r",
					"            if (item.condition.hasOwnProperty(\"xprtnDtTm\")) {\r",
					"                item.xprtnDtTm = item.condition.xprtnDtTm;\r",
					"            }\r",
					"        });\r",
					"\r",
					"        const entitySources = [\r",
					"            ...(graph.governed_as_creditor_by?.map(item => item.entity) ?? []),\r",
					"            ...(graph.governed_as_debtor_by?.map(item => item.entity) ?? [])\r",
					"        ];\r",
					"\r",
					"        const uniqueEntitySources = Array.from(\r",
					"            new Map(entitySources.map(cond => [cond.id, cond])).values()\r",
					"        );\r",
					"\r",
					"        uniqueEntitySources.forEach(item => {\r",
					"            item._key = `${item.id}`;\r",
					"            item._id = `entities/${item.id}`;\r",
					"        });\r",
					"\r",
					"        const accountSources = [\r",
					"            ...(graph.governed_as_creditor_account_by?.map(item => item.account) ?? []),\r",
					"            ...(graph.governed_as_debtor_account_by?.map(item => item.account) ?? [])\r",
					"        ];\r",
					"\r",
					"        const uniqueAccountSources = Array.from(\r",
					"            new Map(accountSources.map(cond => [cond.id, cond])).values()\r",
					"        );\r",
					"\r",
					"        uniqueAccountSources.forEach(item => {\r",
					"            item._key = `${item.id}`;\r",
					"            item._id = `accounts/${item.id}`;\r",
					"        });\r",
					"\r",
					"        graph.governed_as_creditor_by.forEach(item => {\r",
					"            item._key = `${utils.createISOUUID()}`;\r",
					"            item._id = `governed_as_creditor_by/${item._key}`;\r",
					"            item._from = `entities/${item.source}`;\r",
					"            item._to = `conditions/${item.destination}`;\r",
					"        });\r",
					"\r",
					"        graph.governed_as_debtor_by.forEach(item => {\r",
					"            item._key = `${utils.createISOUUID()}`;\r",
					"            item._id = `governed_as_debtor_by/${item._key}`;\r",
					"            item._from = `entities/${item.source}`;\r",
					"            item._to = `conditions/${item.destination}`;\r",
					"        });\r",
					"\r",
					"        graph.governed_as_creditor_account_by.forEach(item => {\r",
					"            item._key = `${utils.createISOUUID()}`;\r",
					"            item._id = `governed_as_creditor_account_by/${item._key}`;\r",
					"            item._from = `accounts/${item.source}`;\r",
					"            item._to = `conditions/${item.destination}`;\r",
					"        });\r",
					"\r",
					"        graph.governed_as_debtor_account_by.forEach(item => {\r",
					"            item._key = `${utils.createISOUUID()}`;\r",
					"            item._id = `governed_as_debtor_account_by/${item._key}`;\r",
					"            item._from = `accounts/${item.source}`;\r",
					"            item._to = `conditions/${item.destination}`;\r",
					"        });\r",
					"\r",
					"        conditionsGraph.v = [...uniqueConditions, ...uniqueEntitySources, ...uniqueAccountSources];\r",
					"        conditionsGraph.e = [...graph.governed_as_creditor_by, ...graph.governed_as_debtor_by, ...graph.governed_as_creditor_account_by, ...graph.governed_as_debtor_account_by];\r",
					"\r",
					"        let conditionsGraphString = JSON.stringify(conditionsGraph);\r",
					"\r",
					"        conditionsGraphString = conditionsGraphString.replaceAll(\"tenantid\", \"tenantId\");\r",
					"        conditionsGraphString = conditionsGraphString.replaceAll(\"evttp\", \"evtTp\");\r",
					"        conditionsGraphString = conditionsGraphString.replaceAll(\"incptndttm\", \"incptnDtTm\");\r",
					"        conditionsGraphString = conditionsGraphString.replaceAll(\"xprtndttm\", \"xprtnDtTm\");\r",
					"\r",
					"        conditionsGraph = JSON.parse(conditionsGraphString);\r",
					"\r",
					"        if (LOGLEVEL === \"DEBUG\") {\r",
					"            console.log(`Conditions graph:`, JSON.stringify(conditionsGraph, null, 2));\r",
					"        }\r",
					"\r",
					"        return conditionsGraph;\r",
					"\r",
					"    },\r",
					"\r",
					"    getConditionsFromGraph: function (graph, all) {\r",
					"\r",
					"        if (LOGLEVEL === \"DEBUG\") {\r",
					"            console.log(`getConditionsFromGraph:`, JSON.stringify(graph, null, 2));\r",
					"        }\r",
					"\r",
					"        if (all) {\r",
					"            return graph.v.filter(condition => condition._id.substring(0, condition._id.search('/')) === \"conditions\");    // filter to get the conditions\r",
					"        } else {\r",
					"            return graph.v.filter(condition => condition._id.substring(0, condition._id.search('/')) === \"conditions\").map(({ _key }) => _key);    // filter to get the conditions, map to only get the _key;\r",
					"        }\r",
					"    },\r",
					"\r",
					"    getConditionPerspectivesFromGraph: function (graph, condition, all) {\r",
					"\r",
					"        if (LOGLEVEL === \"DEBUG\") {\r",
					"            console.log(`getConditionPerspectivesFromGraph:`, JSON.stringify(graph, null, 2));\r",
					"        }\r",
					"\r",
					"        if (all) {\r",
					"            return graph.e.filter(edge => edge._to === \"conditions/\" + condition);   // filter to get the condition's perspectives\r",
					"        } else {\r",
					"            return graph.e.filter(edge => edge._to === \"conditions/\" + condition).map(({ _id }) => _id.substring(0, _id.search('/')));    // filter to get the condition's perspectives, map to only get the _id up to the '/'\r",
					"        }\r",
					"    },\r",
					"\r",
					"    getConditionPerspectiveEventTypesFromGraph: function (graph, condition, perspective) {\r",
					"\r",
					"        if (LOGLEVEL === \"DEBUG\") {\r",
					"            console.log(`getConditionPerspectiveEventTypesFromGraph:`, JSON.stringify(graph, null, 2));\r",
					"        }\r",
					"\r",
					"        return graph.e.filter(edge => edge._to === \"conditions/\" + condition).filter(eventType => eventType._id.substring(0, eventType._id.search('/')) === perspective).map(({ evtTp }) => evtTp);    // filter to get the condition's perspectives, filter to get the specific perspective, map to only get the evtTp\r",
					"    },\r",
					"\r",
					"    getConditionPerspectiveInceptionDateFromGraph: function (graph, condition, perspective) {\r",
					"\r",
					"        if (LOGLEVEL === \"DEBUG\") {\r",
					"            console.log(`getConditionPerspectiveInceptionDateFromGraph:`, JSON.stringify(graph, null, 2));\r",
					"        }\r",
					"\r",
					"        return graph.e.filter(edge => edge._to === \"conditions/\" + condition).filter(eventType => eventType._id.substring(0, eventType._id.search('/')) === perspective).map(({ incptnDtTm }) => incptnDtTm);    // filter to get the condition's perspectives, filter to get the specific perspective, map to only get the incptnDtTm\r",
					"    },\r",
					"\r",
					"    getConditionPerspectiveExpirationDateFromGraph: function (graph, condition, perspective) {\r",
					"\r",
					"        if (LOGLEVEL === \"DEBUG\") {\r",
					"            console.log(`getConditionPerspectiveExpirationDateFromGraph:`, JSON.stringify(graph, null, 2));\r",
					"        }\r",
					"\r",
					"        return graph.e.filter(edge => edge._to === \"conditions/\" + condition).filter(eventType => eventType._id.substring(0, eventType._id.search('/')) === perspective).map(({ xprtnDtTm }) => xprtnDtTm);    // filter to get the condition's perspectives, filter to get the specific perspective, map to only get the incptnDtTm\r",
					"    }\r",
					"\r",
					"}"
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"packages": {},
				"requests": {},
				"exec": [
					""
				]
			}
		}
	]
}