{
	"info": {
		"_postman_id": "be089774-4467-4f08-af15-a71880c88419",
		"name": "3.1. (NO-AUTH) Public DockerHub Full-Service Test",
		"description": "# 20241207\n\n- Implemented tests for the full-service DockerHub deployment",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "36724395"
	},
	"item": [
		{
			"name": "Message Creation sans pain.001/013",
			"item": [
				{
					"name": "Create messages in memory",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"utils.setPm(pm); // set the utils _pm to the pre-request script pm\r",
									"\r",
									"pm.globals.clear();\r",
									"\r",
									"// ## Set up transaction eco-system\r",
									"\r",
									"messageSet = utils.createTransactionSetInMemory();\r",
									"\r",
									"let pacs008 = messageSet.pacs008;\r",
									"\r",
									"// Send another one for the same entities and accounts, but for a different tenant...\r",
									"historicalMessageSets = await utils.createTransactionSetsInDatabase(\r",
									"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ \"tenant-001\",\r",
									"    /* Number of Sets - null defaults 1 ----------------------------- */ null,\r",
									"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
									"    /* Timestamp Epoch - null defaults 0 ---------------------------- */ utils.timeframe(\"h\"),\r",
									"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
									"    /* Timestamp Iteration Leap - null defaults even spread --------- */ null,\r",
									"    /* Force create entities and accounts - null defaults false ----- */ true,\r",
									"    /* Debtor ID - null defaults random UUID ------------------------ */ utils.getDebtorIdFromPacs008(pacs008).id,\r",
									"    /* Debtor Account ID - null defaults random UUID ---------------- */ utils.getDebtorAccountIdFromPacs008(pacs008).id,\r",
									"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
									"    /* Creditor ID - null defaults random UUID ---------------------- */ utils.getCreditorIdFromPacs008(pacs008).id,\r",
									"    /* Creditor Account ID - null defaults random UUID -------------- */ utils.getCreditorAccountIdFromPacs008(pacs008).id,\r",
									"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
									"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
									"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
									"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
									"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
									"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
									"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
									"    /* Description - null defaults random UUID ---------------------- */ null,\r",
									"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
									"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
									"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
									"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
									"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
									"    );\r",
									"\r",
									"// Recreate the transactions in memory to refresh the global variables for the transactions...\r",
									"messageSets = utils.createTransactionSetInMemory(\r",
									"    /* Tenant ID - null defaults DEFAULT ---------------------------- */ null,\r",
									"    /* Quoting Enabled - null defaults false ------------------------ */ null,\r",
									"    /* Timestamp Epoch - null defaults 0 ---------------------------- */ null,\r",
									"    /* Timestamp Interval - null defaults 300000 -------------------- */ null,\r",
									"    /* Debtor ID - null defaults random UUID ------------------------ */ utils.getDebtorIdFromPacs008(pacs008).id,\r",
									"    /* Debtor Account ID - null defaults random UUID ---------------- */ utils.getDebtorAccountIdFromPacs008(pacs008).id,\r",
									"    /* Debtor Agent ID - null defaults to 'fsp001' ------------------ */ null,\r",
									"    /* Creditor ID - null defaults random UUID ---------------------- */ utils.getCreditorIdFromPacs008(pacs008).id,\r",
									"    /* Creditor Account ID - null defaults random UUID -------------- */ utils.getCreditorAccountIdFromPacs008(pacs008).id,\r",
									"    /* Creditor Agent ID - null defaults to 'fsp002' ---------------- */ null,\r",
									"    /* Instructed Currency - null defaults to 'XTS' ----------------- */ null,\r",
									"    /* Instructed Amount - null defaults to random amount ----------- */ null,\r",
									"    /* Settlement Currency - null defaults to Instructed Currency --- */ null,\r",
									"    /* Settlement Amount - null defaults to Instructed Amount ------- */ null,\r",
									"    /* Exchange Rate Currency - null defaults to Instructed Currency  */ null,\r",
									"    /* Exchange Rate - null defaults to 1.0 ------------------------- */ null,\r",
									"    /* Description - null defaults random UUID ---------------------- */ null,\r",
									"    /* Status - null defaults 'ACCC' (successful) ------------------- */ null,\r",
									"    /* Debtor Age - null defaults 25 -------------------------------- */ null,\r",
									"    /* Transaction Type - null defaults 'MP2P' ---------------------- */ null,\r",
									"    /* Latitude - null defaults -3.1609 ----------------------------- */ null,\r",
									"    /* Longitude - null defaults 38.3588 ---------------------------- */ null\r",
									"    );"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"const activePain001 = JSON.parse(pm.environment.get('activePain001'));\r",
									"\r",
									"pm.test(\"Status code is 200\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"let dataCache = JSON.parse(pm.globals.get(\"dataCache\"));\r",
									"let endToEndId = pm.globals.get(\"endToEndId\");\r",
									"let messageIdPacs008 = pm.globals.get(\"messageIdPacs008\");\r",
									"let messageIdPacs002 = pm.globals.get(\"messageIdPacs002\");\r",
									"let pacs008 = pm.globals.get(\"pacs008\");\r",
									"let pacs002 = pm.globals.get(\"pacs002\");\r",
									"\r",
									"pm.test(`Has a new dataCache:dbtrId value: ${dataCache.dbtrId}`, function() {\r",
									"  pm.expect(dataCache.dbtrId, `${dataCache.dbtrId}`).to.be.a('string');\r",
									"});\r",
									"\r",
									"pm.test(`Has a new dataCache:cdtrId value: ${dataCache.cdtrId}`, function() {\r",
									"  pm.expect(dataCache.cdtrId).to.be.a('string');\r",
									"});\r",
									"\r",
									"pm.test(`Has a dataCache:dbtrAcctId value: ${dataCache.dbtrAcctId}`, function() {\r",
									"  pm.expect(dataCache.dbtrAcctId).to.be.a('string');\r",
									"});\r",
									"\r",
									"pm.test(`Has a dataCache:cdtrAcctId value: ${dataCache.cdtrAcctId}`, function() {\r",
									"  pm.expect(dataCache.cdtrAcctId).to.be.a('string');\r",
									"});\r",
									"\r",
									"pm.test(`Has a new endToEndId value: ${endToEndId}`, function() {\r",
									"  pm.expect(endToEndId).to.be.a('string');\r",
									"});\r",
									"\r",
									"\r",
									"pm.test(`Has a new pacs.008 msgId value: ${messageIdPacs008}`, function() {\r",
									"  pm.expect(messageIdPacs008).to.be.a('string');\r",
									"});\r",
									"\r",
									"pm.test(`Has a new pacs.002 msgId value: ${messageIdPacs002}`, function() {\r",
									"  pm.expect(messageIdPacs002).to.be.a('string');\r",
									"});\r",
									"\r",
									"pm.test(`Has a new pacs.008 body for TMS API`, function() {\r",
									"  pm.expect(pacs008).to.be.a('string');\r",
									"});\r",
									"\r",
									"pm.test(`Has a new pacs.002 body for Data Preparation`, function() {\r",
									"  pm.expect(pacs002).to.be.a('string');\r",
									"});\r",
									"\r",
									"if (activePain001) {\r",
									"    let messageIdPain001 = pm.globals.get(\"messageIdPain001\");\r",
									"    let messageIdPain013 = pm.globals.get(\"messageIdPain013\");\r",
									"    let pain001 = pm.globals.get(\"pain001\");\r",
									"    let pain013 = pm.globals.get(\"pain013\");\r",
									"    pm.test(`Has a new pain.001 msgId value: ${messageIdPain001}`, function() {\r",
									"    pm.expect(messageIdPain001).to.be.a('string');\r",
									"    });\r",
									"\r",
									"    pm.test(`Has a new pain.013 msgId value: ${messageIdPain013}`, function() {\r",
									"    pm.expect(messageIdPain013).to.be.a('string');\r",
									"    });\r",
									"\r",
									"    pm.test(`Has a new pain.001 body for TMS API`, function() {\r",
									"    pm.expect(pain001).to.be.a('string');\r",
									"    });\r",
									"\r",
									"    pm.test(`Has a new pain.013 body for TMS API`, function() {\r",
									"    pm.expect(pain013).to.be.a('string');\r",
									"    });\r",
									"} else {\r",
									"    pm.test(`pain.001/013 messages disabled`, function() {\r",
									"    pm.expect(activePain001).to.be.false;\r",
									"    });\r",
									"}"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "GET",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{tazamaTMSUrl}}",
							"host": [
								"{{tazamaTMSUrl}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Post pacs.008 to TMS API - unauthenticated",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"let messageBody = pm.globals.get('pacs008');\r",
									"pm.globals.set('messageBody', messageBody);"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"pacs.008 successfully submitted to TMS API\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{{messageBody}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs008}}",
							"host": [
								"{{tazamaTMSUrl}}{{path-tms-api-version}}"
							],
							"path": [
								"{{path-pacs008}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Post pacs.002 to TMS API - unauthenticated",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"let messageBody = pm.globals.get('pacs002');\r",
									"pm.globals.set('messageBody', messageBody);"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"pacs.002 successfully submitted to TMS API\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{{messageBody}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{tazamaTMSUrl}}{{path-tms-api-version}}/{{path-pacs002}}",
							"host": [
								"{{tazamaTMSUrl}}{{path-tms-api-version}}"
							],
							"path": [
								"{{path-pacs002}}"
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "DB update tests",
			"item": [
				{
					"name": "Fetch created pacs.008 from transactionHistoryPacs008",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"utils.setPm(pm); // set the utils _pm to the pre-request script pm\r",
									"\r",
									"console.log(`Fetching submitted pacs.008 from ${pm.environment.get('db_raw_history_pacs008')} using:\r",
									"  tenantId: ${pm.globals.get('tenantId')}\r",
									"  msgId: ${pm.globals.get('messageIdPacs008')}`);\r",
									"\r",
									"const tableFields = await utils.getTableFields(`${pm.environment.get(\"db_raw_history_pacs008\")}`);\r",
									"pm.globals.set(\"tableFields\", tableFields);"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"const resJson = utils.extractData(pm.response.json(), \"pacs008\")[0].document;\r",
									"\r",
									"let memPacs008MsgId = pm.globals.get('messageIdPacs008')\r",
									"let memTenantId = pm.globals.get('tenantId')\r",
									"\r",
									"pm.test(`pacs.008 for tenantId ${memTenantId} with msgId ${memPacs008MsgId} found`, function () {\r",
									"    pm.expect(resJson.FIToFICstmrCdtTrf.GrpHdr.MsgId).to.be.equal(memPacs008MsgId);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{auth-token}}",
									"type": "string"
								}
							]
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"query\": \"query GetAccount($tenantId: String!, $messageId: String!) {pacs008(where: {tenantid: {_eq: $tenantId},messageid: {_eq: $messageId}}) {{{tableFields}}}}\",\r\n  \"variables\": {\r\n    \"tenantId\": \"{{tenantId}}\",\r\n    \"messageId\": \"{{messageIdPacs008}}\"\r\n  },\r\n  \"operationName\": \"GetAccount\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{hasuraUrl}}/v1/graphql",
							"host": [
								"{{hasuraUrl}}"
							],
							"path": [
								"v1",
								"graphql"
							]
						}
					},
					"response": []
				},
				{
					"name": "Fetch created pacs.002 from transactionHistoryPacs002",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"utils.setPm(pm); // set the utils _pm to the pre-request script pm\r",
									"\r",
									"console.log(`Fetching submitted pacs.002 from ${pm.environment.get('db_raw_history_pacs002')} using:\r",
									"  tenantId: ${pm.globals.get('tenantId')}\r",
									"  msgId: ${pm.globals.get('messageIdPacs002')}`);\r",
									"\r",
									"const tableFields = await utils.getTableFields(`${pm.environment.get(\"db_raw_history_pacs002\")}`);\r",
									"pm.globals.set(\"tableFields\", tableFields);"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"const resJson = utils.extractData(pm.response.json(), \"pacs002\")[0].document;\r",
									"\r",
									"let memPacs002MsgId = pm.globals.get('messageIdPacs002')\r",
									"let memTenantId = pm.globals.get('tenantId')\r",
									"\r",
									"pm.test(`pacs.002 for tenantId ${memTenantId} with msgId ${memPacs002MsgId} found`, function () {\r",
									"    pm.expect(resJson.FIToFIPmtSts.GrpHdr.MsgId).to.be.equal(memPacs002MsgId);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{auth-token}}",
									"type": "string"
								}
							]
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"query\": \"query GetAccount($tenantId: String!, $messageId: String!) {pacs002(where: {tenantid: {_eq: $tenantId},messageid: {_eq: $messageId}}) {{{tableFields}}}}\",\r\n  \"variables\": {\r\n    \"tenantId\": \"{{tenantId}}\",\r\n    \"messageId\": \"{{messageIdPacs002}}\"\r\n  },\r\n  \"operationName\": \"GetAccount\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{hasuraUrl}}/v1/graphql",
							"host": [
								"{{hasuraUrl}}"
							],
							"path": [
								"v1",
								"graphql"
							]
						}
					},
					"response": []
				},
				{
					"name": "Check event data creation",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"utils.setPm(pm); // set the utils _pm to the pre-request script pm\r",
									"\r",
									"console.log(`Fetching event data from database for tenantId: ${pm.globals.get('tenantId')}`);\r",
									"\r",
									"const [entityFields, accountHolderFields, accountFields, transactionFields] = await Promise.all([\r",
									"    utils.getTableFields(`${pm.environment.get(\"db_event_history_entity\")}`),\r",
									"    utils.getTableFields(`${pm.environment.get(\"db_event_history_account_holder\")}`),\r",
									"    utils.getTableFields(`${pm.environment.get(\"db_event_history_account\")}`),\r",
									"    utils.getTableFields(`${pm.environment.get(\"db_event_history_transaction\")}`)\r",
									"]);\r",
									"\r",
									"const dataCache = JSON.parse(pm.globals.get(\"dataCache\"));\r",
									"const tenantId = pm.globals.get(\"tenantId\");\r",
									"\r",
									"const qryBody = {\r",
									"    query: `query getEventData(\r",
									"        $tenantId: String!,\r",
									"        $dbtrId: String!,\r",
									"        $cdtrId: String!,\r",
									"        $dbtrAcctId: String!,\r",
									"        $cdtrAcctId: String!\r",
									"    ) {\r",
									"        entity(where: {\r",
									"            _and: {\r",
									"                id: {_in: [$dbtrId, $cdtrId]},\r",
									"                tenantid: {_eq: $tenantId}\r",
									"            }\r",
									"        }) {\r",
									"            ${entityFields}\r",
									"        }\r",
									"        account_holder(where: {\r",
									"            _and: {\r",
									"                destination: {_in: [$dbtrAcctId, $cdtrAcctId]},\r",
									"                source: {_in: [$dbtrId, $cdtrId]},\r",
									"                tenantid: {_eq: $tenantId}\r",
									"            }\r",
									"        }) {\r",
									"            ${accountHolderFields}\r",
									"        }\r",
									"        account(where: {\r",
									"            _and: {\r",
									"                id: {_in: [$dbtrAcctId, $cdtrAcctId]},\r",
									"                tenantid: {_eq: $tenantId}\r",
									"            }\r",
									"        }) {\r",
									"            ${accountFields}\r",
									"        }\r",
									"        transactionPain001: transaction(where: {\r",
									"            _and: {\r",
									"                tenantid: {_eq: $tenantId},\r",
									"                txtp: {_eq: \"pain.001.001.11\"},\r",
									"                source: {_eq: $dbtrAcctId},\r",
									"                destination: {_eq: $cdtrAcctId}\r",
									"            }\r",
									"        }) {\r",
									"            ${transactionFields}\r",
									"        }\r",
									"        transactionPain013: transaction(where: {\r",
									"            _and: {\r",
									"                tenantid: {_eq: $tenantId},\r",
									"                txtp: {_eq: \"pain.013.001.09\"},\r",
									"                source: {_eq: $cdtrAcctId},\r",
									"                destination: {_eq: $dbtrAcctId}\r",
									"            }\r",
									"        }) {\r",
									"            ${transactionFields}\r",
									"        }\r",
									"        transactionPacs008: transaction(where: {\r",
									"            _and: {\r",
									"                tenantid: {_eq: $tenantId},\r",
									"                txtp: {_eq: \"pacs.008.001.10\"},\r",
									"                source: {_eq: $dbtrAcctId},\r",
									"                destination: {_eq: $cdtrAcctId}\r",
									"            }\r",
									"        }) {\r",
									"            ${transactionFields}\r",
									"        }\r",
									"        transactionPacs002: transaction(where: {\r",
									"            _and: {\r",
									"                tenantid: {_eq: $tenantId},\r",
									"                txtp: {_eq: \"pacs.002.001.12\"},\r",
									"                source: {_eq: $cdtrAcctId},\r",
									"                destination: {_eq: $dbtrAcctId}\r",
									"            }\r",
									"        }) {\r",
									"            ${transactionFields}\r",
									"        }\r",
									"    }`,\r",
									"    variables: {\r",
									"        tenantId: tenantId,\r",
									"        dbtrId: dataCache.dbtrId,\r",
									"        cdtrId: dataCache.cdtrId,\r",
									"        dbtrAcctId: dataCache.dbtrAcctId,\r",
									"        cdtrAcctId: dataCache.cdtrAcctId\r",
									"    }\r",
									"};\r",
									"\r",
									"pm.globals.set('qryBody', JSON.stringify(qryBody));"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"const resJson = pm.response.json();\r",
									"\r",
									"const entities = utils.extractData(resJson, `${pm.environment.get(\"db_event_history_entity\")}`);\r",
									"const accountHolders = utils.extractData(resJson, `${pm.environment.get(\"db_event_history_account_holder\")}`);\r",
									"const accounts = utils.extractData(resJson, `${pm.environment.get(\"db_event_history_account\")}`);\r",
									"const pain001 = (utils.extractData(resJson, \"transactionPain001\"));\r",
									"const pain013 = (utils.extractData(resJson, \"transactionPain013\"));\r",
									"const pacs008 = (utils.extractData(resJson, \"transactionPacs008\"));\r",
									"const pacs002 = (utils.extractData(resJson, \"transactionPacs002\"));\r",
									"\r",
									"const dataCache = JSON.parse(pm.globals.get(\"dataCache\"));\r",
									"const tenantId = pm.globals.get(\"tenantId\");\r",
									"const activePain001 = JSON.parse(pm.environment.get('activePain001'));\r",
									"\r",
									"pm.test(\"All entity data updated as expected\", function() {\r",
									"\r",
									"    pm.expect(entities, `entities: Should be an array`).to.be.an(`array`);\r",
									"    pm.expect(entities, `entities: Should have exactly 2 records`).to.have.lengthOf(2);\r",
									"\r",
									"    const debtor = entities.find(ntty => ntty.id === dataCache.dbtrId);\r",
									"    pm.expect(debtor, `entities: one of the entities is the debtor`).to.exist;\r",
									"    pm.expect(debtor.id, `entities: debtor id matches ingested dataCache.dbtrId`).to.equal(dataCache.dbtrId);\r",
									"    pm.expect(debtor.tenantid, `entities: debtor tenantid matches ingested tenantId`).to.equal(tenantId);\r",
									"\r",
									"    const creditor = entities.find(ntty => ntty.id === dataCache.cdtrId);\r",
									"    pm.expect(creditor, `entities: one of the entities is the creditor`).to.exist;\r",
									"    pm.expect(creditor.id, `entities: creditor id matches ingested dataCache.cdtrId`).to.equal(dataCache.cdtrId);\r",
									"    pm.expect(creditor.tenantid, `entities: creditor tenantid matches ingested tenantId`).to.equal(tenantId);\r",
									"\r",
									"    if (activePain001) {\r",
									"        pm.expect(utils.normalizeUTC(debtor.credttm), `entities: debtor credttm matches ingested pain.001 credDtTm`).to.equal(pm.globals.get(\"timestampPain001\"));\r",
									"        pm.expect(utils.normalizeUTC(creditor.credttm), `entities: creditor credttm matches ingested pain.013 credDtTm`).to.equal(pm.globals.get(\"timestampPain001\"));\r",
									"    } else {\r",
									"        pm.expect(utils.normalizeUTC(debtor.credttm), `entities: debtor credttm matches ingested pacs.008 credDtTm`).to.equal(pm.globals.get(\"timestampPacs008\"));\r",
									"        pm.expect(utils.normalizeUTC(creditor.credttm), `entities: creditor credttm matches ingested pacs.008 credDtTm`).to.equal(pm.globals.get(\"timestampPacs008\"));\r",
									"    }\r",
									"});\r",
									"\r",
									"pm.test(\"All account data updated as expected\", function() {\r",
									"\r",
									"    pm.expect(accounts, `accounts: Should be an array`).to.be.an(`array`);\r",
									"    pm.expect(accounts, `accounts: Should have exactly 2 records`).to.have.lengthOf(2);\r",
									"\r",
									"    const debtorAccount = accounts.find(acct => acct.id === dataCache.dbtrAcctId);\r",
									"    pm.expect(debtorAccount, `accounts: one of the accounts is the debtor account`).to.exist;\r",
									"    pm.expect(debtorAccount.id, `accounts: debtor account id matches ingested dataCache.dbtrAcctId`).to.equal(dataCache.dbtrAcctId);\r",
									"    pm.expect(debtorAccount.tenantid, `accounts: debtor tenantid matches ingested tenantId`).to.equal(tenantId);\r",
									"\r",
									"    const creditorAccount = accounts.find(acct => acct.id === dataCache.cdtrAcctId);\r",
									"    pm.expect(creditorAccount, `accounts: one of the accounts is the creditor account`).to.exist;\r",
									"    pm.expect(creditorAccount.id, `accounts: creditor account id matches ingested dataCache.cdtrAcctId`).to.equal(dataCache.cdtrAcctId);\r",
									"    pm.expect(creditorAccount.tenantid, `accounts: creditor tenantid matches ingested tenantId`).to.equal(tenantId);\r",
									"});\r",
									"\r",
									"pm.test(\"All account_holder data updated as expected\", function() {\r",
									"\r",
									"    pm.expect(accountHolders, `accounts: Should be an array`).to.be.an(`array`);\r",
									"    pm.expect(accountHolders, `accounts: Should have exactly 2 records`).to.have.lengthOf(2);\r",
									"\r",
									"    const debtorAccountHolder = accountHolders.find(edge => edge.source === dataCache.dbtrId);\r",
									"    pm.expect(debtorAccountHolder, `account_holders: one of the account_holders is the debtor`).to.exist;\r",
									"    pm.expect(debtorAccountHolder.source, `account_holders: should be from the debtor (source)\"`).to.equal(dataCache.dbtrId);\r",
									"    pm.expect(debtorAccountHolder.destination, `account_holders: should be to the debtor account (destination)\"`).to.equal(dataCache.dbtrAcctId);\r",
									"    pm.expect(debtorAccountHolder.tenantid, `account_holders: tenantid matches ingested tenantId`).to.equal(tenantId);\r",
									"\r",
									"    const creditorAccountHolder = accountHolders.find(edge => edge.source === dataCache.cdtrId);\r",
									"    pm.expect(creditorAccountHolder, `account_holders: one of the account_holders is the creditor`).to.exist;\r",
									"    pm.expect(creditorAccountHolder.source, `account_holders: should be from the creditor (source)\"`).to.equal(dataCache.cdtrId);\r",
									"    pm.expect(creditorAccountHolder.destination, `account_holders: should be to the creditor account (destination)\"`).to.equal(dataCache.cdtrAcctId);\r",
									"    pm.expect(creditorAccountHolder.tenantid, `account_holders: tenantid matches ingested tenantId`).to.equal(tenantId);\r",
									"\r",
									"    if (activePain001) {\r",
									"        pm.expect(utils.normalizeUTC(debtorAccountHolder.credttm), `account_holders: debtor edge credttm matches ingested pain.001 credDtTm`).to.equal(pm.globals.get(\"timestampPain001\"));\r",
									"        pm.expect(utils.normalizeUTC(debtorAccountHolder.credttm), `account_holders: creditor edge credttm matches ingested pain.013 credDtTm`).to.equal(pm.globals.get(\"timestampPain001\"));\r",
									"    } else {\r",
									"        pm.expect(utils.normalizeUTC(debtorAccountHolder.credttm), `account_holders: debtor edge credttm matches ingested pacs.008 credDtTm`).to.equal(pm.globals.get(\"timestampPacs008\"));\r",
									"        pm.expect(utils.normalizeUTC(debtorAccountHolder.credttm), `account_holders: creditor edge credttm matches ingested pacs.008 credDtTm`).to.equal(pm.globals.get(\"timestampPacs008\"));\r",
									"    }\r",
									"});\r",
									"\r",
									"pm.test(\"All transaction event data updated as expected\", function() {\r",
									"\r",
									"    if (activePain001) {\r",
									"        pm.expect(pacs001, `transactions - pacs.001: should be an array`).to.be.an(`array`);\r",
									"        pm.expect(pacs001, `transactions - pacs.001: should have exactly 1 record`).to.have.lengthOf(1);\r",
									"        pm.expect(pacs001[0].source, `transactions - pacs.001: should be from the debtor account (source)`).to.equal(dataCache.dbtrAcctId);\r",
									"        pm.expect(pacs001[0].destination, `transactions - pacs.001: should be to the creditor account (destination)`).to.equal(dataCache.cdtrAcctId);\r",
									"        pm.expect(pacs001[0].txtp, `transactions - pacs.001: txtp should be \"pacs.001.001.10\"`).to.equal(\"pacs.001.001.10\");\r",
									"        pm.expect(pacs001[0].msgid, `transactions - pacs.001: msgid Should match ingested transaction`).to.equal(pm.globals.get(\"messageIdPacs001\"));\r",
									"        pm.expect(pacs001[0].tenantid, `transactions - pacs.001: tenantid Should match ingested transaction`).to.equal(pm.globals.get(\"tenantId\"));\r",
									"        pm.expect(pacs001[0].endtoendid, `transactions - pacs.001: endtoendid should match ingested EndToEndId`).to.equal(pm.globals.get(\"endToEndId\"));\r",
									"        \r",
									"        pm.expect(pacs013, `transactions - pacs.013: should be an array`).to.be.an(`array`);\r",
									"        pm.expect(pacs013, `transactions - pacs.013: should have exactly 1 record`).to.have.lengthOf(1);\r",
									"        pm.expect(pacs013[0].source, `transactions - pacs.013: should be from the creditor account (source)`).to.equal(dataCache.cdtrAcctId);\r",
									"        pm.expect(pacs013[0].destination, `transactions - pacs.013: should be to the debtor account (destination)`).to.equal(dataCache.dbtrAcctId);\r",
									"        pm.expect(pacs013[0].txtp, `transactions - pacs.013: txtp should be \"pacs.001.001.10\"`).to.equal(\"pacs.013.001.12\");\r",
									"        pm.expect(pacs013[0].msgid, `transactions - pacs.013: msgid should match ingested transaction`).to.equal(pm.globals.get(\"messageIdPacs013\"));\r",
									"        pm.expect(pacs013[0].tenantid, `transactions - pacs.013: tenantid should match ingested transaction`).to.equal(pm.globals.get(\"tenantId\"));\r",
									"        pm.expect(pacs013[0].endtoendid, `transactions - pacs.013: endtoendid should match ingested EndToEndId`).to.equal(pm.globals.get(\"endToEndId\"));\r",
									"    } else {\r",
									"        pm.expect(pain001, `pain.001: Should be an empty array`).to.be.an(`array`).that.is.empty;\r",
									"        pm.expect(pain013, `pain.001: Should be an empty array`).to.be.an(`array`).that.is.empty;\r",
									"    }\r",
									"\r",
									"    pm.expect(pacs008, `transactions - pacs.008: should be an array`).to.be.an(`array`);\r",
									"    pm.expect(pacs008, `transactions - pacs.008: should have exactly 1 record`).to.have.lengthOf(1);\r",
									"    pm.expect(pacs008[0].source, `transactions - pacs.008: should be from the debtor account (source)\"`).to.equal(dataCache.dbtrAcctId);\r",
									"    pm.expect(pacs008[0].destination, `transactions - pacs.008: should be to the creditor account (destination)\"`).to.equal(dataCache.cdtrAcctId);\r",
									"    pm.expect(pacs008[0].txtp, `transactions - pacs.008: txtp should be \"pacs.008.001.10\"`).to.equal(\"pacs.008.001.10\");\r",
									"    pm.expect(pacs008[0].msgid, `transactions - pacs.008: msgid should match ingested transaction`).to.equal(pm.globals.get(\"messageIdPacs008\"));\r",
									"    pm.expect(pacs008[0].tenantid, `transactions - pacs.008: tenantid should match ingested transaction`).to.equal(pm.globals.get(\"tenantId\"));\r",
									"    pm.expect(pacs008[0].endtoendid, `transactions - pacs.008: endtoendid should match ingested EndToEndId`).to.equal(pm.globals.get(\"endToEndId\"));\r",
									"    \r",
									"    pm.expect(pacs002, `transactions - pacs.002: should be an array`).to.be.an(`array`);\r",
									"    pm.expect(pacs002, `transactions - pacs.008: should have exactly 1 record`).to.have.lengthOf(1);\r",
									"    pm.expect(pacs002[0].source, `transactions - pacs.008: should be from the creditor account (source)\"`).to.equal(dataCache.cdtrAcctId);\r",
									"    pm.expect(pacs002[0].destination, `transactions - pacs.008: should be to the debtor account (destination)\"`).to.equal(dataCache.dbtrAcctId);\r",
									"    pm.expect(pacs002[0].txtp, `transactions - pacs.008: txtp should be \"pacs.008.001.10\"`).to.equal(\"pacs.002.001.12\");\r",
									"    pm.expect(pacs002[0].msgid, `transactions - pacs.008: msgid should match ingested transaction`).to.equal(pm.globals.get(\"messageIdPacs002\"));\r",
									"    pm.expect(pacs002[0].tenantid, `transactions - pacs.008: tenantid should match ingested transaction`).to.equal(pm.globals.get(\"tenantId\"));\r",
									"    pm.expect(pacs002[0].endtoendid, `transactions - pacs.008: endtoendid should match ingested EndToEndId`).to.equal(pm.globals.get(\"endToEndId\"));\r",
									"});\r",
									"\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{auth-token}}",
									"type": "string"
								}
							]
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{{qryBody}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{hasuraUrl}}/v1/graphql",
							"host": [
								"{{hasuraUrl}}"
							],
							"path": [
								"v1",
								"graphql"
							]
						}
					},
					"response": []
				},
				{
					"name": "Fetch evaluation results with msgId from Hasura",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);\r",
									"\r",
									"const qryBody = {\r",
									"    query: `query GetEvaluationReport($msgid: String!, $tenantid: String!)\r",
									"  {\r",
									"    evaluation(where: {\r",
									"        messageid: {\r",
									"            _eq: $msgid\r",
									"            },\r",
									"            tenantid: {\r",
									"                _eq: $tenantid\r",
									"                }\r",
									"                })\r",
									"                {\r",
									"                    evaluation messageid tenantid\r",
									"                    }\r",
									"                    }`,\r",
									"    variables: {\r",
									"        msgid: pm.globals.get(\"messageIdPacs002\"),\r",
									"        tenantid: pm.globals.get(\"tenantId\")\r",
									"    }\r",
									"};\r",
									"\r",
									"pm.globals.set('qryBody', JSON.stringify(qryBody));"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"const resJson = pm.response.json().data.evaluation[0].evaluation;\r",
									"const logLevel = utils.getLogLevel();\r",
									"\r",
									"const totalExpectedTypologies = 1;\r",
									"const rulesPerTypologyCount = [34];\r",
									"const expectedAlertStatus = \"NALT\";\r",
									"const interdictionTypologies = [\r",
									"    \"000\"\r",
									"];\r",
									"const ruleDescriptions = {\r",
									"    \"001\": \"Derived account age - creditor\",\r",
									"    \"002\": \"Transaction convergence - debtor\",\r",
									"    \"003\": \"Account dormancy - creditor\",\r",
									"    \"004\": \"Account dormancy - debtor\",\r",
									"    \"006\": \"Outgoing transfer similarity - amounts\",\r",
									"    \"007\": \"Outgoing transfer similarity - descriptions\",\r",
									"    \"008\": \"Outgoing transfer similarity - creditor\",\r",
									"    \"010\": \"Increased account activity: volume - debtor\",\r",
									"    \"011\": \"Increased account activity: volume - creditor\",\r",
									"    \"016\": \"Transaction convergence - creditor\",\r",
									"    \"017\": \"Transaction divergence - debtor\",\r",
									"    \"018\": \"Exceptionally large outgoing transfer - debtor\",\r",
									"    \"020\": \"Large transaction amount vs history - creditor\",\r",
									"    \"021\": \"A large number of similar transaction amounts - creditor\",\r",
									"    \"024\": \"Non-commissioned transaction mirroring - creditor\",\r",
									"    \"025\": \"Non-commissioned transaction mirroring - debtor\",\r",
									"    \"026\": \"Commissioned transaction mirroring - creditor\",\r",
									"    \"027\": \"Commissioned transaction mirroring - debtor\",\r",
									"    \"028\": \"Age classification - debtor\",\r",
									"    \"030\": \"Transfer to unfamiliar creditor account - debtor\",\r",
									"    \"044\": \"Successful transactions from the debtor, including the new transaction\",\r",
									"    \"045\": \"Successful transactions to the creditor, including the new transaction\",\r",
									"    \"048\": \"Large transaction amount vs history - debtor\",\r",
									"    \"054\": \"Synthetic data check - Benford's Law - debtor\",\r",
									"    \"063\": \"Synthetic data check - Benford's Law - creditor\",\r",
									"    \"074\": \"Distance over time from last transaction location - debtor\",\r",
									"    \"075\": \"Distance from habitual locations - debtor\",\r",
									"    \"076\": \"Time since last transaction - debtor\",\r",
									"    \"078\": \"Transaction type\",\r",
									"    \"083\": \"Multiple accounts associated with a debtor\",\r",
									"    \"084\": \"Multiple accounts associated with a creditor\",\r",
									"    \"090\": \"Upstream transaction divergence - debtor\",\r",
									"    \"091\": \"Transaction amount vs regulatory threshold\"\r",
									"}\r",
									"const typologyDescriptions = {\r",
									"    \"000\": \"Complete rule coverage\"\r",
									"}\r",
									"const expectedIndependentVariable = [\r",
									"    /* rule-001 */ 300000,\r",
									"    /* rule-002 */ 0,\r",
									"    /* rule-003 */ 0,\r",
									"    /* rule-004 */ 0,\r",
									"    /* rule-006 */ 0,\r",
									"    /* rule-007 */ 0,\r",
									"    /* rule-008 */ 0,\r",
									"    /* rule-010 */ 0,\r",
									"    /* rule-011 */ 0,\r",
									"    /* rule-016 */ 1,\r",
									"    /* rule-017 */ 1,\r",
									"    /* rule-018 */ 0,\r",
									"    /* rule-020 */ 0,\r",
									"    /* rule-021 */ 0,\r",
									"    /* rule-024 */ 0,\r",
									"    /* rule-025 */ 0,\r",
									"    /* rule-026 */ 0,\r",
									"    /* rule-027 */ 0,\r",
									"    /* rule-028 */ 25,\r",
									"    /* rule-030 */ 1,\r",
									"    /* rule-044 */ 1,\r",
									"    /* rule-045 */ 1,\r",
									"    /* rule-048 */ 0,\r",
									"    /* rule-054 */ 0,\r",
									"    /* rule-063 */ 0,\r",
									"    /* rule-074 */ 0,\r",
									"    /* rule-075 */ 0,\r",
									"    /* rule-076 */ 0,\r",
									"    /* rule-078 */ 0,\r",
									"    /* rule-083 */ 1,\r",
									"    /* rule-084 */ 1,\r",
									"    /* rule-090 */ 0,\r",
									"    /* rule-091 */ 0,\r",
									"    /* EFRuP    */ 0];\r",
									"\r",
									"let ruleCount = 0;\r",
									"let typologyCount = 0;\r",
									"let slowestRule = 0;\r",
									"let fastestRule = 999999999;\r",
									"let slowestTypology = 0;\r",
									"let fastestTypology = 999999999;\r",
									"let totalRule = 0;\r",
									"let totalTypology = 0;\r",
									"let prcgTmDP = resJson.report.metaData.prcgTmDP;\r",
									"let prcgTmED = resJson.report.metaData.prcgTmED;\r",
									"let tadpTime = resJson.report.tadpResult.prcgTm;\r",
									"let whichTypologyIsSlowest = 0;\r",
									"let whichTypologyIsFastest = 0;\r",
									"let whichRuleIsSlowest = 0;\r",
									"\r",
									"let typologyTimings = resJson.report.tadpResult.typologyResult.filter(e => e.prcgTm > 0);\r",
									"\r",
									"let timingsPerTypology = `Elapsed typology processor time per typology\r",
									"====================================================\r",
									"`;\r",
									"\r",
									"let sortedTypologyTimings = typologyTimings.sort((e1, e2) => (e1.prcgTm < e2.prcgTm) ? 1 : (e1.prcgTm > e2.prcgTm) ? -1 : 0);\r",
									"\r",
									"for (let i = 0; i < sortedTypologyTimings.count(); i++) {\r",
									"    timingsPerTypology = timingsPerTypology + `   ${sortedTypologyTimings[i].cfg}: ${(sortedTypologyTimings[i].prcgTm/1000000).toFixed(3)}\\n`;\r",
									"}\r",
									"\r",
									"typologyTimings = typologyTimings.filter(e => e.prcgTm > 0).map(e => e.prcgTm);\r",
									"\r",
									"ruleResults = [];\r",
									"for (let i = 0; i < resJson.report.tadpResult.typologyResult.count(); i++) {\r",
									"    ruleResultsPerTypology = resJson.report.tadpResult.typologyResult[i].ruleResults.filter(e => e.prcgTm > 0);\r",
									"    for (let j = 0; j < ruleResultsPerTypology.count(); j++) {\r",
									"        ruleResults.push(ruleResultsPerTypology[j]);\r",
									"    };\r",
									"    ruleResultsPerTypology = [];\r",
									"}\r",
									"\r",
									"const ruleResultsUnique = [...new Map(ruleResults.map((e) => [e.id, e])).values()];\r",
									"ruleTimings = ruleResultsUnique.filter(e => e.prcgTm > 0).map(e => e.prcgTm);\r",
									"\r",
									"ruleCount = ruleTimings.count();\r",
									"typologyCount = typologyTimings.count();\r",
									"\r",
									"for (let i = 0; i < typologyCount; i++) {\r",
									"    totalTypology += typologyTimings[i];\r",
									"    if (typologyTimings[i] > slowestTypology) {\r",
									"        slowestTypology = typologyTimings[i];\r",
									"        whichTypologyIsSlowest = i;\r",
									"    }\r",
									"    if (typologyTimings[i] < fastestTypology) {\r",
									"        fastestTypology = typologyTimings[i];\r",
									"        whichTypologyIsFastest = i;\r",
									"    }\r",
									"}\r",
									"\r",
									"for (let i = 0; i < ruleCount; i++) {\r",
									"    totalRule += ruleTimings[i];\r",
									"    if (ruleTimings[i] > slowestRule) {\r",
									"        slowestRule = ruleTimings[i];\r",
									"    }\r",
									"    if (ruleTimings[i] < fastestRule) {\r",
									"        fastestRule = ruleTimings[i];\r",
									"    }\r",
									"}\r",
									"\r",
									"whichRuleIsSlowest = ruleResultsUnique.filter(e => e.prcgTm === slowestRule)[0].id;\r",
									"whichRuleIsFastest = ruleResultsUnique.filter(e => e.prcgTm === fastestRule)[0].id;\r",
									"\r",
									"let totalEstimatedTime = prcgTmDP + prcgTmED + slowestRule + slowestTypology + tadpTime;\r",
									"let averageRuleTime = totalRule / ruleCount;\r",
									"let averageTypologyTime = totalTypology / typologyCount;\r",
									"\r",
									"if ((logLevel === \"DEBUG\") || (logLevel === \"INFO\")) {\r",
									"    console.log(`\r",
									"    ====================================================\r",
									"    Total Estimate Time: ${(totalEstimatedTime/1000000).toFixed(3)}ms;\r",
									"    ====================================================\r",
									"    Data Preparation Service: ${(prcgTmDP/1000000).toFixed(3)}ms\r",
									"    ED: ${(prcgTmED/1000000).toFixed(3)}ms\r",
									"    ====================================================\r",
									"    Number of Rules: ${ruleCount}\r",
									"    Slowest Rule: ${(slowestRule/1000000).toFixed(3)}ms (Rule ${whichRuleIsSlowest})\r",
									"    Fastest Rule: ${(fastestRule/1000000).toFixed(3)}ms (Rule ${whichRuleIsFastest})\r",
									"    Rule Average: ${(averageRuleTime/1000000).toFixed(3)}ms\r",
									"    ====================================================\r",
									"    Number of Typologies: ${typologyCount}\r",
									"    Slowest Typology: ${(slowestTypology/1000000).toFixed(3)}ms (Typology ${resJson.report.tadpResult.typologyResult[whichTypologyIsSlowest].cfg})\r",
									"    Fastest Typology: ${(fastestTypology/1000000).toFixed(3)}ms (Typology ${resJson.report.tadpResult.typologyResult[whichTypologyIsFastest].cfg})\r",
									"\r",
									"    Typology Average: ${(averageTypologyTime/1000000).toFixed(3)}ms\r",
									"    ====================================================\r",
									"    TADP: ${(tadpTime/1000000).toFixed(3)}ms\r",
									"    ====================================================`);\r",
									"}\r",
									"\r",
									"let timingsPerRule = `\r",
									"    Elapsed time per rule\r",
									"    ====================================================\r",
									"`;\r",
									"\r",
									"let sortedRuleTimings = ruleResultsUnique.sort((e1, e2) => (e1.prcgTm < e2.prcgTm) ? 1 : (e1.prcgTm > e2.prcgTm) ? -1 : 0);\r",
									"\r",
									"for (let i = 0; i < sortedRuleTimings.count(); i++) {\r",
									"    timingsPerRule = timingsPerRule + `    ${sortedRuleTimings[i].id}: ${(sortedRuleTimings[i].prcgTm/1000000).toFixed(3)} - ${ruleDescriptions[sortedRuleTimings[i].id.substring(0,3)]}\\n`;\r",
									"}\r",
									"\r",
									"if ((logLevel === \"DEBUG\") || (logLevel === \"INFO\")) {\r",
									"    console.log(timingsPerRule);\r",
									"    console.log(timingsPerTypology);\r",
									"}\r",
									"\r",
									"let sortedRuleTimingsById = ruleResultsUnique.sort((e1, e2) => (e1.id > e2.id) ? 1 : (e1.id < e2.id) ? -1 : 0);\r",
									"\r",
									"if (logLevel === \"DEBUG\") {\r",
									"    console.log(sortedRuleTimingsById);\r",
									"}\r",
									"\r",
									"for (let i = 0; i < sortedRuleTimingsById.length; i++) {\r",
									"    pm.test(`Rule ${sortedRuleTimingsById[i].id}@${sortedRuleTimingsById[i].cfg} result.reason omitted`, function () {\r",
									"        pm.expect(sortedRuleTimingsById[i].reason).to.be.eql(undefined);\r",
									"    });\r",
									"\r",
									"    pm.test(`Rule ${sortedRuleTimingsById[i].id}@${sortedRuleTimingsById[i].cfg} result.desc omitted`, function () {\r",
									"        pm.expect(sortedRuleTimingsById[i].desc).to.be.eql(undefined);\r",
									"    });\r",
									"\r",
									"    if (sortedRuleTimingsById[i].id === \"091@1.0.0\") { // rule-091\r",
									"        let instructedAmount = resJson.dataCache.instdAmt.amt;\r",
									"        pm.test(`Rule ${sortedRuleTimingsById[i].id}@${sortedRuleTimingsById[i].cfg} result.indpdntVarbl ${sortedRuleTimingsById[i].indpdntVarbl} matches amount ${instructedAmount}`, function () {\r",
									"            pm.expect(sortedRuleTimingsById[i].indpdntVarbl).to.be.eql(instructedAmount);\r",
									"        });\r",
									"    } else {\r",
									"        pm.test(`Rule ${sortedRuleTimingsById[i].id}@${sortedRuleTimingsById[i].cfg} result.indpdntVarbl ${sortedRuleTimingsById[i].indpdntVarbl} matches target ${expectedIndependentVariable[i]}`, function () {\r",
									"            pm.expect(sortedRuleTimingsById[i].indpdntVarbl).to.be.eql(expectedIndependentVariable[i]);\r",
									"        });\r",
									"    };\r",
									"\r",
									"}\r",
									"\r",
									"pm.test(`Total (estimated) processing time: ${(totalEstimatedTime / 1000000).toFixed(3)} milliseconds`, function () {\r",
									"    pm.expect(totalEstimatedTime).to.be.greaterThan(0);\r",
									"});\r",
									"\r",
									"pm.test(`Data preparation procesing time: ${(prcgTmDP / 1000000).toFixed(3)} milliseconds`, function () {\r",
									"    pm.expect(prcgTmDP).to.be.greaterThan(0);\r",
									"});\r",
									"\r",
									"pm.test(`ED procesing time: ${(prcgTmED / 1000000).toFixed(3)} milliseconds`, function () {\r",
									"    pm.expect(prcgTmED).to.be.greaterThan(0);\r",
									"});\r",
									"\r",
									"pm.test(`Slowest rule procesing time: ${(slowestRule / 1000000).toFixed(3)} milliseconds (Rule ${whichRuleIsSlowest})`, function () {\r",
									"    pm.expect(slowestRule).to.be.greaterThan(0);\r",
									"});\r",
									"\r",
									"pm.test(`Fastest rule procesing time: ${(fastestRule / 1000000).toFixed(3)} milliseconds (Rule ${whichRuleIsFastest})`, function () {\r",
									"    pm.expect(fastestRule).to.be.greaterThan(0);\r",
									"});\r",
									"\r",
									"pm.test(`Average rule procesing time: ${(averageRuleTime / 1000000).toFixed(3)} milliseconds`, function () {\r",
									"    pm.expect(averageRuleTime).to.be.greaterThan(0);\r",
									"});\r",
									"\r",
									"pm.test(`Slowest typology processing time: ${(slowestTypology / 1000000).toFixed(3)} milliseconds (Typology ${resJson.report.tadpResult.typologyResult[whichTypologyIsSlowest].id})`, function () {\r",
									"    pm.expect(slowestTypology).to.be.greaterThan(0);\r",
									"});\r",
									"\r",
									"pm.test(`Fastest typology processing time: ${(fastestTypology / 1000000).toFixed(3)} milliseconds (Typology ${resJson.report.tadpResult.typologyResult[whichTypologyIsFastest].id})`, function () {\r",
									"    pm.expect(fastestTypology).to.be.lessThan(999999999);\r",
									"});\r",
									"\r",
									"pm.test(`Average typology processing time: ${(averageTypologyTime / 1000000).toFixed(3)} milliseconds`, function () {\r",
									"    pm.expect(averageTypologyTime).to.be.greaterThan(0);\r",
									"});\r",
									"\r",
									"pm.test(`TADProc processing time: ${(tadpTime / 1000000).toFixed(3)} milliseconds`, function () {\r",
									"    pm.expect(tadpTime).to.be.greaterThan(0);\r",
									"});\r",
									"\r",
									"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
									"    pm.expect(resJson.report.status).to.equal(expectedAlertStatus);\r",
									"});\r",
									"\r",
									"let sortedTypologiesById = resJson.report.tadpResult.typologyResult.sort((e1, e2) => (e1.cfg > e2.cfg) ? 1 : (e1.cfg < e2.cfg) ? -1 : 0);\r",
									"\r",
									"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
									"    pm.expect(sortedTypologiesById.length).to.equal(totalExpectedTypologies);\r",
									"});\r",
									"\r",
									"let ruleWeightingTotal = 0;\r",
									"for (let i = 0; i < sortedTypologiesById.length; i++) {\r",
									"    ruleWeightingTotal = 0;\r",
									"    for (let j = 0; j < sortedTypologiesById[i].ruleResults.length; j++) {\r",
									"        ruleWeightingTotal += sortedTypologiesById[i].ruleResults[j].wght;\r",
									"    }\r",
									"\r",
									"    pm.test(`Typology ${sortedTypologiesById[i].cfg} contains ${rulesPerTypologyCount[i]} rule results`, function () {\r",
									"        pm.expect(sortedTypologiesById[i].ruleResults.length).to.equal(rulesPerTypologyCount[i]);\r",
									"    });\r",
									"\r",
									"    pm.test(`Typology ${sortedTypologiesById[i].cfg} result (${sortedTypologiesById[i].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
									"        pm.expect(sortedTypologiesById[i].result).to.equal(ruleWeightingTotal);\r",
									"    });\r",
									"\r",
									"    if (sortedTypologiesById[i].cfg == \"105@1.0.0\" && expectedAlertStatus == \"ALRT\") {\r",
									"        pm.test(`Typology ${sortedTypologiesById[i].cfg} result (${sortedTypologiesById[i].result}) breached threshold (${sortedTypologiesById[i].workflow.alertThreshold})`, function () {\r",
									"            pm.expect(sortedTypologiesById[i].result).to.be.greaterThanOrEqual(sortedTypologiesById[i].workflow.alertThreshold);\r",
									"        });\r",
									"        pm.test(`Typology ${sortedTypologiesById[i].cfg} review flag is true`, function () {\r",
									"            pm.expect(sortedTypologiesById[i].review).to.be.true;\r",
									"        });\r",
									"    } else {\r",
									"        pm.test(`Typology ${sortedTypologiesById[i].cfg} result (${sortedTypologiesById[i].result}) did not breach threshold (${sortedTypologiesById[i].workflow.alertThreshold})`, function () {\r",
									"            pm.expect(sortedTypologiesById[i].result).to.be.lessThan(sortedTypologiesById[i].workflow.alertThreshold);\r",
									"        });\r",
									"        pm.test(`Typology ${sortedTypologiesById[i].cfg} review flag is false`, function () {\r",
									"            pm.expect(sortedTypologiesById[i].review).to.be.false;\r",
									"        });\r",
									"    }\r",
									"\r",
									"    if (interdictionTypologies.includes(sortedTypologiesById[i].cfg.split('@')[0])) {\r",
									"        pm.test(`Typology ${sortedTypologiesById[i].cfg} interdictionThreshold is greater than zero if not omitted`, function () {\r",
									"            pm.expect(sortedTypologiesById[i].workflow.interdictionThreshold).to.be.greaterThan(0);\r",
									"        });\r",
									"    } else {\r",
									"        pm.test(`Typology ${sortedTypologiesById[i].cfg} interdictionThreshold is omitted`, function () {\r",
									"            pm.expect(sortedTypologiesById[i].workflow.interdictionThreshold).to.be.eql(undefined);\r",
									"        });\r",
									"    }\r",
									"}"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{auth-token}}",
									"type": "string"
								}
							]
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{{qryBody}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{hasuraUrl}}/v1/graphql",
							"host": [
								"{{hasuraUrl}}"
							],
							"path": [
								"v1",
								"graphql"
							]
						}
					},
					"response": []
				},
				{
					"name": "Fetch evaluation results with msgId from admin-service",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(`Fetching result for pacs.002 msgId: ${pm.globals.get('messageIdPacs002')}`);"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"const resJson = pm.response.json().data;\r",
									"const logLevel = utils.getLogLevel();\r",
									"\r",
									"const totalExpectedTypologies = 1;\r",
									"const rulesPerTypologyCount = [34];\r",
									"const expectedAlertStatus = \"NALT\";\r",
									"const interdictionTypologies = [\r",
									"    \"000\"\r",
									"];\r",
									"const ruleDescriptions = {\r",
									"    \"001\": \"Derived account age - creditor\",\r",
									"    \"002\": \"Transaction convergence - debtor\",\r",
									"    \"003\": \"Account dormancy - creditor\",\r",
									"    \"004\": \"Account dormancy - debtor\",\r",
									"    \"006\": \"Outgoing transfer similarity - amounts\",\r",
									"    \"007\": \"Outgoing transfer similarity - descriptions\",\r",
									"    \"008\": \"Outgoing transfer similarity - creditor\",\r",
									"    \"010\": \"Increased account activity: volume - debtor\",\r",
									"    \"011\": \"Increased account activity: volume - creditor\",\r",
									"    \"016\": \"Transaction convergence - creditor\",\r",
									"    \"017\": \"Transaction divergence - debtor\",\r",
									"    \"018\": \"Exceptionally large outgoing transfer - debtor\",\r",
									"    \"020\": \"Large transaction amount vs history - creditor\",\r",
									"    \"021\": \"A large number of similar transaction amounts - creditor\",\r",
									"    \"024\": \"Non-commissioned transaction mirroring - creditor\",\r",
									"    \"025\": \"Non-commissioned transaction mirroring - debtor\",\r",
									"    \"026\": \"Commissioned transaction mirroring - creditor\",\r",
									"    \"027\": \"Commissioned transaction mirroring - debtor\",\r",
									"    \"028\": \"Age classification - debtor\",\r",
									"    \"030\": \"Transfer to unfamiliar creditor account - debtor\",\r",
									"    \"044\": \"Successful transactions from the debtor, including the new transaction\",\r",
									"    \"045\": \"Successful transactions to the creditor, including the new transaction\",\r",
									"    \"048\": \"Large transaction amount vs history - debtor\",\r",
									"    \"054\": \"Synthetic data check - Benford's Law - debtor\",\r",
									"    \"063\": \"Synthetic data check - Benford's Law - creditor\",\r",
									"    \"074\": \"Distance over time from last transaction location - debtor\",\r",
									"    \"075\": \"Distance from habitual locations - debtor\",\r",
									"    \"076\": \"Time since last transaction - debtor\",\r",
									"    \"078\": \"Transaction type\",\r",
									"    \"083\": \"Multiple accounts associated with a debtor\",\r",
									"    \"084\": \"Multiple accounts associated with a creditor\",\r",
									"    \"090\": \"Upstream transaction divergence - debtor\",\r",
									"    \"091\": \"Transaction amount vs regulatory threshold\"\r",
									"}\r",
									"const typologyDescriptions = {\r",
									"    \"000\": \"Complete rule coverage\"\r",
									"}\r",
									"const expectedIndependentVariable = [\r",
									"    /* rule-001 */ 300000,\r",
									"    /* rule-002 */ 0,\r",
									"    /* rule-003 */ 0,\r",
									"    /* rule-004 */ 0,\r",
									"    /* rule-006 */ 0,\r",
									"    /* rule-007 */ 0,\r",
									"    /* rule-008 */ 0,\r",
									"    /* rule-010 */ 0,\r",
									"    /* rule-011 */ 0,\r",
									"    /* rule-016 */ 1,\r",
									"    /* rule-017 */ 1,\r",
									"    /* rule-018 */ 0,\r",
									"    /* rule-020 */ 0,\r",
									"    /* rule-021 */ 0,\r",
									"    /* rule-024 */ 0,\r",
									"    /* rule-025 */ 0,\r",
									"    /* rule-026 */ 0,\r",
									"    /* rule-027 */ 0,\r",
									"    /* rule-028 */ 25,\r",
									"    /* rule-030 */ 1,\r",
									"    /* rule-044 */ 1,\r",
									"    /* rule-045 */ 1,\r",
									"    /* rule-048 */ 0,\r",
									"    /* rule-054 */ 0,\r",
									"    /* rule-063 */ 0,\r",
									"    /* rule-074 */ 0,\r",
									"    /* rule-075 */ 0,\r",
									"    /* rule-076 */ 0,\r",
									"    /* rule-078 */ 0,\r",
									"    /* rule-083 */ 1,\r",
									"    /* rule-084 */ 1,\r",
									"    /* rule-090 */ 0,\r",
									"    /* rule-091 */ 0,\r",
									"    /* EFRuP    */ 0];\r",
									"\r",
									"let ruleCount = 0;\r",
									"let typologyCount = 0;\r",
									"let slowestRule = 0;\r",
									"let fastestRule = 999999999;\r",
									"let slowestTypology = 0;\r",
									"let fastestTypology = 999999999;\r",
									"let totalRule = 0;\r",
									"let totalTypology = 0;\r",
									"let prcgTmDP = resJson.report.metaData.prcgTmDP;\r",
									"let prcgTmED = resJson.report.metaData.prcgTmED;\r",
									"let tadpTime = resJson.report.tadpResult.prcgTm;\r",
									"let whichTypologyIsSlowest = 0;\r",
									"let whichTypologyIsFastest = 0;\r",
									"let whichRuleIsSlowest = 0;\r",
									"\r",
									"let typologyTimings = resJson.report.tadpResult.typologyResult.filter(e => e.prcgTm > 0);\r",
									"\r",
									"let timingsPerTypology = `Elapsed typology processor time per typology\r",
									"====================================================\r",
									"`;\r",
									"\r",
									"let sortedTypologyTimings = typologyTimings.sort((e1, e2) => (e1.prcgTm < e2.prcgTm) ? 1 : (e1.prcgTm > e2.prcgTm) ? -1 : 0);\r",
									"\r",
									"for (let i = 0; i < sortedTypologyTimings.count(); i++) {\r",
									"    timingsPerTypology = timingsPerTypology + `   ${sortedTypologyTimings[i].cfg}: ${(sortedTypologyTimings[i].prcgTm/1000000).toFixed(3)}\\n`;\r",
									"}\r",
									"\r",
									"typologyTimings = typologyTimings.filter(e => e.prcgTm > 0).map(e => e.prcgTm);\r",
									"\r",
									"ruleResults = [];\r",
									"for (let i = 0; i < resJson.report.tadpResult.typologyResult.count(); i++) {\r",
									"    ruleResultsPerTypology = resJson.report.tadpResult.typologyResult[i].ruleResults.filter(e => e.prcgTm > 0);\r",
									"    for (let j = 0; j < ruleResultsPerTypology.count(); j++) {\r",
									"        ruleResults.push(ruleResultsPerTypology[j]);\r",
									"    };\r",
									"    ruleResultsPerTypology = [];\r",
									"}\r",
									"\r",
									"const ruleResultsUnique = [...new Map(ruleResults.map((e) => [e.id, e])).values()];\r",
									"ruleTimings = ruleResultsUnique.filter(e => e.prcgTm > 0).map(e => e.prcgTm);\r",
									"\r",
									"ruleCount = ruleTimings.count();\r",
									"typologyCount = typologyTimings.count();\r",
									"\r",
									"for (let i = 0; i < typologyCount; i++) {\r",
									"    totalTypology += typologyTimings[i];\r",
									"    if (typologyTimings[i] > slowestTypology) {\r",
									"        slowestTypology = typologyTimings[i];\r",
									"        whichTypologyIsSlowest = i;\r",
									"    }\r",
									"    if (typologyTimings[i] < fastestTypology) {\r",
									"        fastestTypology = typologyTimings[i];\r",
									"        whichTypologyIsFastest = i;\r",
									"    }\r",
									"}\r",
									"\r",
									"for (let i = 0; i < ruleCount; i++) {\r",
									"    totalRule += ruleTimings[i];\r",
									"    if (ruleTimings[i] > slowestRule) {\r",
									"        slowestRule = ruleTimings[i];\r",
									"    }\r",
									"    if (ruleTimings[i] < fastestRule) {\r",
									"        fastestRule = ruleTimings[i];\r",
									"    }\r",
									"}\r",
									"\r",
									"whichRuleIsSlowest = ruleResultsUnique.filter(e => e.prcgTm === slowestRule)[0].id;\r",
									"whichRuleIsFastest = ruleResultsUnique.filter(e => e.prcgTm === fastestRule)[0].id;\r",
									"\r",
									"let totalEstimatedTime = prcgTmDP + prcgTmED + slowestRule + slowestTypology + tadpTime;\r",
									"let averageRuleTime = totalRule / ruleCount;\r",
									"let averageTypologyTime = totalTypology / typologyCount;\r",
									"\r",
									"if ((logLevel === \"DEBUG\") || (logLevel === \"INFO\")) {\r",
									"    console.log(`\r",
									"    ====================================================\r",
									"    Total Estimate Time: ${(totalEstimatedTime/1000000).toFixed(3)}ms;\r",
									"    ====================================================\r",
									"    Data Preparation Service: ${(prcgTmDP/1000000).toFixed(3)}ms\r",
									"    ED: ${(prcgTmED/1000000).toFixed(3)}ms\r",
									"    ====================================================\r",
									"    Number of Rules: ${ruleCount}\r",
									"    Slowest Rule: ${(slowestRule/1000000).toFixed(3)}ms (Rule ${whichRuleIsSlowest})\r",
									"    Fastest Rule: ${(fastestRule/1000000).toFixed(3)}ms (Rule ${whichRuleIsFastest})\r",
									"    Rule Average: ${(averageRuleTime/1000000).toFixed(3)}ms\r",
									"    ====================================================\r",
									"    Number of Typologies: ${typologyCount}\r",
									"    Slowest Typology: ${(slowestTypology/1000000).toFixed(3)}ms (Typology ${resJson.report.tadpResult.typologyResult[whichTypologyIsSlowest].cfg})\r",
									"    Fastest Typology: ${(fastestTypology/1000000).toFixed(3)}ms (Typology ${resJson.report.tadpResult.typologyResult[whichTypologyIsFastest].cfg})\r",
									"\r",
									"    Typology Average: ${(averageTypologyTime/1000000).toFixed(3)}ms\r",
									"    ====================================================\r",
									"    TADP: ${(tadpTime/1000000).toFixed(3)}ms\r",
									"    ====================================================`);\r",
									"}\r",
									"\r",
									"let timingsPerRule = `\r",
									"    Elapsed time per rule\r",
									"    ====================================================\r",
									"`;\r",
									"\r",
									"let sortedRuleTimings = ruleResultsUnique.sort((e1, e2) => (e1.prcgTm < e2.prcgTm) ? 1 : (e1.prcgTm > e2.prcgTm) ? -1 : 0);\r",
									"\r",
									"for (let i = 0; i < sortedRuleTimings.count(); i++) {\r",
									"    timingsPerRule = timingsPerRule + `    ${sortedRuleTimings[i].id}: ${(sortedRuleTimings[i].prcgTm/1000000).toFixed(3)} - ${ruleDescriptions[sortedRuleTimings[i].id.substring(0,3)]}\\n`;\r",
									"}\r",
									"\r",
									"if ((logLevel === \"DEBUG\") || (logLevel === \"INFO\")) {\r",
									"    console.log(timingsPerRule);\r",
									"    console.log(timingsPerTypology);\r",
									"}\r",
									"\r",
									"let sortedRuleTimingsById = ruleResultsUnique.sort((e1, e2) => (e1.id > e2.id) ? 1 : (e1.id < e2.id) ? -1 : 0);\r",
									"\r",
									"if (logLevel === \"DEBUG\") {\r",
									"    console.log(sortedRuleTimingsById);\r",
									"}\r",
									"\r",
									"for (let i = 0; i < sortedRuleTimingsById.length; i++) {\r",
									"    pm.test(`Rule ${sortedRuleTimingsById[i].id}@${sortedRuleTimingsById[i].cfg} result.reason omitted`, function () {\r",
									"        pm.expect(sortedRuleTimingsById[i].reason).to.be.eql(undefined);\r",
									"    });\r",
									"\r",
									"    pm.test(`Rule ${sortedRuleTimingsById[i].id}@${sortedRuleTimingsById[i].cfg} result.desc omitted`, function () {\r",
									"        pm.expect(sortedRuleTimingsById[i].desc).to.be.eql(undefined);\r",
									"    });\r",
									"\r",
									"    if (sortedRuleTimingsById[i].id === \"091@1.0.0\") { // rule-091\r",
									"        let instructedAmount = resJson.dataCache.instdAmt.amt;\r",
									"        pm.test(`Rule ${sortedRuleTimingsById[i].id}@${sortedRuleTimingsById[i].cfg} result.indpdntVarbl ${sortedRuleTimingsById[i].indpdntVarbl} matches amount ${instructedAmount}`, function () {\r",
									"            pm.expect(sortedRuleTimingsById[i].indpdntVarbl).to.be.eql(instructedAmount);\r",
									"        });\r",
									"    } else {\r",
									"        pm.test(`Rule ${sortedRuleTimingsById[i].id}@${sortedRuleTimingsById[i].cfg} result.indpdntVarbl ${sortedRuleTimingsById[i].indpdntVarbl} matches target ${expectedIndependentVariable[i]}`, function () {\r",
									"            pm.expect(sortedRuleTimingsById[i].indpdntVarbl).to.be.eql(expectedIndependentVariable[i]);\r",
									"        });\r",
									"    };\r",
									"\r",
									"}\r",
									"\r",
									"pm.test(`Total (estimated) processing time: ${(totalEstimatedTime / 1000000).toFixed(3)} milliseconds`, function () {\r",
									"    pm.expect(totalEstimatedTime).to.be.greaterThan(0);\r",
									"});\r",
									"\r",
									"pm.test(`Data preparation procesing time: ${(prcgTmDP / 1000000).toFixed(3)} milliseconds`, function () {\r",
									"    pm.expect(prcgTmDP).to.be.greaterThan(0);\r",
									"});\r",
									"\r",
									"pm.test(`ED procesing time: ${(prcgTmED / 1000000).toFixed(3)} milliseconds`, function () {\r",
									"    pm.expect(prcgTmED).to.be.greaterThan(0);\r",
									"});\r",
									"\r",
									"pm.test(`Slowest rule procesing time: ${(slowestRule / 1000000).toFixed(3)} milliseconds (Rule ${whichRuleIsSlowest})`, function () {\r",
									"    pm.expect(slowestRule).to.be.greaterThan(0);\r",
									"});\r",
									"\r",
									"pm.test(`Fastest rule procesing time: ${(fastestRule / 1000000).toFixed(3)} milliseconds (Rule ${whichRuleIsFastest})`, function () {\r",
									"    pm.expect(fastestRule).to.be.greaterThan(0);\r",
									"});\r",
									"\r",
									"pm.test(`Average rule procesing time: ${(averageRuleTime / 1000000).toFixed(3)} milliseconds`, function () {\r",
									"    pm.expect(averageRuleTime).to.be.greaterThan(0);\r",
									"});\r",
									"\r",
									"pm.test(`Slowest typology processing time: ${(slowestTypology / 1000000).toFixed(3)} milliseconds (Typology ${resJson.report.tadpResult.typologyResult[whichTypologyIsSlowest].id})`, function () {\r",
									"    pm.expect(slowestTypology).to.be.greaterThan(0);\r",
									"});\r",
									"\r",
									"pm.test(`Fastest typology processing time: ${(fastestTypology / 1000000).toFixed(3)} milliseconds (Typology ${resJson.report.tadpResult.typologyResult[whichTypologyIsFastest].id})`, function () {\r",
									"    pm.expect(fastestTypology).to.be.lessThan(999999999);\r",
									"});\r",
									"\r",
									"pm.test(`Average typology processing time: ${(averageTypologyTime / 1000000).toFixed(3)} milliseconds`, function () {\r",
									"    pm.expect(averageTypologyTime).to.be.greaterThan(0);\r",
									"});\r",
									"\r",
									"pm.test(`TADProc processing time: ${(tadpTime / 1000000).toFixed(3)} milliseconds`, function () {\r",
									"    pm.expect(tadpTime).to.be.greaterThan(0);\r",
									"});\r",
									"\r",
									"pm.test(`Report status is ${expectedAlertStatus}`, function () {\r",
									"    pm.expect(resJson.report.status).to.equal(expectedAlertStatus);\r",
									"});\r",
									"\r",
									"let sortedTypologiesById = resJson.report.tadpResult.typologyResult.sort((e1, e2) => (e1.cfg > e2.cfg) ? 1 : (e1.cfg < e2.cfg) ? -1 : 0);\r",
									"\r",
									"pm.test(`Evaluation result contains ${totalExpectedTypologies} typology results`, function () {\r",
									"    pm.expect(sortedTypologiesById.length).to.equal(totalExpectedTypologies);\r",
									"});\r",
									"\r",
									"let ruleWeightingTotal = 0;\r",
									"for (let i = 0; i < sortedTypologiesById.length; i++) {\r",
									"    ruleWeightingTotal = 0;\r",
									"    for (let j = 0; j < sortedTypologiesById[i].ruleResults.length; j++) {\r",
									"        ruleWeightingTotal += sortedTypologiesById[i].ruleResults[j].wght;\r",
									"    }\r",
									"\r",
									"    pm.test(`Typology ${sortedTypologiesById[i].cfg} contains ${rulesPerTypologyCount[i]} rule results`, function () {\r",
									"        pm.expect(sortedTypologiesById[i].ruleResults.length).to.equal(rulesPerTypologyCount[i]);\r",
									"    });\r",
									"\r",
									"    pm.test(`Typology ${sortedTypologiesById[i].cfg} result (${sortedTypologiesById[i].result}) matches rule weighting total (${ruleWeightingTotal})`, function () {\r",
									"        pm.expect(sortedTypologiesById[i].result).to.equal(ruleWeightingTotal);\r",
									"    });\r",
									"\r",
									"    if (sortedTypologiesById[i].cfg == \"105@1.0.0\" && expectedAlertStatus == \"ALRT\") {\r",
									"        pm.test(`Typology ${sortedTypologiesById[i].cfg} result (${sortedTypologiesById[i].result}) breached threshold (${sortedTypologiesById[i].workflow.alertThreshold})`, function () {\r",
									"            pm.expect(sortedTypologiesById[i].result).to.be.greaterThanOrEqual(sortedTypologiesById[i].workflow.alertThreshold);\r",
									"        });\r",
									"        pm.test(`Typology ${sortedTypologiesById[i].cfg} review flag is true`, function () {\r",
									"            pm.expect(sortedTypologiesById[i].review).to.be.true;\r",
									"        });\r",
									"    } else {\r",
									"        pm.test(`Typology ${sortedTypologiesById[i].cfg} result (${sortedTypologiesById[i].result}) did not breach threshold (${sortedTypologiesById[i].workflow.alertThreshold})`, function () {\r",
									"            pm.expect(sortedTypologiesById[i].result).to.be.lessThan(sortedTypologiesById[i].workflow.alertThreshold);\r",
									"        });\r",
									"        pm.test(`Typology ${sortedTypologiesById[i].cfg} review flag is false`, function () {\r",
									"            pm.expect(sortedTypologiesById[i].review).to.be.false;\r",
									"        });\r",
									"    }\r",
									"\r",
									"    if (interdictionTypologies.includes(sortedTypologiesById[i].cfg.split('@')[0])) {\r",
									"        pm.test(`Typology ${sortedTypologiesById[i].cfg} interdictionThreshold is greater than zero if not omitted`, function () {\r",
									"            pm.expect(sortedTypologiesById[i].workflow.interdictionThreshold).to.be.greaterThan(0);\r",
									"        });\r",
									"    } else {\r",
									"        pm.test(`Typology ${sortedTypologiesById[i].cfg} interdictionThreshold is omitted`, function () {\r",
									"            pm.expect(sortedTypologiesById[i].workflow.interdictionThreshold).to.be.eql(undefined);\r",
									"        });\r",
									"    }\r",
									"}"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{auth-token}}",
									"type": "string"
								}
							]
						},
						"method": "GET",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n    \"query\": \"FOR doc in transactions FILTER doc.transaction.FIToFIPmtSts.GrpHdr.MsgId == '{{messageIdPacs002}}' RETURN doc\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{tazamaAdminUrl}}{{path-admin-api-version}}/admin/reports/getreportbymsgid?msgid={{messageIdPacs002}}",
							"host": [
								"{{tazamaAdminUrl}}{{path-admin-api-version}}"
							],
							"path": [
								"admin",
								"reports",
								"getreportbymsgid"
							],
							"query": [
								{
									"key": "msgid",
									"value": "{{messageIdPacs002}}"
								}
							]
						}
					},
					"response": []
				}
			]
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"requests": {},
				"exec": [
					"const uuid = require('uuid');",
					"const lodash = require('lodash');",
					"",
					"const LOGLEVEL = \"ERROR\";",
					"const TENANT_DEFAULT = \"DEFAULT\";",
					"",
					"// Message creation defaults",
					"const DEBTOR_ID_TYPE = \"TAZAMA_EID\";",
					"const DEBTOR_ACCOUNT_TYPE = \"MSISDN\";",
					"const DEBTOR_AGENT_ID = \"fsp001\";",
					"const CREDITOR_ID_TYPE = \"TAZAMA_EID\";",
					"const CREDITOR_ACCOUNT_TYPE = \"MSISDN\";",
					"const CREDITOR_AGENT_ID = \"fsp002\";",
					"",
					"// Postman environment variables",
					"const POSTGRES_API_URL = `${pm.environment.get('hasuraUrl')}/v1/graphql`;",
					"const POSTGRES_API_SECRET = pm.environment.get('hasuraPassword');",
					"const DB_RAW_HISTORY = pm.environment.get('db_raw_history');",
					"const DB_EVENT_HISTORY = pm.environment.get('db_event_history');",
					"const DB_EVENT_HISTORY_ENTITY = pm.environment.get('db_event_history_entity');",
					"const DB_EVENT_HISTORY_ACCOUNT_HOLDER = pm.environment.get('db_event_history_account_holder');",
					"const DB_EVENT_HISTORY_ACCOUNT = pm.environment.get('db_event_history_account');",
					"const DB_EVENT_HISTORY_TRANSACTION = pm.environment.get('db_event_history_transaction');",
					"const DB_EVENT_HISTORY_CONDITION = pm.environment.get('db_event_history_condition');",
					"const DB_RAW_HISTORY_PAIN001 = pm.environment.get('db_raw_history_pain001');",
					"const DB_RAW_HISTORY_PAIN013 = pm.environment.get('db_raw_history_pain013');",
					"const DB_RAW_HISTORY_PACS008 = pm.environment.get('db_raw_history_pacs008');",
					"const DB_RAW_HISTORY_PACS002 = pm.environment.get('db_raw_history_pacs002');",
					"",
					"prep = {",
					"",
					"    /**",
					"       * Constructs a pain.001.001.11 message for initiating a customer credit transfer.",
					"       *",
					"       * @param {string} messageIdPain001 - Unique identifier for the message.",
					"       * @param {string} timestampPain001 - Timestamp of message creation.",
					"       * @param {string} debtorDoB - Date of birth of the debtor.",
					"       * @param {string} debtorId - Identifier for the debtor.",
					"       * @param {string} debtorAccountId - Account identifier for the debtor.",
					"       * @param {string} debtorAccountIdType - Account scheme name for the debtor.",
					"       * @param {string} endToEndId - Unique end-to-end transaction identifier.",
					"       * @param {string} transactionPurpose - Purpose of the transaction.",
					"       * @param {string} instructedCurrency - Currency code for the instructed amount.",
					"       * @param {number} instructedAmount - Instructed amount.",
					"       * @param {string} interbankSettlementCurrency - Currency code for the equivalent amount.",
					"       * @param {number} interbankSettlementAmount - Equivalent amount.",
					"       * @param {number} exchangeRateCurrency - Currency in which the rate of exchange is expressed in the currency exchange (assumed to match instructedCurrency).",
					"       * @param {number} exchangeRate - Exchange rate applied to the instructed amount to achieve the equivalent amount.",
					"       * @param {string} creditorId - Identifier for the creditor.",
					"       * @param {string} creditorAccountId - Account identifier for the creditor.",
					"       * @param {string} creditorAccountIdType - Account scheme name for the creditor.",
					"       * @param {string} transactionDescription - Description of the transaction.",
					"       * @param {string} transactionLat - Latitude coordinate of the transaction location.",
					"       * @param {string} transactionLong - Longitude coordinate of the transaction location.",
					"       * ",
					"       * @returns {object} A pain.001.001.11 message object for customer credit transfer initiation.",
					"       */",
					"    prepPain001Msg: function (messageIdPain001, timestampPain001, debtorDoB, debtorId, debtorIdType, debtorAccountId, debtorAccountIdType, debtorAgentId, endToEndId, transactionPurpose, instructedCurrency, instructedAmount, interbankSettlementCurrency, interbankSettlementAmount, exchangeRateCurrency, exchangeRate, creditorId, creditorIdType, creditorAccountId, creditorAccountIdType, creditorAgentId, transactionDescription, transactionLat, transactionLong, dataCache) {",
					"",
					"        if (LOGLEVEL === \"DEBUG\") {",
					"            logStatement = {",
					"                \"messageIdPain001\": `${messageIdPain001}`,",
					"                \"timestampPain001\": `${timestampPain001}`,",
					"                \"debtorDoB\": `${debtorDoB}`,",
					"                \"debtorId\": `${debtorId}`,",
					"                \"debtorIdType\": `${debtorIdType}`,",
					"                \"debtorAccountId\": `${debtorAccountId}`,",
					"                \"debtorAccountIdType\": `${debtorAccountIdType}`,",
					"                \"debtorAgentId\": `${debtorAgentId}`,",
					"                \"endToEndId\": `${endToEndId}`,",
					"                \"transactionPurpose\": `${transactionPurpose}`,",
					"                \"instructedCurrency\": `${instructedCurrency}`,",
					"                \"instructedAmount\": `${instructedAmount}`,",
					"                \"interbankSettlementCurrency\": `${interbankSettlementCurrency}`,",
					"                \"interbankSettlementAmount\": `${interbankSettlementAmount}`,",
					"                \"exchangeRateCurrency\": `${exchangeRateCurrency}`,",
					"                \"exchangeRate\": `${exchangeRate}`,",
					"                \"creditorId\": `${creditorId}`,",
					"                \"creditorIdType\": `${creditorIdType}`,",
					"                \"creditorAccountId\": `${creditorAccountId}`,",
					"                \"creditorAccountIdType\": `${creditorAccountIdType}`,",
					"                \"creditorAgentId\": `${creditorAgentId}`,",
					"                \"transactionDescription\": `${transactionDescription}`,",
					"                \"transactionLat\": `${transactionLat}`,",
					"                \"transactionLong\": `${transactionLong}`",
					"            }",
					"            console.log(`prepPain001Msg() input parameters:`);",
					"            console.log(JSON.stringify(logStatement, null, 2));",
					"            console.log(`\"dataCache\": ${JSON.stringify(dataCache, null, 2)}`);",
					"        }",
					"",
					"        message = {",
					"            \"TxTp\": \"pain.001.001.11\",",
					"            \"CstmrCdtTrfInitn\": {",
					"                \"GrpHdr\": {",
					"                    \"MsgId\": `${messageIdPain001}`,",
					"                    \"CreDtTm\": `${timestampPain001}`,",
					"                    \"NbOfTxs\": 1,",
					"                    \"InitgPty\": {",
					"                        \"Nm\": \"April Blake Grant\",",
					"                        \"Id\": {",
					"                            \"PrvtId\": {",
					"                                \"DtAndPlcOfBirth\": {",
					"                                    \"BirthDt\": \"1968-02-01\",",
					"                                    \"CityOfBirth\": \"Unknown\",",
					"                                    \"CtryOfBirth\": \"ZZ\"",
					"                                },",
					"                                \"Othr\": [{",
					"                                    \"Id\": \"+27730975224\",",
					"                                    \"SchmeNm\": {",
					"                                        \"Prtry\": `${debtorAccountIdType}`",
					"                                    }",
					"                                }]",
					"                            }",
					"                        },",
					"                        \"CtctDtls\": {",
					"                            \"MobNb\": \"+27-730975224\"",
					"                        }",
					"                    }",
					"                },",
					"                \"PmtInf\": {",
					"                    \"PmtInfId\": \"5ab4fc7355de4ef8a75b78b00a681ed2\",",
					"                    \"PmtMtd\": \"TRA\",",
					"                    \"ReqdAdvcTp\": {",
					"                        \"DbtAdvc\": {",
					"                            \"Cd\": \"ADWD\",",
					"                            \"Prtry\": \"Advice with transaction details\"",
					"                        }",
					"                    },",
					"                    \"ReqdExctnDt\": {",
					"                        \"Dt\": \"2023-06-02\",",
					"                        \"DtTm\": \"2023-06-02T07:50:57.000Z\"",
					"                    },",
					"                    \"Dbtr\": {",
					"                        \"Nm\": \"April Blake Grant\",",
					"                        \"Id\": {",
					"                            \"PrvtId\": {",
					"                                \"DtAndPlcOfBirth\": {",
					"                                    \"BirthDt\": `${debtorDoB}`,",
					"                                    \"CityOfBirth\": \"Unknown\",",
					"                                    \"CtryOfBirth\": \"ZZ\"",
					"                                },",
					"                                \"Othr\": [{",
					"                                    \"Id\": `${debtorId}`,",
					"                                    \"SchmeNm\": {",
					"                                        \"Prtry\": `${debtorIdType}`",
					"                                    }",
					"                                }]",
					"                            }",
					"                        },",
					"                        \"CtctDtls\": {",
					"                            \"MobNb\": \"+27-730975224\"",
					"                        }",
					"                    },",
					"                    \"DbtrAcct\": {",
					"                        \"Id\": {",
					"                            \"Othr\": [{",
					"                                \"Id\": `${debtorAccountId}`,",
					"                                \"SchmeNm\": {",
					"                                    \"Prtry\": `${debtorAccountIdType}`",
					"                                }",
					"                            }]",
					"                        },",
					"                        \"Nm\": \"April Grant\"",
					"                    },",
					"                    \"DbtrAgt\": {",
					"                        \"FinInstnId\": {",
					"                            \"ClrSysMmbId\": {",
					"                                \"MmbId\": `${debtorAgentId}`",
					"                            }",
					"                        }",
					"                    },",
					"                    \"CdtTrfTxInf\": {",
					"                        \"PmtId\": {",
					"                            \"EndToEndId\": `${endToEndId}`",
					"                        },",
					"                        \"PmtTpInf\": {",
					"                            \"CtgyPurp\": {",
					"                                \"Prtry\": `${transactionPurpose}`",
					"                            }",
					"                        },",
					"                        \"Amt\": {",
					"                            \"InstdAmt\": {",
					"                                \"Amt\": {",
					"                                    \"Amt\": instructedAmount,",
					"                                    \"Ccy\": `${instructedCurrency}`",
					"                                }",
					"                            },",
					"                            \"EqvtAmt\": {",
					"                                \"Amt\": {",
					"                                    \"Amt\": interbankSettlementAmount,",
					"                                    \"Ccy\": `${interbankSettlementCurrency}`",
					"                                },",
					"                                \"CcyOfTrf\": `${exchangeRateCurrency}`",
					"                            }",
					"                        },",
					"                        \"XchgRateInf\": {",
					"                            \"UnitCcy\": `${exchangeRateCurrency}`,",
					"                            \"XchgRate\": exchangeRate",
					"                        },",
					"                        \"ChrgBr\": \"DEBT\",",
					"                        \"CdtrAgt\": {",
					"                            \"FinInstnId\": {",
					"                                \"ClrSysMmbId\": {",
					"                                    \"MmbId\": `${creditorAgentId}`",
					"                                }",
					"                            }",
					"                        },",
					"                        \"Cdtr\": {",
					"                            \"Nm\": \"Felicia Easton Quill\",",
					"                            \"Id\": {",
					"                                \"PrvtId\": {",
					"                                    \"DtAndPlcOfBirth\": {",
					"                                        \"BirthDt\": \"1935-05-08\",",
					"                                        \"CityOfBirth\": \"Unknown\",",
					"                                        \"CtryOfBirth\": \"ZZ\"",
					"                                    },",
					"                                    \"Othr\": [{",
					"                                        \"Id\": `${creditorId}`,",
					"                                        \"SchmeNm\": {",
					"                                            \"Prtry\": `${creditorIdType}`",
					"                                        }",
					"                                    }]",
					"                                }",
					"                            },",
					"                            \"CtctDtls\": {",
					"                                \"MobNb\": \"+27-707650428\"",
					"                            }",
					"                        },",
					"                        \"CdtrAcct\": {",
					"                            \"Id\": {",
					"                                \"Othr\": [{",
					"                                    \"Id\": `${creditorAccountId}`,",
					"                                    \"SchmeNm\": {",
					"                                        \"Prtry\": `${creditorAccountIdType}`",
					"                                    }",
					"                                }]",
					"                            },",
					"                            \"Nm\": \"Felicia Quill\"",
					"                        },",
					"                        \"Purp\": {",
					"                            \"Cd\": \"MP2P\"",
					"                        },",
					"                        \"RgltryRptg\": {",
					"                            \"Dtls\": {",
					"                                \"Tp\": \"BALANCE OF PAYMENTS\",",
					"                                \"Cd\": \"100\"",
					"                            }",
					"                        },",
					"                        \"RmtInf\": {",
					"                            \"Ustrd\": `${transactionDescription}`",
					"                        },",
					"                        \"SplmtryData\": {",
					"                            \"Envlp\": {",
					"                                \"Doc\": {",
					"                                    \"Dbtr\": {",
					"                                        \"FrstNm\": \"April\",",
					"                                        \"MddlNm\": \"Blake\",",
					"                                        \"LastNm\": \"Grant\",",
					"                                        \"MrchntClssfctnCd\": \"BLANK\"",
					"                                    },",
					"                                    \"Cdtr\": {",
					"                                        \"FrstNm\": \"Felicia\",",
					"                                        \"MddlNm\": \"Easton\",",
					"                                        \"LastNm\": \"Quill\",",
					"                                        \"MrchntClssfctnCd\": \"BLANK\"",
					"                                    },",
					"                                    \"DbtrFinSvcsPrvdrFees\": {",
					"                                        \"Ccy\": `${instructedCurrency}`,",
					"                                        \"Amt\": 0.00",
					"                                    },",
					"                                    \"Xprtn\": \"2021-11-30T10:38:56.000Z\"",
					"                                }",
					"                            }",
					"                        }",
					"                    }",
					"                },",
					"                \"SplmtryData\": {",
					"                    \"Envlp\": {",
					"                        \"Doc\": {",
					"                            \"InitgPty\": {",
					"                                \"InitrTp\": \"CONSUMER\",",
					"                                \"Glctn\": {",
					"                                    \"Lat\": `${transactionLat}`,",
					"                                    \"Long\": `${transactionLong}`",
					"                                }",
					"                            }",
					"                        }",
					"                    }",
					"                }",
					"            },",
					"            \"DataCache\": dataCache",
					"        };",
					"",
					"        if (LOGLEVEL === 'DEBUG') {",
					"            console.log(\"Prepared pain.001.001.11 message:\", JSON.stringify(message));",
					"        }",
					"",
					"        return message;",
					"    },",
					"",
					"    /**",
					"       * Constructs a pain.013.001.09 message for initiating a creditor payment activation request.",
					"       *",
					"       * @param {string} messageIdPain013 - Unique identifier for the message.",
					"       * @param {string} timestampPain013 - Timestamp of message creation.",
					"       * @param {string} debtorDoB - Date of birth of the debtor.",
					"       * @param {string} debtorId - Identifier for the debtor.",
					"       * @param {string} debtorAccountId - Account identifier for the debtor.",
					"       * @param {string} debtorAccountIdType - Account scheme name for the debtor.",
					"       * @param {string} endToEndId - Unique end-to-end transaction identifier.",
					"       * @param {string} currency - Currency code for the transaction amount.",
					"       * @param {number} amount - Transaction amount.",
					"       * @param {string} creditorId - Identifier for the creditor.",
					"       * @param {string} creditorAccountId - Account identifier for the creditor.",
					"       * @param {string} creditorAccountIdType - Account scheme name for the creditor.",
					"       * @param {string} transactionLat - Latitude coordinate of the transaction location.",
					"       * @param {string} transactionLong - Longitude coordinate of the transaction location.",
					"       * ",
					"       * @returns {object} A pain.013.001.09 message object for creditor payment activation request.",
					"       */",
					"    prepPain013Msg: function (messageIdPain013, timestampPain013, debtorDoB, debtorId, debtorIdType, debtorAccountId, debtorAccountIdType, debtorAgentId, endToEndId, instructedCurrency, instructedAmount, interbankSettlementCurrency, interbankSettlementAmount, creditorId, creditorIdType, creditorAccountId, creditorAccountIdType, creditorAgentId, transactionLat, transactionLong, dataCache) {",
					"",
					"        if (LOGLEVEL === \"DEBUG\") {",
					"            logStatement = {",
					"                \"messageIdPain013\": `${messageIdPain013}`,",
					"                \"timestampPain013\": `${timestampPain013}`,",
					"                \"debtorDoB\": `${debtorDoB}`,",
					"                \"debtorId\": `${debtorId}`,",
					"                \"debtorIdType\": `${debtorIdType}`,",
					"                \"debtorAccountId\": `${debtorAccountId}`,",
					"                \"debtorAccountIdType\": `${debtorAccountIdType}`,",
					"                \"debtorAgentId\": `${debtorAgentId}`,",
					"                \"endToEndId\": `${endToEndId}`,",
					"                \"instructedCurrency\": `${instructedCurrency}`,",
					"                \"instructedAmount\": `${instructedAmount}`,",
					"                \"interbankSettlementCurrency\": `${interbankSettlementCurrency}`,",
					"                \"interbankSettlementAmount\": `${interbankSettlementAmount}`,",
					"                \"creditorId\": `${creditorId}`,",
					"                \"creditorIdType\": `${creditorIdType}`,",
					"                \"creditorAccountId\": `${creditorAccountId}`,",
					"                \"creditorAccountIdType\": `${creditorAccountIdType}`,",
					"                \"creditorAgentId\": `${creditorAgentId}`,",
					"                \"transactionLat\": `${transactionLat}`,",
					"                \"transactionLong\": `${transactionLong}`",
					"            }",
					"            console.log(`prepPain013Msg() input parameters:`);",
					"            console.log(JSON.stringify(logStatement, null, 2));",
					"            console.log(`\"dataCache\": ${JSON.stringify(dataCache, null, 2)}`);",
					"        }",
					"",
					"        message = {",
					"            \"TxTp\": \"pain.013.001.09\",",
					"            \"CdtrPmtActvtnReq\": {",
					"                \"GrpHdr\": {",
					"                    \"MsgId\": `${messageIdPain013}`,",
					"                    \"CreDtTm\": `${timestampPain013}`,",
					"                    \"NbOfTxs\": 1,",
					"                    \"InitgPty\": {",
					"                        \"Nm\": \"April Blake Grant\",",
					"                        \"Id\": {",
					"                            \"PrvtId\": {",
					"                                \"DtAndPlcOfBirth\": {",
					"                                    \"BirthDt\": \"1968-02-01\",",
					"                                    \"CityOfBirth\": \"Unknown\",",
					"                                    \"CtryOfBirth\": \"ZZ\"",
					"                                },",
					"                                \"Othr\": [{",
					"                                    \"Id\": \"+27730975224\",",
					"                                    \"SchmeNm\": {",
					"                                        \"Prtry\": `${debtorAccountIdType}`",
					"                                    }",
					"                                }]",
					"                            }",
					"                        },",
					"                        \"CtctDtls\": {",
					"                            \"MobNb\": \"+27-730975224\"",
					"                        }",
					"                    }",
					"                },",
					"                \"PmtInf\": {",
					"                    \"PmtInfId\": \"5ab4fc7355de4ef8a75b78b00a681ed2\",",
					"                    \"PmtMtd\": \"TRA\",",
					"                    \"ReqdAdvcTp\": {",
					"                        \"DbtAdvc\": {",
					"                            \"Cd\": \"ADWD\",",
					"                            \"Prtry\": \"Advice with transaction details\"",
					"                        }",
					"                    },",
					"                    \"ReqdExctnDt\": {",
					"                        \"DtTm\": \"2023-06-02T07:51:48.000Z\"",
					"                    },",
					"                    \"XpryDt\": {",
					"                        \"DtTm\": \"2021-11-30T10:38:56.000Z\"",
					"                    },",
					"                    \"Dbtr\": {",
					"                        \"Nm\": \"April Blake Grant\",",
					"                        \"Id\": {",
					"                            \"PrvtId\": {",
					"                                \"DtAndPlcOfBirth\": {",
					"                                    \"BirthDt\": `${debtorDoB}`,",
					"                                    \"CityOfBirth\": \"Unknown\",",
					"                                    \"CtryOfBirth\": \"ZZ\"",
					"                                },",
					"                                \"Othr\": [{",
					"                                    \"Id\": `${debtorId}`,",
					"                                    \"SchmeNm\": {",
					"                                        \"Prtry\": `${debtorIdType}`",
					"                                    }",
					"                                }]",
					"                            }",
					"                        },",
					"                        \"CtctDtls\": {",
					"                            \"MobNb\": \"+27-730975224\"",
					"                        }",
					"                    },",
					"                    \"DbtrAcct\": {",
					"                        \"Id\": {",
					"                            \"Othr\": [{",
					"                                \"Id\": `${debtorAccountId}`,",
					"                                \"SchmeNm\": {",
					"                                    \"Prtry\": `${debtorAccountIdType}`",
					"                                }",
					"                            }]",
					"                        },",
					"                        \"Nm\": \"April Grant\"",
					"                    },",
					"                    \"DbtrAgt\": {",
					"                        \"FinInstnId\": {",
					"                            \"ClrSysMmbId\": {",
					"                                \"MmbId\": `${debtorAgentId}`",
					"                            }",
					"                        }",
					"                    },",
					"                    \"CdtTrfTxInf\": {",
					"                        \"PmtId\": {",
					"                            \"EndToEndId\": `${endToEndId}`",
					"                        },",
					"                        \"PmtTpInf\": {",
					"                            \"CtgyPurp\": {",
					"                                \"Prtry\": \"TRANSFER BLANK\"",
					"                            }",
					"                        },",
					"                        \"Amt\": {",
					"                            \"InstdAmt\": {",
					"                                \"Amt\": {",
					"                                    \"Amt\": instructedAmount,",
					"                                    \"Ccy\": `${instructedCurrency}`",
					"                                }",
					"                            },",
					"                            \"EqvtAmt\": {",
					"                                \"Amt\": {",
					"                                    \"Amt\": interbankSettlementAmount,",
					"                                    \"Ccy\": `${interbankSettlementCurrency}`",
					"                                },",
					"                                \"CcyOfTrf\": `${instructedCurrency}`",
					"                            }",
					"                        },",
					"                        \"ChrgBr\": \"DEBT\",",
					"                        \"CdtrAgt\": {",
					"                            \"FinInstnId\": {",
					"                                \"ClrSysMmbId\": {",
					"                                    \"MmbId\": `${creditorAgentId}`",
					"                                }",
					"                            }",
					"                        },",
					"                        \"Cdtr\": {",
					"                            \"Nm\": \"Felicia Easton Quill\",",
					"                            \"Id\": {",
					"                                \"PrvtId\": {",
					"                                    \"DtAndPlcOfBirth\": {",
					"                                        \"BirthDt\": \"1935-05-08\",",
					"                                        \"CityOfBirth\": \"Unknown\",",
					"                                        \"CtryOfBirth\": \"ZZ\"",
					"                                    },",
					"                                    \"Othr\": [{",
					"                                        \"Id\": `${creditorId}`,",
					"                                        \"SchmeNm\": {",
					"                                            \"Prtry\": `${creditorIdType}`",
					"                                        }",
					"                                    }]",
					"                                }",
					"                            },",
					"                            \"CtctDtls\": {",
					"                                \"MobNb\": \"+27-707650428\"",
					"                            }",
					"                        },",
					"                        \"CdtrAcct\": {",
					"                            \"Id\": {",
					"                                \"Othr\": [{",
					"                                    \"Id\": `${creditorAccountId}`,",
					"                                    \"SchmeNm\": {",
					"                                        \"Prtry\": `${creditorAccountIdType}`",
					"                                    }",
					"                                }]",
					"                            },",
					"                            \"Nm\": \"Felicia Quill\"",
					"                        },",
					"                        \"Purp\": {",
					"                            \"Cd\": \"MP2P\"",
					"                        },",
					"                        \"RgltryRptg\": {",
					"                            \"Dtls\": {",
					"                                \"Tp\": \"BALANCE OF PAYMENTS\",",
					"                                \"Cd\": \"100\"",
					"                            }",
					"                        },",
					"                        \"SplmtryData\": {",
					"                            \"Envlp\": {",
					"                                \"Doc\": {",
					"                                    \"PyeeRcvAmt\": {",
					"                                        \"Amt\": {",
					"                                            \"Amt\": 0.00,",
					"                                            \"Ccy\": `${instructedCurrency}`",
					"                                        }",
					"                                    },",
					"                                    \"PyeeFinSvcsPrvdrFee\": {",
					"                                        \"Amt\": {",
					"                                            \"Amt\": 0.00,",
					"                                            \"Ccy\": `${instructedCurrency}`",
					"                                        }",
					"                                    },",
					"                                    \"PyeeFinSvcsPrvdrComssn\": {",
					"                                        \"Amt\": {",
					"                                            \"Amt\": 0.00,",
					"                                            \"Ccy\": `${instructedCurrency}`",
					"                                        }",
					"                                    }",
					"                                }",
					"                            }",
					"                        }",
					"                    }",
					"                },",
					"                \"SplmtryData\": {",
					"                    \"Envlp\": {",
					"                        \"Doc\": {",
					"                            \"InitgPty\": {",
					"                                \"Glctn\": {",
					"                                    \"Lat\": `${transactionLat}`,",
					"                                    \"Long\": `${transactionLong}`",
					"                                }",
					"                            }",
					"                        }",
					"                    }",
					"                }",
					"            },",
					"            \"DataCache\": dataCache",
					"        };",
					"",
					"        if (LOGLEVEL === 'DEBUG') {",
					"            console.log(\"Pain.013.001.09 Message:\", JSON.stringify(message));",
					"        }",
					"",
					"        return message;",
					"    },",
					"",
					"    /**",
					"       * Constructs a pacs.008.001.10 message for initiating a financial institution to financial institution customer credit transfer.",
					"       *",
					"       * @param {string} messageIdPacs008 - Unique identifier for the message.",
					"       * @param {string} timestampPacs008 - Timestamp of message creation.",
					"       * @param {string} endToEndId - Unique end-to-end transaction identifier.",
					"       * @param {string} instructedCurrency - Currency code for the instructed amount.",
					"       * @param {number} instructedAmount - Instructed amount.",
					"       * @param {string} interbankSettlementCurrency - Currency code for the interbank settlement amount.",
					"       * @param {number} interbankSettlementAmount - Interbank settlement amount.",
					"       * @param {number} exchangeRate - Exchange rate applied to the instructed amount to achieve the interbank settlement amount.",
					"       * @param {string} debtorDoB - Date of birth of the debtor.",
					"       * @param {string} debtorId - Identifier for the debtor.",
					"       * @param {string} debtorAccountId - Account identifier for the debtor.",
					"       * @param {string} debtorAccountIdType - Account scheme name for the debtor.",
					"       * @param {string} creditorId - Identifier for the creditor.",
					"       * @param {string} creditorAccountId - Account identifier for the creditor.",
					"       * @param {string} creditorAccountIdType - Account scheme name for the creditor.",
					"       * @param {string} transactionPurpose - Purpose of the transaction.",
					"       * @param {string} transactionDescription - Description of the transaction.",
					"       * @param {string} transactionLat - Latitude coordinate of the transaction location.",
					"       * @param {string} transactionLong - Longitude coordinate of the transaction location.",
					"       * ",
					"       * @returns {object} A pacs.008.001.10 message object for financial institution to financial institution customer credit transfer.",
					"       */",
					"    prepPacs008Msg: function (messageIdPacs008, timestampPacs008, endToEndId, instructedCurrency, instructedAmount, interbankSettlementCurrency, interbankSettlementAmount, exchangeRate, debtorDoB, debtorId, debtorIdType, debtorAccountId, debtorAccountIdType, debtorAgentId, creditorId, creditorIdType, creditorAccountId, creditorAccountIdType, creditorAgentId, transactionPurpose, transactionDescription, transactionLat, transactionLong, dataCache) {",
					"",
					"        if (LOGLEVEL === \"DEBUG\") {",
					"            logStatement = {",
					"                \"messageIdPacs008\": `${messageIdPacs008}`,",
					"                \"timestampPacs008\": `${timestampPacs008}`,",
					"                \"endToEndId\": `${endToEndId}`,",
					"                \"instructedCurrency\": `${instructedCurrency}`,",
					"                \"instructedAmount\": `${instructedAmount}`,",
					"                \"interbankSettlementCurrency\": `${interbankSettlementCurrency}`,",
					"                \"interbankSettlementAmount\": `${interbankSettlementAmount}`,",
					"                \"exchangeRate\": `${exchangeRate}`,",
					"                \"debtorDoB\": `${debtorDoB}`,",
					"                \"debtorId\": `${debtorId}`,",
					"                \"debtorIdType\": `${debtorIdType}`,",
					"                \"debtorAccountId\": `${debtorAccountId}`,",
					"                \"debtorAccountIdType\": `${debtorAccountIdType}`,",
					"                \"debtorAgentId\": `${debtorAgentId}`,",
					"                \"creditorId\": `${creditorId}`,",
					"                \"creditorIdType\": `${creditorIdType}`,",
					"                \"creditorAccountId\": `${creditorAccountId}`,",
					"                \"creditorAccountIdType\": `${creditorAccountIdType}`,",
					"                \"creditorAgentId\": `${creditorAgentId}`,",
					"                \"transactionPurpose\": `${transactionPurpose}`,",
					"                \"transactionDescription\": `${transactionDescription}`,",
					"                \"transactionLat\": `${transactionLat}`,",
					"                \"transactionLong\": `${transactionLong}`",
					"            }",
					"            console.log(`prepPacs008Msg() input parameters:`);",
					"            console.log(JSON.stringify(logStatement, null, 2));",
					"            console.log(`\"dataCache\": ${JSON.stringify(dataCache, null, 2)}`);",
					"        }",
					"",
					"        message = {",
					"            \"TxTp\": \"pacs.008.001.10\",",
					"            \"FIToFICstmrCdtTrf\": {",
					"                \"GrpHdr\": {",
					"                    \"MsgId\": `${messageIdPacs008}`,",
					"                    \"CreDtTm\": `${timestampPacs008}`,",
					"                    \"NbOfTxs\": 1,",
					"                    \"SttlmInf\": {",
					"                        \"SttlmMtd\": \"CLRG\"",
					"                    }",
					"                },",
					"                \"CdtTrfTxInf\": {",
					"                    \"PmtId\": {",
					"                        \"InstrId\": \"5ab4fc7355de4ef8a75b78b00a681ed2\",",
					"                        \"EndToEndId\": `${endToEndId}`",
					"                    },",
					"                    \"IntrBkSttlmAmt\": {",
					"                        \"Amt\": {",
					"                            \"Amt\": interbankSettlementAmount,",
					"                            \"Ccy\": `${interbankSettlementCurrency}`",
					"                        }",
					"                    },",
					"                    \"InstdAmt\": {",
					"                        \"Amt\": {",
					"                            \"Amt\": instructedAmount,",
					"                            \"Ccy\": `${instructedCurrency}`",
					"                        }",
					"                    },",
					"                    \"XchgRate\": exchangeRate,",
					"                    \"ChrgBr\": \"DEBT\",",
					"                    \"ChrgsInf\": {",
					"                        \"Amt\": {",
					"                            \"Amt\": 0.00,",
					"                            \"Ccy\": `${instructedCurrency}`",
					"                        },",
					"                        \"Agt\": {",
					"                            \"FinInstnId\": {",
					"                                \"ClrSysMmbId\": {",
					"                                    \"MmbId\": `${debtorAgentId}`",
					"                                }",
					"                            }",
					"                        }",
					"                    },",
					"                    \"InitgPty\": {",
					"                        \"Nm\": \"April Blake Grant\",",
					"                        \"Id\": {",
					"                            \"PrvtId\": {",
					"                                \"DtAndPlcOfBirth\": {",
					"                                    \"BirthDt\": \"1968-02-01\",",
					"                                    \"CityOfBirth\": \"Unknown\",",
					"                                    \"CtryOfBirth\": \"ZZ\"",
					"                                },",
					"                                \"Othr\": [{",
					"                                    \"Id\": \"+27730975224\",",
					"                                    \"SchmeNm\": {",
					"                                        \"Prtry\": `${debtorAccountIdType}`",
					"                                    }",
					"                                }]",
					"                            }",
					"                        },",
					"                        \"CtctDtls\": {",
					"                            \"MobNb\": \"+27-730975224\"",
					"                        }",
					"                    },",
					"                    \"Dbtr\": {",
					"                        \"Nm\": \"April Blake Grant\",",
					"                        \"Id\": {",
					"                            \"PrvtId\": {",
					"                                \"DtAndPlcOfBirth\": {",
					"                                    \"BirthDt\": `${debtorDoB}`,",
					"                                    \"CityOfBirth\": \"Unknown\",",
					"                                    \"CtryOfBirth\": \"ZZ\"",
					"                                },",
					"                                \"Othr\": [{",
					"                                    \"Id\": `${debtorId}`,",
					"                                    \"SchmeNm\": {",
					"                                        \"Prtry\": `${debtorIdType}`",
					"                                    }",
					"                                }]",
					"                            }",
					"                        },",
					"                        \"CtctDtls\": {",
					"                            \"MobNb\": \"+27-730975224\"",
					"                        }",
					"                    },",
					"                    \"DbtrAcct\": {",
					"                        \"Id\": {",
					"                            \"Othr\": [{",
					"                                \"Id\": `${debtorAccountId}`,",
					"                                \"SchmeNm\": {",
					"                                    \"Prtry\": `${debtorAccountIdType}`",
					"                                }",
					"                            }]",
					"                        },",
					"                        \"Nm\": \"April Grant\"",
					"                    },",
					"                    \"DbtrAgt\": {",
					"                        \"FinInstnId\": {",
					"                            \"ClrSysMmbId\": {",
					"                                \"MmbId\": `${debtorAgentId}`",
					"                            }",
					"                        }",
					"                    },",
					"                    \"CdtrAgt\": {",
					"                        \"FinInstnId\": {",
					"                            \"ClrSysMmbId\": {",
					"                                \"MmbId\": `${creditorAgentId}`",
					"                            }",
					"                        }",
					"                    },",
					"                    \"Cdtr\": {",
					"                        \"Nm\": \"Felicia Easton Quill\",",
					"                        \"Id\": {",
					"                            \"PrvtId\": {",
					"                                \"DtAndPlcOfBirth\": {",
					"                                    \"BirthDt\": \"1935-05-08\",",
					"                                    \"CityOfBirth\": \"Unknown\",",
					"                                    \"CtryOfBirth\": \"ZZ\"",
					"                                },",
					"                                \"Othr\": [{",
					"                                    \"Id\": `${creditorId}`,",
					"                                    \"SchmeNm\": {",
					"                                        \"Prtry\": `${creditorIdType}`",
					"                                    }",
					"                                }]",
					"                            }",
					"                        },",
					"                        \"CtctDtls\": {",
					"                            \"MobNb\": \"+27-707650428\"",
					"                        }",
					"                    },",
					"                    \"CdtrAcct\": {",
					"                        \"Id\": {",
					"                            \"Othr\": [{",
					"                                \"Id\": `${creditorAccountId}`,",
					"                                \"SchmeNm\": {",
					"                                    \"Prtry\": `${creditorAccountIdType}`",
					"                                }",
					"                            }]",
					"                        },",
					"                        \"Nm\": \"Felicia Quill\"",
					"                    },",
					"                    \"Purp\": {",
					"                        \"Cd\": `${transactionPurpose}`",
					"                    }",
					"                },",
					"                \"RgltryRptg\": {",
					"                    \"Dtls\": {",
					"                        \"Tp\": \"BALANCE OF PAYMENTS\",",
					"                        \"Cd\": \"100\"",
					"                    }",
					"                },",
					"                \"RmtInf\": {",
					"                    \"Ustrd\": `${transactionDescription}`",
					"                },",
					"                \"SplmtryData\": {",
					"                    \"Envlp\": {",
					"                        \"Doc\": {",
					"                            \"Xprtn\": \"2021-11-30T10:38:56.000Z\",",
					"                            \"InitgPty\": {",
					"                                \"Glctn\":",
					"                                {",
					"                                    \"Lat\": `${transactionLat}`,",
					"                                    \"Long\": `${transactionLong}`",
					"                                }",
					"                            }",
					"                        }",
					"                    }",
					"                }",
					"            },",
					"            \"DataCache\": dataCache",
					"        }",
					"",
					"        if (LOGLEVEL === 'DEBUG') {",
					"            console.log(\"pacs.008.001.10 message details:\", JSON.stringify(message));",
					"        }",
					"",
					"        return message;",
					"    },",
					"",
					"    /**",
					"       * Constructs a pacs.002.001.12 message for financial institution to financial institution payment status reporting.",
					"       *",
					"       * @param {string} messageIdPacs002 - Unique identifier for the message.",
					"       * @param {string} timestampPacs002 - Timestamp of message creation.",
					"       * @param {string} endToEndId - Unique end-to-end transaction identifier.",
					"       * @param {string} pacs002Sts - Transaction status.",
					"       * ",
					"       * @returns {object} A pacs.002.001.12 message object for financial institution to financial institution payment status reporting.",
					"       */",
					"    prepPacs002Msg: function (messageIdPacs002, timestampPacs002, endToEndId, pacs002Sts, debtorAgentId, creditorAgentId, dataCache) {",
					"",
					"        if (LOGLEVEL === \"DEBUG\") {",
					"            logStatement = {",
					"                \"messageIdPacs002\": `${messageIdPacs002}`,",
					"                \"timestampPacs002\": `${timestampPacs002}`,",
					"                \"endToEndId\": `${endToEndId}`,",
					"                \"pacs002Sts\": `${pacs002Sts}`,",
					"                \"debtorAgentId\": `${debtorAgentId}`,",
					"                \"creditorAgentId\": `${creditorAgentId}`",
					"            }",
					"            console.log(`prepPacs002Msg() input parameters:`);",
					"            console.log(JSON.stringify(logStatement, null, 2));",
					"            console.log(`\"dataCache\": ${JSON.stringify(dataCache, null, 2)}`);",
					"        }",
					"",
					"        message = {",
					"            \"TxTp\": \"pacs.002.001.12\",",
					"            \"FIToFIPmtSts\": {",
					"                \"GrpHdr\": {",
					"                    \"MsgId\": `${messageIdPacs002}`,",
					"                    \"CreDtTm\": `${timestampPacs002}`",
					"                },",
					"                \"TxInfAndSts\": {",
					"                    \"OrgnlInstrId\": \"5ab4fc7355de4ef8a75b78b00a681ed2\",",
					"                    \"OrgnlEndToEndId\": `${endToEndId}`,",
					"                    \"TxSts\": `${pacs002Sts}`,",
					"                    \"ChrgsInf\": [",
					"                        {",
					"                            \"Amt\": {",
					"                                \"Amt\": 0.00,",
					"                                \"Ccy\": \"USD\"",
					"                            },",
					"                            \"Agt\": {",
					"                                \"FinInstnId\": {",
					"                                    \"ClrSysMmbId\": {",
					"                                        \"MmbId\": `${debtorAgentId}`",
					"                                    }",
					"                                }",
					"                            }",
					"                        },",
					"                        {",
					"                            \"Amt\": {",
					"                                \"Amt\": 0.00,",
					"                                \"Ccy\": \"USD\"",
					"                            },",
					"                            \"Agt\": {",
					"                                \"FinInstnId\": {",
					"                                    \"ClrSysMmbId\": {",
					"                                        \"MmbId\": `${debtorAgentId}`",
					"                                    }",
					"                                }",
					"                            }",
					"                        },",
					"                        {",
					"                            \"Amt\": {",
					"                                \"Amt\": 0.00,",
					"                                \"Ccy\": \"USD\"",
					"                            },",
					"                            \"Agt\": {",
					"                                \"FinInstnId\": {",
					"                                    \"ClrSysMmbId\": {",
					"                                        \"MmbId\": `${creditorAgentId}`",
					"                                    }",
					"                                }",
					"                            }",
					"                        }",
					"                    ],",
					"                    \"AccptncDtTm\": \"2023-06-02T07:52:31.000Z\",",
					"                    \"InstgAgt\": {",
					"                        \"FinInstnId\": {",
					"                            \"ClrSysMmbId\": {",
					"                                \"MmbId\": `${debtorAgentId}`",
					"                            }",
					"                        }",
					"                    },",
					"                    \"InstdAgt\": {",
					"                        \"FinInstnId\": {",
					"                            \"ClrSysMmbId\": {",
					"                                \"MmbId\": `${creditorAgentId}`",
					"                            }",
					"                        }",
					"                    }",
					"                }",
					"            },",
					"            \"DataCache\": dataCache",
					"        };",
					"",
					"        if (LOGLEVEL === 'DEBUG') {",
					"            console.log(\"pacs.002.001.12 message details:\", JSON.stringify(message));",
					"        }",
					"",
					"        return message;",
					"    },",
					"",
					"    /**",
					"       * Constructs a DB-ready event entity.",
					"       *",
					"       * @param {string} tenantId - Identifier for the tenant.",
					"       * @param {string} entityKey - Identifier for the entity.",
					"       * @param {string} timestamp - Timestamp of entity creation.",
					"       * ",
					"       * @returns {Array}  DB-ready entity containing an identifier and a creation timestamp.",
					"       */",
					"    prepEntity: function (tenantId, entityKey, timestamp) {",
					"",
					"        entity = {",
					"            \"id\": entityKey,",
					"            \"tenantid\": tenantId,",
					"            \"credttm\": timestamp",
					"        };",
					"",
					"        if (LOGLEVEL === 'DEBUG') {",
					"            console.log(\"Event entities:\", JSON.stringify(entity, null, 2));",
					"        }",
					"",
					"        return entity;",
					"    },",
					"",
					"    /**",
					"       * Constructs a DB-ready relationship between an account holder and their account.",
					"       *",
					"       * @param {string} tenantId - Identifier for the tenant.",
					"       * @param {string} entityKey - Identifier for the entity.",
					"       * @param {string} accountKey - Account identifier for the entity.",
					"       * @param {string} timestamp - Timestamp of relationship creation.",
					"       * ",
					"       * @returns {Array} A DB-ready relationship, connecting an account holder to their account.",
					"       */",
					"    prepAccountHolder: function (tenantId, entityKey, accountKey, timestamp) {",
					"",
					"        accountHolder = {",
					"            \"tenantid\": tenantId,",
					"            \"source\": entityKey,",
					"            \"destination\": accountKey,",
					"            \"credttm\": timestamp",
					"        }",
					"",
					"        if (LOGLEVEL === 'DEBUG') {",
					"            console.log(\"Account details:\", JSON.stringify(accountHolder, null, 2));",
					"        }",
					"",
					"        return accountHolder;",
					"    },",
					"",
					"    /**",
					"       * Constructs a DB-ready account.",
					"       *",
					"       * @param {string} tenantId - Identifier for the tenant.",
					"       * @param {string} accountKey - Account identifier.",
					"       * ",
					"       * @returns {Array} A DB-ready account object.",
					"       */",
					"    prepAccount: function (tenantId, accountKey) {",
					"",
					"        account = {",
					"            \"id\": accountKey,",
					"            \"tenantid\": tenantId",
					"        };",
					"",
					"        if (LOGLEVEL === 'DEBUG') {",
					"            console.log(\"Account details:\", JSON.stringify(account, null, 2));",
					"        }",
					"",
					"        return account;",
					"    },",
					"",
					"    /**",
					"       * Constructs an array of event entities for a debtor and a creditor.",
					"       *",
					"       * @param {string} tenantId - Identifier for the tenant.",
					"       * @param {string} debtorId - Identifier for the debtor.",
					"       * @param {string} creditorId - Identifier for the creditor.",
					"       * @param {string} timestamp - Timestamp of entity creation.",
					"       * ",
					"       * @returns {Array} An array of graph entities, each containing an identifier and a creation timestamp.",
					"       */",
					"    prepEventEntities: function (tenantId, debtorId, creditorId, timestamp) {",
					"",
					"        entities = [prep.prepEntity(tenantId, debtorId, timestamp), prep.prepEntity(tenantId, creditorId, timestamp)];",
					"",
					"        if (LOGLEVEL === 'DEBUG') {",
					"            console.log(\"Event entities:\", JSON.stringify(entities, null, 2));",
					"        }",
					"",
					"        return entities;",
					"    },",
					"",
					"    /**",
					"       * Constructs an array of debtor and creditor accounts.",
					"       *",
					"       * @param {string} tenantId - Identifier for the tenant.",
					"       * @param {string} debtorAccountId - Account identifier for the debtor.",
					"       * @param {string} creditorAccountId - Account identifier for the creditor.",
					"       * ",
					"       * @returns {Array} An array of graph nodes, each representing an account with a unique identifier.",
					"       */",
					"    prepEventAccounts: function (tenantId, debtorAccountId, creditorAccountId) {",
					"",
					"        accounts = [prep.prepAccount(tenantId, debtorAccountId), prep.prepAccount(tenantId, creditorAccountId)];",
					"",
					"        if (LOGLEVEL === 'DEBUG') {",
					"            console.log(\"Account details:\", JSON.stringify(accounts, null, 2));",
					"        }",
					"",
					"        return accounts;",
					"    },",
					"",
					"    /**",
					"       * Constructs an array of relationships between account holders and their accounts.",
					"       *",
					"       * @param {string} tenantId - Identifier for the tenant.",
					"       * @param {string} debtorId - Identifier for the debtor.",
					"       * @param {string} debtorAccountId - Account identifier for the debtor.",
					"       * @param {string} creditorId - Identifier for the creditor.",
					"       * @param {string} creditorAccountId - Account identifier for the creditor.",
					"       * @param {string} timestamp - Timestamp of relationship creation.",
					"       * ",
					"       * @returns {Array} An array of graph relationships, each connecting an account holder to their account.",
					"       */",
					"    prepEventAccountHolders: function (tenantId, debtorId, debtorAccountId, creditorId, creditorAccountId, timestamp) {",
					"",
					"        accountHolders = [prep.prepAccountHolder(tenantId, debtorId, debtorAccountId, timestamp), prep.prepAccountHolder(tenantId, creditorId, creditorAccountId, timestamp)];",
					"",
					"        if (LOGLEVEL === 'DEBUG') {",
					"            console.log(\"Account holder details:\", JSON.stringify(accountHolders, null, 2));",
					"        }",
					"",
					"        return accountHolders;",
					"    },",
					"",
					"    /**",
					"       * Constructs an array of transactions between debtor and creditor accounts, including various transaction types.",
					"       *",
					"       * @param {string} tenantId - Identifier for the tenant.",
					"       * @param {string} debtorAccountId - Account identifier for the debtor.",
					"       * @param {string} creditorAccountId - Account identifier for the creditor.",
					"       * @param {string} currency - Currency code for the transaction amount.",
					"       * @param {number} amount - Transaction amount.",
					"       * @param {string} endToEndId - Unique end-to-end transaction identifier.",
					"       * @param {string} timestampPacs008 - Timestamp of pacs.008.001.10 message creation.",
					"       * @param {string} timestampPacs002 - Timestamp of pacs.002.001.12 message creation.",
					"       * @param {string} pacs002Sts - Transaction status for pacs.002.001.12 message.",
					"       * @param {string} timestampPain001 - Timestamp of pain.001.001.11 message creation.",
					"       * @param {string} timestampPain013 - Timestamp of pain.013.001.09 message creation.",
					"       * ",
					"       * @returns {Array} An array of graph transactions, each representing a transaction between debtor and creditor accounts.",
					"       */",
					"    prepEventTransactions: function (tenantId, debtorAccountId, creditorAccountId, instructedCurrency, instructedAmount, interbankSettlementCurrency, interbankSettlementAmount, exchangeRateCurrency, exchangeRate, endToEndId, timestampPacs008, messageIdPacs008, timestampPacs002, messageIdPacs002, pacs002Sts, timestampPain001, messageIdPain001, timestampPain013, messageIdPain013) {",
					"",
					"        if (LOGLEVEL === \"DEBUG\") {",
					"            logStatement = {",
					"                \"tenantId\": `${tenantId}`,",
					"                \"debtorAccountId\": `${debtorAccountId}`,",
					"                \"creditorAccountId\": `${creditorAccountId}`,",
					"                \"instructedCurrency\": `${instructedCurrency}`,",
					"                \"instructedAmount\": `${instructedAmount}`,",
					"                \"interbankSettlementCurrency\": `${interbankSettlementCurrency}`,",
					"                \"interbankSettlementAmount\": `${interbankSettlementAmount}`,",
					"                \"exchangeRateCurrency\": `${exchangeRateCurrency}`,",
					"                \"exchangeRate\": `${exchangeRate}`,",
					"                \"endToEndId\": `${endToEndId}`,",
					"                \"timestampPacs008\": `${timestampPacs008}`,",
					"                \"messageIdPacs008\": `${messageIdPacs008}`,",
					"                \"timestampPacs002\": `${timestampPacs002}`,",
					"                \"messageIdPacs002\": `${messageIdPacs002}`,",
					"                \"pacs002Sts\": `${pacs002Sts}`,",
					"                \"timestampPain001\": `${timestampPain001}`,",
					"                \"messageIdPain001\": `${messageIdPain001}`,",
					"                \"timestampPain013\": `${timestampPain013}`,",
					"                \"messageIdPain013\": `${messageIdPain013}`",
					"            }",
					"            console.log(`Transaction DB prep input parameters:`);",
					"            console.log(JSON.stringify(logStatement, null, 2));",
					"        }",
					"",
					"        var transactions = [];",
					"",
					"        if (typeof timestampPain001 !== \"undefined\") {",
					"            transactions.push({",
					"                \"source\": debtorAccountId,",
					"                \"destination\": creditorAccountId,",
					"                \"transaction\": {",
					"                    \"TxTp\": \"pain.001.001.11\",",
					"                    \"TenantId\": tenantId,",
					"                    \"MsgId\": messageIdPain001,",
					"                    \"CreDtTm\": timestampPain001,",
					"                    \"Amt\": instructedAmount,",
					"                    \"Ccy\": instructedCurrency,",
					"                    \"EndToEndId\": endToEndId,",
					"                    /* pending implementation",
					"                    \"instdamt\": {",
					"                        \"amt\": instructedAmount,",
					"                        \"ccy\": instructedCurrency",
					"                    },",
					"                    \"intrbksttlmamt\": {",
					"                        \"amt\": interbankSettlementAmount,",
					"                        \"ccy\": interbankSettlementCurrency",
					"                    },",
					"                    \"xchgrate\": exchangeRate",
					"                    */",
					"                }",
					"            });",
					"            transactions.push({",
					"                \"source\": creditorAccountId,",
					"                \"destination\": debtorAccountId,",
					"                \"transaction\": {",
					"                    \"TxTp\": \"pain.013.001.09\",",
					"                    \"TenantId\": tenantId,",
					"                    \"MsgId\": messageIdPain013,",
					"                    \"CreDtTm\": timestampPain013,",
					"                    \"Amt\": instructedAmount,",
					"                    \"Ccy\": instructedCurrency,",
					"                    \"EndToEndId\": endToEndId,",
					"                    /* pending implementation",
					"                    \"instdamt\": {",
					"                        \"amt\": instructedAmount,",
					"                        \"ccy\": instructedCurrency",
					"                    },",
					"                    \"intrbksttlmamt\": {",
					"                        \"amt\": interbankSettlementAmount,",
					"                        \"ccy\": interbankSettlementCurrency",
					"                    },",
					"                    \"xchgrate\": exchangeRate",
					"                    */",
					"                }",
					"            });",
					"        }",
					"",
					"        transactions.push({",
					"            \"source\": debtorAccountId,",
					"            \"destination\": creditorAccountId,",
					"            \"transaction\": {",
					"                \"TxTp\": \"pacs.008.001.10\",",
					"                \"TenantId\": tenantId,",
					"                \"MsgId\": messageIdPacs008,",
					"                \"CreDtTm\": timestampPacs008,",
					"                \"Amt\": instructedAmount,",
					"                \"Ccy\": instructedCurrency,",
					"                \"EndToEndId\": endToEndId,",
					"                /* pending implementation",
					"                \"instdamt\": {",
					"                    \"amt\": instructedAmount,",
					"                    \"ccy\": instructedCurrency",
					"                },",
					"                \"intrbksttlmamt\": {",
					"                    \"amt\": interbankSettlementAmount,",
					"                    \"ccy\": interbankSettlementCurrency",
					"                },",
					"                \"xchgrate\": exchangeRate",
					"                */",
					"            }",
					"        });",
					"",
					"        if (typeof timestampPacs002 !== \"undefined\") {",
					"            transactions.push({",
					"                \"source\": creditorAccountId,",
					"                \"destination\": debtorAccountId,",
					"                \"transaction\": {",
					"                    \"TxTp\": \"pacs.002.001.12\",",
					"                    \"TenantId\": tenantId,",
					"                    \"MsgId\": messageIdPacs002,",
					"                    \"CreDtTm\": timestampPacs002,",
					"                    \"EndToEndId\": endToEndId,",
					"                    \"TxSts\": pacs002Sts,",
					"                }",
					"            });",
					"        }",
					"",
					"        if (LOGLEVEL === 'DEBUG') {",
					"            console.log(\"Transaction details:\", JSON.stringify(transactions, null, 2));",
					"        }",
					"",
					"        return transactions;",
					"    }",
					"}",
					"",
					"utils = {",
					"    // https://community.postman.com/t/how-to-reuse-function-in-2022/39077/4",
					"    setPm: function (scriptPm) {",
					"        try {",
					"            if (!scriptPm) {",
					"                throw new Error(\"The pm object is not provided.\");",
					"            }",
					"            _pm = scriptPm;",
					"            if ((LOGLEVEL === 'DEBUG') || (LOGLEVEL === 'INFO')) {",
					"                console.log(\"pm object successfully set.\");",
					"            }",
					"        } catch (error) {",
					"            console.error(\"Failed to set pm object:\", error.message);",
					"        }",
					"    },",
					"",
					"    /**",
					"       * Returns the LOGLEVEL value from this script to a test script.",
					"       * ",
					"       * Example: `logLevel = utils.getLogLevel();`",
					"       *",
					"       */",
					"    getLogLevel: function () {",
					"        return LOGLEVEL;",
					"    },",
					"",
					"    /**",
					"       * Converts a time unit to its equivalent in milliseconds.",
					"       * ",
					"       * Example: `weekInMilliseconds = 7 * utils.timeframe('d');`",
					"       *",
					"       * @param {string} unit - The time unit to convert. Supported units are 'd'/'days', 'h'/'hours', 'm'/'minutes', and 's'/'seconds'.",
					"       * @returns {number} The number of milliseconds corresponding to the given time unit.",
					"       */",
					"    timeframe: function (unit) {",
					"        switch (unit) {",
					"            case 'd':",
					"            case 'days':",
					"                milliseconds = 86400000;",
					"                break;",
					"            case 'h':",
					"            case 'hours':",
					"                milliseconds = 3600000;",
					"                break;",
					"            case 'm':",
					"            case 'minutes':",
					"                milliseconds = 60000;",
					"                break;",
					"            case 's':",
					"            case 'seconds':",
					"                milliseconds = 1000;",
					"                break;",
					"            default: milliseconds = 0;",
					"        }",
					"        return milliseconds;",
					"    },",
					"",
					"    /**",
					"     * Calculates a timestamp in the past relative to the current time.",
					"     * ",
					"     * This function computes a timestamp by subtracting a specified duration ",
					"     * (quantum * unit) from the current time and returns it in ISO 8601 format.",
					"     * ",
					"     * Example: ",
					"     * ```javascript",
					"     * // Get timestamp from 7 days ago",
					"     * pastDate = utils.timestampAtTMinus(7, 'd');",
					"     * // Returns: \"2025-10-26T20:30:00.000Z\" (if current date is 2025-11-02)",
					"     * ",
					"     * // Get timestamp from 2 hours ago",
					"     * recentDate = utils.timestampAtTMinus(2, 'h');",
					"     * // Returns: \"2025-11-02T18:30:00.000Z\" (if current time is 20:30:00)",
					"     * ```",
					"     *",
					"     * @param {number} quantum - The quantity of time units to subtract from now.",
					"     * @param {string} unit - The time unit to use. Supported units are 'd'/'days', ",
					"     *                        'h'/'hours', 'm'/'minutes', and 's'/'seconds'.",
					"     * @returns {string} An ISO 8601 formatted timestamp string (e.g., \"2025-11-02T20:30:00.000Z\") ",
					"     *                   representing the calculated past time.",
					"     */",
					"    timestampAtTMinus: function (quantum, unit) {",
					"        elapsedTime = quantum * this.timeframe(unit);",
					"        return new Date(new Date(Date.now()) - elapsedTime).toISOString();",
					"    },",
					"",
					"    /**",
					"       * Generates a UUID (Universally Unique Identifier) in ISO format by removing hyphens from a standard UUID.",
					"       *",
					"       * @returns {string} A UUID in ISO format without hyphens.",
					"       */",
					"    createISOUUID: function () {",
					"        return uuid.v4().replace(/-/g, '');",
					"    },",
					"",
					"    /**",
					"       * Logs a structured message containing payment transaction details to the console.",
					"       * This function facilitates easy tracking and debugging of transaction data by displaying it in a structured JSON format.",
					"       *",
					"       *   @param {Object} dataCache - An object containing all the necessary transaction data.",
					"       *   @param {string} data.dbtrId - Debtor's identifier.",
					"       *   @param {string} data.cdtrId - Creditor's identifier.",
					"       *   @param {string} data.dbtrAcctId - Debtor's account identifier.",
					"       *   @param {string} data.cdtrAcctId - Creditor's account identifier.",
					"       *   @param {string} data.creDtTm - Creation date and time of the transaction, formatted as ISO 8601.",
					"       *   @param {number} data.amt - Transaction amount.",
					"       *   @param {string} data.curr - Currency of the transaction amount.",
					"       *   @param {string} data.endToEndId - End-to-end identifier that uniquely references the transaction.",
					"       *",
					"       * @example",
					"       * logDataCache({",
					"       *   dbtrId: '123',",
					"       *   cdtrId: '456',",
					"       *   dbtrAcctId: '78910',",
					"       *   cdtrAcctId: '111213',",
					"       *   creDtTm: '2020-12-31T23:59:59',",
					"       *  \"instdAmt\": {",
					"       *      \"amt\": 1000,",
					"       *      \"ccy\": \"USD\"",
					"       *  },",
					"       *  \"intrBkSttlmAmt\": {",
					"       *      \"amt\": 18351.11,",
					"       *      \"ccy\": \"ZAR\"",
					"       *  },",
					"       *  \"xchgRate\": 18.35111,",
					"       *   endToEndId: 'E2E123456789'",
					"       * });",
					"       */",
					"    logDataCache: function (dataCache) {",
					"        console.log(JSON.stringify({ DataCache: dataCache }, null, 2));",
					"    },",
					"",
					"    /**",
					"       * Returns the current timestamp in ISO 8601 format.",
					"       *",
					"       * This function retrieves the current date and time, creates a new `Date` object, ",
					"       * and converts it into an ISO 8601 string representation, which is commonly ",
					"       * used for timestamps in APIs and logging.",
					"       *",
					"       * @returns {string} The current timestamp in ISO 8601 format (e.g., \"2024-11-22T10:35:00.000Z\").",
					"       *",
					"       * @example",
					"       * const timestamp = getTimestampNow();",
					"       * console.log(timestamp); ",
					"       * // Output: \"2024-11-22T10:35:00.000Z\"",
					"       */",
					"    getTimestampNow: function () {",
					"        return new Date(new Date(Date.now())).toISOString();",
					"    },",
					"",
					"    /**",
					"     * Normalize UTC timezone from +00:00 to Z",
					"     * @param {string} dateStr - Date string to normalize",
					"     * @returns {string} - Normalized date string",
					"     * ",
					"     * @example",
					"     * utils.normalizeUTC(\"2025-10-29T10:30:00+00:00\") // \"2025-10-29T10:30:00Z\"",
					"     * utils.normalizeUTC(\"2025-10-29T10:30:00Z\") // \"2025-10-29T10:30:00Z\" (unchanged)",
					"     */",
					"    normalizeUTC: function (dateStr) {",
					"        return dateStr ? dateStr.replace(/\\+00:00$/, \"Z\") : dateStr;",
					"    },",
					"",
					"    /**",
					"     * Saves data to a PostgreSQL table via Hasura API endpoints.",
					"     * ",
					"     * This function sends a POST request to insert data into the specified PostgreSQL table",
					"     * in a multi-database setup. It uses the 'Prefer: return=representation' header to get ",
					"     * the created record back in the response. Designed for use in Postman pre-request ",
					"     * scripts to populate test data during test execution.",
					"     *",
					"     * @param {Object} data - The data object to be inserted into the table. Must be a valid JavaScript object that can be JSON serialized.",
					"     * @param {string} database - The database name (e.g., 'DB_EVENT_HISTORY', 'DB_RAW_HISTORY').",
					"     * @param {string} table - The name of the table where the data will be inserted. Must match an existing table name in the database schema.",
					"     * @returns {Object} Returns the pm.sendRequest promise for chaining or error handling.",
					"     *",
					"     * @example",
					"     * // Save to event history database",
					"     * const pacs008message = prep.prepPacs008Msg(...);",
					"     * await utils.saveData(pacs008message, DB_RAW_HISTORY, DB_RAW_HISTORY_PACS008)",
					"     *   .then(response => console.log('Success:', response.json()))",
					"     *   .catch(error => console.error('Failed:', error));",
					"     * ",
					"     * @example",
					"     * // Save to raw history database",
					"     * const accountData = prep.prepAccount('tenant-001', 'acct_987654321IBAN');",
					"     * await utils.saveData(accountData, DB_EVENT_HISTORY, DB_EVENT_HISTORY_ACCOUNT);",
					"     */",
					"    saveData: function (data, database, table) {",
					"",
					"        if (LOGLEVEL === \"DEBUG\") {",
					"            console.log('Database:', database);",
					"            console.log('Table:', table);",
					"            console.log('Data:', JSON.stringify(data));",
					"        }",
					"",
					"        // Wrap single objects in array for Hasura",
					"        const dataArray = Array.isArray(data) ? data : [data];",
					"",
					"        // Build GraphQL mutation",
					"        const graphqlMutation = `",
					"        mutation InsertData($objects: [${table}_insert_input!]!) {",
					"            insert_${table}(objects: $objects) {",
					"                affected_rows",
					"            }",
					"        }",
					"    `;",
					"",
					"        const postRequest = {",
					"            url: POSTGRES_API_URL,",
					"            method: 'POST',",
					"            header: {",
					"                'Content-Type': 'application/json',",
					"                'x-hasura-role': 'anonymous'",
					"            },",
					"            body: {",
					"                mode: 'raw',",
					"                raw: JSON.stringify({",
					"                    query: graphqlMutation,",
					"                    variables: {",
					"                        objects: dataArray",
					"                    }",
					"                })",
					"            }",
					"        };",
					"",
					"        if (LOGLEVEL === \"DEBUG\") {",
					"            console.log('GraphQL Query:', graphqlMutation);",
					"            console.log('Request body:', postRequest.body.raw);",
					"        }",
					"",
					"        return new Promise((resolve, reject) => {",
					"            _pm.sendRequest(postRequest, (error, response) => {",
					"                if (error) {",
					"                    console.error('Request ERROR:', JSON.stringify(error, null, 2));",
					"                    reject(error);",
					"                } else {",
					"                    if (LOGLEVEL === \"DEBUG\") {",
					"                        console.log('Response code:', response.code);",
					"                        console.log('Response body:', response.text());",
					"                    }",
					"",
					"                    if (response.code >= 400) {",
					"                        console.error('HTTP Error:', response.code);",
					"                        reject(new Error(`HTTP ${response.code}: ${response.text()}`));",
					"                    } else {",
					"                        const body = response.json();",
					"                        if (body.errors) {",
					"                            console.error('GraphQL Errors:', JSON.stringify(body.errors, null, 2));",
					"                            reject(new Error(JSON.stringify(body.errors)));",
					"                        } else {",
					"                            if (LOGLEVEL === 'DEBUG') {",
					"                                console.log('Records created:', JSON.stringify(body.data, null, 2));",
					"                            }",
					"                            resolve(response);",
					"                        }",
					"                    }",
					"                }",
					"            });",
					"        });",
					"    },",
					"",
					"    /**",
					"     * Get field list for a table from GraphQL schema",
					"     * @param {string} tableName - The table name to introspect",
					"     * @returns {Promise<Array>} - Resolves with array of field names",
					"     * ",
					"     * @example",
					"     * // Using async/await",
					"     * const fields = await utils.getTableFields(\"pacs008\");",
					"     * console.log('Fields:', fields); // ['creditoraccountid', 'credttm', 'debtoraccountid', ...]",
					"     * ",
					"     * @example",
					"     * // Using Promise chain",
					"     * utils.getTableFields(\"pacs008\").then(fields => {",
					"     *     console.log('Fields:', fields);",
					"     *     console.log('As JSON:', JSON.stringify(fields));",
					"     * });",
					"     * ",
					"     * @example",
					"     * // Error handling",
					"     * utils.getTableFields(\"pacs008\")",
					"     *     .then(fields => console.log('Success:', fields))",
					"     *     .catch(error => console.error('Failed:', error));",
					"     */",
					"    getTableFields: function (tableName) {",
					"        const introspectionQuery = {",
					"            query: `query IntrospectionQuery($typeName: String!) { __type(name: $typeName) { name fields { name type { name kind ofType { name kind }}}}}`,",
					"            variables: {",
					"                typeName: tableName",
					"            }",
					"        };",
					"",
					"        // Make the introspection request",
					"        const introspectionRequest = {",
					"            url: POSTGRES_API_URL,",
					"            method: 'POST',",
					"            header: [",
					"                { key: 'Content-Type', value: 'application/json' },",
					"                { key: 'x-hasura-admin-secret', value: POSTGRES_API_SECRET }",
					"            ],",
					"            body: {",
					"                mode: 'raw',",
					"                raw: JSON.stringify(introspectionQuery),",
					"                options: {",
					"                    raw: {",
					"                        language: 'json'",
					"                    }",
					"                }",
					"            }",
					"        };",
					"",
					"        return new Promise((resolve, reject) => {",
					"            _pm.sendRequest(introspectionRequest, (err, response) => {",
					"                if (err) {",
					"                    console.error('Error fetching schema:', err);",
					"                    reject(err);",
					"                    return;",
					"                }",
					"",
					"                const result = response.json();",
					"",
					"                if (result.errors) {",
					"                    const error = new Error('GraphQL errors: ' + JSON.stringify(result.errors));",
					"                    console.error(error.message);",
					"                    reject(error);",
					"                    return;",
					"                }",
					"",
					"                if (!result.data || !result.data.__type) {",
					"                    const error = new Error(`Table \"${tableName}\" not found in schema`);",
					"                    console.error(error.message);",
					"                    reject(error);",
					"                    return;",
					"                }",
					"",
					"                const fields = result.data.__type.fields;",
					"",
					"                // Filter to only scalar fields (exclude objects/arrays)",
					"                const scalarFields = fields.filter(field => {",
					"                    const fieldType = field.type.kind === 'NON_NULL' ? field.type.ofType : field.type;",
					"                    return fieldType.kind === 'SCALAR' || fieldType.kind === 'ENUM';",
					"                });",
					"",
					"                // Extract field names",
					"                const fieldNames = scalarFields.map(f => f.name);",
					"",
					"                resolve(fieldNames);",
					"            });",
					"        });",
					"    },",
					"",
					"    /**",
					"     * Extract data array from Hasura query response",
					"     * @param {Object} response - The Hasura GraphQL response object",
					"     * @param {string} tableName - Table name to extract specific table data",
					"     * @returns {Array} - Returns the table array",
					"     * ",
					"     * @example",
					"     * // Extract specific table's array",
					"     * const data = utils.extractData(response, 'pacs008');",
					"     * // Returns: [{ creditoraccountid: \"...\", ... }]",
					"     */",
					"    extractData: function (response, tableName) {",
					"        return response.data[tableName];",
					"    },",
					"",
					"    /**",
					"       * Creates one or more new accounts for a given entity and updates the database with the new account(s) and their relationship to the entity.",
					"       *",
					"       * @param {number|null|undefined} [numberOfAccounts=0] - The number of new accounts to create. Defaults to 0.",
					"       * @param {string} tenantId - Mandatory. Reference identifier for the tenant.",
					"       * @param {string} entityKey - Mandatory. Identifier for the entity to which the account will be associated.",
					"       * @param {string|null|undefined} [accountKey] - Optional. Identifier(s) for the new account(s). If omitted or null, a unique account identifier will be generated for each account.",
					"       * @param {string|null|undefined} timestamp - Timestamp for the creation of the account. Defaults to the current timestamp.",
					"       */",
					"    createAccounts: async function (numberOfAccounts, tenantId, entityKey, accountKey, timestamp) {",
					"",
					"        if (LOGLEVEL === \"DEBUG\") {",
					"            logStatement = {",
					"                \"numberOfAccounts\": `${numberOfAccounts}`,",
					"                \"tenantId\": `${tenantId}`,",
					"                \"entityKey\": `${entityKey}`,",
					"                \"accountKey\": `${accountKey}`,",
					"                \"timestamp\": `${timestamp}`",
					"            }",
					"            console.log(`Message creation parameters:`);",
					"            console.log(JSON.stringify(logStatement, null, 2));",
					"        }",
					"",
					"        // Essential defaults",
					"        numberOfAccounts = numberOfAccounts ?? 1;",
					"        timestamp = timestamp ?? new Date(new Date(Date.now())).toISOString();",
					"",
					"        accountKeys = [];",
					"        accounts = [];",
					"        account_holders = [];",
					"",
					"        if (accountKey === null || accountKey === undefined) {",
					"            for (let step = 0; step < numberOfAccounts; step++) {",
					"                genAccountKey = `acct_${uuid.v4().replace(/-/g, '')}${DEBTOR_ACCOUNT_TYPE}`;",
					"                accounts.push(prep.prepAccount(tenantId, genAccountKey));",
					"                account_holders.push(prep.prepAccountHolder(tenantId, entityKey, genAccountKey, timestamp));",
					"            }",
					"        } else {",
					"            accounts.push(prep.prepAccount(tenantId, accountKey));",
					"            account_holders.push(prep.prepAccountHolder(tenantId, entityKey, accountKey, timestamp));",
					"        }",
					"",
					"        if (LOGLEVEL === 'DEBUG') {",
					"            console.log(`Creating ${numberOfAccounts} account(s) for entity ${entityKey} under tenant ${tenantId}.`);",
					"            console.log('Accounts to be created:', JSON.stringify(accounts, null, 2));",
					"            console.log('Account holder relationships to be created:', JSON.stringify(account_holders, null, 2));",
					"        }",
					"",
					"        try {",
					"            for (const account of accounts) {",
					"                await utils.saveData(account, DB_EVENT_HISTORY, DB_EVENT_HISTORY_ACCOUNT);",
					"                if ((LOGLEVEL === 'DEBUG') || (LOGLEVEL === 'INFO')) {",
					"                    console.log('Account created:', account.id);",
					"                }",
					"            }",
					"",
					"            for (const account_holder of account_holders) {",
					"                await utils.saveData(account_holder, DB_EVENT_HISTORY, DB_EVENT_HISTORY_ACCOUNT_HOLDER);",
					"                if ((LOGLEVEL === 'DEBUG') || (LOGLEVEL === 'INFO')) {",
					"                    console.log('Account holder relationship created:', account_holder.source, '->', account_holder.destination);",
					"                }",
					"            }",
					"        } catch (error) {",
					"            console.error('Failed to create accounts/account_holders:', error);",
					"            throw error;",
					"        }",
					"    },",
					"",
					"    /**",
					"       * Creates a new entity in the graph database with the given entity identifier.",
					"       *",
					"       * @param {string} tenantId - Mandatory. Identifier for the tenant.",
					"       * @param {string} entityKey - Mandatory. Identifier for the new entity.",
					"       */",
					"    createEntity: async function (tenantId, entityKey) {",
					"",
					"        // Essential defaults",
					"        const timestamp = new Date(new Date(Date.now())).toISOString();",
					"        const entity = prep.prepEntity(tenantId, entityKey, timestamp);",
					"",
					"        try {",
					"            await utils.saveData(entity, DB_EVENT_HISTORY, DB_EVENT_HISTORY_ENTITY);",
					"            if ((LOGLEVEL === 'DEBUG') || (LOGLEVEL === 'INFO')) {",
					"                console.log('Entity created:', entity.id);",
					"            }",
					"        } catch (error) {",
					"            console.error('Failed to create entity:', error);",
					"            throw error;",
					"        }",
					"",
					"    },",
					"",
					"    /**",
					"       * Appends the supplied tenantId to the object as object.tenantId.",
					"       *",
					"       * This function adds the supplied tenantId string to the supplied object and returns it. ",
					"       * If the tenantId is not supplied, the default tenantId will be added instead. ",
					"       *",
					"       * @returns {object} The updated object.",
					"       *",
					"       * @example",
					"       * const messageSet = createTransactionSetInMemory();",
					"       * let pacs002WithTenantId = addTenantId(\"tenant-001\", messageSet[1]); ",
					"       * // Output:",
					"       * // {",
					"       * //   \"TenantId\": \"tenant-001\",",
					"       * //   \"TxTp\": \"pacs.002.001.12\",",
					"       * //   ...,",
					"       * // }",
					"       */",
					"    addTenantId: function (tenantId, obj) {",
					"        tenantId = tenantId ? tenantId : TENANT_DEFAULT;",
					"        obj.TenantId = tenantId;",
					"        return obj;",
					"    },",
					"",
					"    /**",
					"     * Generates composite keys for debtor and creditor entities and accounts.",
					"     * ",
					"     * This function creates unique identifier keys by concatenating entity/account IDs ",
					"     * with their corresponding type identifiers. These composite keys are used throughout ",
					"     * the system to uniquely identify entities and accounts across different message types ",
					"     * and database operations.",
					"     *",
					"     * @param {string} debtorId - The debtor's entity identifier.",
					"     * @param {string} debtorAccountId - The debtor's account identifier.",
					"     * @param {string} debtorAgentId - The debtor's financial institution identifier.",
					"     * @param {string} creditorId - The creditor's entity identifier.",
					"     * @param {string} creditorAccountId - The creditor's account identifier.",
					"     * @param {string} creditorAgentId - The creditor's financial institution identifier.",
					"     * ",
					"     * @returns {Object} An object containing composite keys for all parties:",
					"     * @returns {string} returns.debtorId - Composite key: debtorId + DEBTOR_ID_TYPE",
					"     * @returns {string} returns.debtorAccountId - Composite key: debtorAccountId + DEBTOR_ACCOUNT_TYPE + debtorAgentId",
					"     * @returns {string} returns.creditorId - Composite key: creditorId + CREDITOR_ID_TYPE",
					"     * @returns {string} returns.creditorAccountId - Composite key: creditorAccountId + CREDITOR_ACCOUNT_TYPE + creditorAgentId",
					"     * ",
					"     * @example",
					"     * const keys = utils.getKeys(",
					"     *   'dbtr_123', ",
					"     *   'dbtrAcct_456', ",
					"     *   'fsp001',",
					"     *   'cdtr_789', ",
					"     *   'cdtrAcct_012', ",
					"     *   'fsp002'",
					"     * );",
					"     * // Returns:",
					"     * // {",
					"     * //   debtorId: 'dbtr_123TAZAMA_EID',",
					"     * //   debtorAccountId: 'dbtrAcct_456MSISDNfsp001',",
					"     * //   creditorId: 'cdtr_789TAZAMA_EID',",
					"     * //   creditorAccountId: 'cdtrAcct_012MSISDNfsp002'",
					"     * // }",
					"     */",
					"    getKeys: function (debtorId, debtorAccountId, debtorAgentId, creditorId, creditorAccountId, creditorAgentId) {",
					"",
					"        let keys = {",
					"            debtorKey: `${debtorId}${DEBTOR_ID_TYPE}`,",
					"            debtorAccountKey: `${debtorAccountId}${DEBTOR_ACCOUNT_TYPE}${debtorAgentId}`,",
					"            creditorKey: `${creditorId}${CREDITOR_ID_TYPE}`,",
					"            creditorAccountKey: `${creditorAccountId}${CREDITOR_ACCOUNT_TYPE}${creditorAgentId}`",
					"        }",
					"",
					"        if (LOGLEVEL === 'DEBUG') {",
					"            console.log(\"Generated composite keys:\", JSON.stringify(keys, null, 2));",
					"        }",
					"",
					"        return (keys)",
					"    },",
					"",
					"    /**",
					"       * Creates a new set of transactions for testing purposes, including all necessary data, and stores it in memory so that the transactions can be submitted to the API in sequence as valid messages.",
					"       * The transaction set will always contain a pacs.008 and a pacs.002 message.",
					"       * The messages in the set will be linked through the same EndToEndId.",
					"       * The function stashes created data in global variables can be retrieved with the `pm.globals.get()` method.",
					"       *",
					"       * @param {string|null|undefined} [tenantId=null] - Reference identifier for the tenant. Defaults to DEFAULT. The tenantId is not appended to the object.",
					"       * @param {boolean|null|undefined} [activePain001=false] - Determines if quoting is enabled in the deployment. Defaults to false.",
					"       * @param {number|null|undefined} [timestampEpoch=0] - Epoch timestamp for adjusting transaction timestamps. Defaults to 0.",
					"       * @param {number|null|undefined} [timestampInterval=300000] - The default interval between consecutive message timestamps. Defaults to 300000 (5 minutes).",
					"       * @param {string|null|undefined} [debtorId=null] - Reference identifier for the debtor. If provided, this ID will be used. Defaults to null, which means a new ID will be generated.",
					"       * @param {string|null|undefined} [debtorAccountId=null] - Reference account identifier for the debtor. If provided, this ID will be used. Defaults to null, which means a new ID will be generated.",
					"       * @param {string|null|undefined} [debtorAgentId=null] - Identifier for the debtor's agent. If provided, this ID will be used. Defaults to 'fsp001'.",
					"       * @param {string|null|undefined} [creditorId=null] - Reference identifier for the creditor. If provided, this ID will be used. Defaults to null, which means a new ID will be generated.",
					"       * @param {string|null|undefined} [creditorAccountId=null] - Reference account identifier for the creditor. If provided, this ID will be used. Defaults to null, which means a new ID will be generated.",
					"       * @param {string|null|undefined} [creditorAgentId=null] - Identifier for the creditor's agent. If provided, this ID will be used. Defaults to 'fsp002'.",
					"       * @param {string|null|undefined} [instructedCurrency='XTS'] - Currency code for the transaction amount. Defaults to 'XTS'.",
					"       * @param {number|null|undefined} [instructedAmount] - Transaction amount. Defaults to a random value between 10 and 1000.",
					"       * @param {string|null|undefined} [interbankSettlementCurrency='XTS'] - Currency code for the transaction amount that the creditor will receive. Defaults to instructedCurrency.",
					"       * @param {number|null|undefined} [interbankSettlementAmount] - Transaction amount that the creditor will receive. Defaults to instructedAmount.",
					"       * @param {string|null|undefined} [exchangeRateCurrency='XTS'] - Currency code for the exchange rate. Defaults to instructedCurrency.",
					"       * @param {number|null|undefined} [exchangeRate] - Echange rate to convert instructedAmount to interbankSettlementAmount. Defaults to 1.0.",
					"       * @param {string|null|undefined} [transactionDescription='Generic payment description'] - Description of the transaction. Defaults to 'Generic payment description'.",
					"       * @param {string|null|undefined} [pacs002Sts='ACCC'] - Transaction status for pacs.002.001.12 message. Defaults to 'ACCC' (a successful transaction).",
					"       * @param {number|null|undefined} [debtorAge=25] - Age of the debtor. Defaults to 25.",
					"       * @param {string|null|undefined} [transactionPurpose] - Purpose of the transaction. Defaults to 'TRANSFER' if pain.001/013 ingestion is enabled, otherwise 'MP2P'.",
					"       * @param {number|null|undefined} [transactionLat=-3.1609] - Latitude coordinate of the transaction location. Defaults to -3.1609.",
					"       * @param {number|null|undefined} [transactionLong=38.3588] - Longitude coordinate of the transaction location. Defaults to 38.3588.",
					"       */",
					"    createTransactionSetInMemory: function (tenantId, activePain001, timestampEpoch, timestampInterval, debtorId, debtorAccountId, debtorAgentId, creditorId, creditorAccountId, creditorAgentId, instructedCurrency, instructedAmount, interbankSettlementCurrency, interbankSettlementAmount, exchangeRateCurrency, exchangeRate, transactionDescription, pacs002Sts, debtorAge, transactionPurpose, transactionLat, transactionLong) {",
					"",
					"        if (LOGLEVEL === 'DEBUG') {",
					"            logStatement = {",
					"                \"tenantId\": `${tenantId}`,",
					"                \"activePain001\": `${activePain001}`,",
					"                \"timestampEpoch\": `${timestampEpoch}`,",
					"                \"timestampInterval\": `${timestampInterval}`,",
					"                \"debtorId\": `${debtorId}`,",
					"                \"debtorAccountId\": `${debtorAccountId}`,",
					"                \"debtorAgentId\": `${debtorAgentId}`,",
					"                \"creditorId\": `${creditorId}`,",
					"                \"creditorAccountId\": `${creditorAccountId}`,",
					"                \"creditorAgentId\": `${creditorAgentId}`,",
					"                \"instructedCurrency\": `${instructedCurrency}`,",
					"                \"instructedAmount\": `${instructedAmount}`,",
					"                \"interbankSettlementCurrency\": `${interbankSettlementCurrency}`,",
					"                \"interbankSettlementAmount\": `${interbankSettlementAmount}`,",
					"                \"exchangeRateCurrency\": `${exchangeRateCurrency}`,",
					"                \"exchangeRate\": `${exchangeRate}`,",
					"                \"transactionDescription\": `${transactionDescription}`,",
					"                \"pacs002Sts\": `${pacs002Sts}`,",
					"                \"debtorAge\": `${debtorAge}`,",
					"                \"transactionPurpose\": `${transactionPurpose}`,",
					"                \"transactionLat\": `${transactionLat}`,",
					"                \"transactionLong\": `${transactionLong}`",
					"            }",
					"            console.log(`Input parameters at start:`);",
					"            console.log(JSON.stringify(logStatement, null, 2));",
					"        }",
					"",
					"        // Essential defaults",
					"        tenantId = tenantId ?? TENANT_DEFAULT;",
					"        if ((LOGLEVEL === 'DEBUG') || (LOGLEVEL === 'INFO')) {",
					"            console.log(`Tenant context is: ${tenantId}`)",
					"        }",
					"        activePain001 = activePain001 ?? false;",
					"        if ((LOGLEVEL === 'DEBUG') || (LOGLEVEL === 'INFO')) {",
					"            activePain001 ? console.log(\"pain.001/013 ingestion is enabled\") : console.log(\"pain.001/013 ingestion is disabled\");",
					"        }",
					"        timestampEpoch = timestampEpoch ?? 0;",
					"        timestampInterval = timestampInterval ?? 300000; // 300,000 milliseconds = 5 minutes",
					"",
					"        // Entities and accounts",
					"        debtorId = debtorId ?? 'dbtr_' + uuid.v4().replace(/-/g, '');",
					"        debtorAccountId = debtorAccountId ?? 'dbtrAcct_' + uuid.v4().replace(/-/g, '');",
					"        debtorAgentId = debtorAgentId ?? DEBTOR_AGENT_ID;",
					"        creditorId = creditorId ?? 'cdtr_' + uuid.v4().replace(/-/g, '');",
					"        creditorAccountId = creditorAccountId ?? 'cdtrAcct_' + uuid.v4().replace(/-/g, '');",
					"        creditorAgentId = creditorAgentId ?? CREDITOR_AGENT_ID;",
					"",
					"        // Amounts",
					"        instructedCurrency = instructedCurrency ?? 'XTS';",
					"        instructedAmount = instructedAmount ?? Math.round((Math.random() * (1000 - 10) + 10) * 100) / 100;",
					"        interbankSettlementCurrency = interbankSettlementCurrency ?? instructedCurrency;",
					"        interbankSettlementAmount = interbankSettlementAmount ?? instructedAmount;",
					"        exchangeRateCurrency = exchangeRateCurrency ?? instructedCurrency;",
					"        exchangeRate = exchangeRate ?? 1.0;",
					"",
					"        // Metadata",
					"        transactionDescription = transactionDescription ?? uuid.v4();",
					"        pacs002Sts = pacs002Sts ?? 'ACCC';",
					"        debtorAge = debtorAge ?? 25;",
					"        if (activePain001) {",
					"            transactionPurpose = transactionPurpose ?? 'TRANSFER' // or 'WITHDRAWAL', or 'PAYMENT'",
					"        } else {",
					"            transactionPurpose = transactionPurpose ?? 'MP2P' // or 'MP2B', or 'CASH'",
					"        }",
					"        transactionLat = transactionLat ?? -3.1609",
					"        transactionLong = transactionLong ?? 38.3588",
					"",
					"        // Transformations",
					"        const { debtorKey, debtorAccountKey, creditorKey, creditorAccountKey } = utils.getKeys(debtorId, debtorAccountId, debtorAgentId, creditorId, creditorAccountId, creditorAgentId);",
					"        let debtorDoB = new Date(new Date().setDate(new Date().getDate() - (debtorAge * 366))).toISOString().substring(0, 10);",
					"        let timestampPacs008 = new Date(new Date(Date.now() - timestampEpoch - timestampInterval * 1)).toISOString();",
					"        let timestampPacs002 = new Date(new Date(Date.now() - timestampEpoch - timestampInterval * 0)).toISOString();",
					"",
					"        if ((LOGLEVEL === 'DEBUG') || (LOGLEVEL === 'INFO')) {",
					"            console.log(\"pacs.002 payload timestamp: \" + timestampPacs002);",
					"        }",
					"",
					"        let endToEndId = uuid.v4().replace(/-/g, '');",
					"        let messageIdPacs008 = uuid.v4().replace(/-/g, '');",
					"        let messageIdPacs002 = uuid.v4().replace(/-/g, '');",
					"",
					"        var timestampPain001;",
					"        var timestampPain013;",
					"        var messageIdPain001;",
					"        var messageIdPain013;",
					"",
					"        var pain001;",
					"        var pain013;",
					"        var baseCreDtTm;",
					"        if (activePain001) {",
					"            messageIdPain001 = uuid.v4().replace(/-/g, '');",
					"            messageIdPain013 = uuid.v4().replace(/-/g, '');",
					"            timestampPain001 = new Date(new Date(Date.now() - timestampEpoch - timestampInterval * 3)).toISOString();",
					"            timestampPain013 = new Date(new Date(Date.now() - timestampEpoch - timestampInterval * 2)).toISOString();",
					"            baseCreDtTm = timestampPain001;",
					"        } else {",
					"            baseCreDtTm = timestampPacs008;",
					"        }",
					"",
					"        if (LOGLEVEL === 'DEBUG') {",
					"            logStatement = {",
					"                \"tenantId\": `${tenantId}`,",
					"                \"activePain001\": `${activePain001}`,",
					"                \"timestampEpoch\": `${timestampEpoch}`,",
					"                \"timestampInterval\": `${timestampInterval}`,",
					"                \"debtorId\": `${debtorId}`,",
					"                \"debtorKey\": `${debtorKey}`,",
					"                \"debtorAccountId\": `${debtorAccountId}`,",
					"                \"debtorAccountKey\": `${debtorAccountKey}`,",
					"                \"debtorAgentId\": `${debtorAgentId}`,",
					"                \"creditorId\": `${creditorId}`,",
					"                \"creditorKey\": `${creditorKey}`,",
					"                \"creditorAccountId\": `${creditorAccountId}`,",
					"                \"creditorAccountKey\": `${creditorAccountKey}`,",
					"                \"creditorAgentId\": `${creditorAgentId}`,",
					"                \"instructedCurrency\": `${instructedCurrency}`,",
					"                \"instructedAmount\": `${instructedAmount}`,",
					"                \"interbankSettlementCurrency\": `${interbankSettlementCurrency}`,",
					"                \"interbankSettlementAmount\": `${interbankSettlementAmount}`,",
					"                \"exchangeRateCurrency\": `${exchangeRateCurrency}`,",
					"                \"exchangeRate\": `${exchangeRate}`,",
					"                \"transactionDescription\": `${transactionDescription}`,",
					"                \"pacs002Sts\": `${pacs002Sts}`,",
					"                \"debtorAge\": `${debtorAge}`,",
					"                \"transactionPurpose\": `${transactionPurpose}`,",
					"                \"transactionLat\": `${transactionLat}`,",
					"                \"transactionLong\": `${transactionLong}`",
					"            }",
					"            console.log(`Input parameters at start:`);",
					"            console.log(JSON.stringify(logStatement, null, 2));",
					"        }",
					"",
					"        const dataCache = {",
					"            \"dbtrId\": `${debtorKey}`,",
					"            \"cdtrId\": `${creditorKey}`,",
					"            \"dbtrAcctId\": `${debtorAccountKey}`,",
					"            \"cdtrAcctId\": `${creditorAccountKey}`,",
					"            \"creDtTm\": `${baseCreDtTm}`,",
					"            \"instdAmt\": {",
					"                \"amt\": instructedAmount,",
					"                \"ccy\": `${instructedCurrency}`",
					"            },",
					"            \"intrBkSttlmAmt\": {",
					"                \"amt\": interbankSettlementAmount,",
					"                \"ccy\": `${interbankSettlementCurrency}`",
					"            },",
					"            \"xchgRate\": exchangeRate",
					"        };",
					"",
					"        var messageSet = {",
					"            \"pain001\": {},",
					"            \"pain013\": {},",
					"            \"pacs008\": {},",
					"            \"pacs002\": {}",
					"        }",
					"",
					"        if (activePain001) {",
					"            pain001 = [prep.prepPain001Msg(messageIdPain001, timestampPain001, debtorDoB, debtorId, DEBTOR_ID_TYPE, debtorAccountId, DEBTOR_ACCOUNT_TYPE, debtorAgentId, endToEndId, transactionPurpose, instructedCurrency, instructedAmount, interbankSettlementCurrency, interbankSettlementAmount, exchangeRateCurrency, exchangeRate, creditorId, CREDITOR_ID_TYPE, creditorAccountId, CREDITOR_ACCOUNT_TYPE, creditorAgentId, transactionDescription, transactionLat, transactionLong, dataCache)];",
					"            messageSet.pain001 = pain001[0];",
					"            pain013 = [prep.prepPain013Msg(messageIdPain013, timestampPain013, debtorDoB, debtorId, DEBTOR_ID_TYPE, debtorAccountId, DEBTOR_ACCOUNT_TYPE, debtorAgentId, endToEndId, instructedCurrency, instructedAmount, interbankSettlementCurrency, interbankSettlementAmount, creditorId, CREDITOR_ID_TYPE, creditorAccountId, CREDITOR_ACCOUNT_TYPE, creditorAgentId, transactionLat, transactionLong, dataCache)];",
					"            messageSet.pain013 = pain013[0];",
					"        }",
					"",
					"        const pacs008 = [prep.prepPacs008Msg(messageIdPacs008, timestampPacs008, endToEndId, instructedCurrency, instructedAmount, interbankSettlementCurrency, interbankSettlementAmount, exchangeRate, debtorDoB, debtorId, DEBTOR_ID_TYPE, debtorAccountId, DEBTOR_ACCOUNT_TYPE, debtorAgentId, creditorId, CREDITOR_ID_TYPE, creditorAccountId, CREDITOR_ACCOUNT_TYPE, creditorAgentId, transactionPurpose, transactionDescription, transactionLat, transactionLong, dataCache)];",
					"        const pacs002 = [prep.prepPacs002Msg(messageIdPacs002, timestampPacs002, endToEndId, pacs002Sts, debtorAgentId, creditorAgentId, dataCache)];",
					"",
					"        messageSet.pacs008 = pacs008[0];",
					"        messageSet.pacs002 = pacs002[0];",
					"",
					"        if ((LOGLEVEL === 'DEBUG') || (LOGLEVEL === 'INFO')) {",
					"            console.log('pacs.008 message: ' + JSON.stringify(pacs008[0]), null, 2);",
					"            console.log('pacs.002 trigger payload: ' + JSON.stringify(pacs002[0]), null, 2);",
					"        }",
					"",
					"        _pm.globals.set('tenantId', tenantId);",
					"        _pm.globals.set(\"pacs008\", JSON.stringify(pacs008[0]));",
					"        _pm.globals.set(\"pacs002\", JSON.stringify(pacs002[0]));",
					"        _pm.globals.set(\"dataCache\", JSON.stringify(dataCache));",
					"        _pm.globals.set('debtorId', debtorId);",
					"        _pm.globals.set('debtorAccountId', debtorAccountId);",
					"        _pm.globals.set('debtorAgentId', debtorAgentId);",
					"        _pm.globals.set('debtorDoB', debtorDoB);",
					"        _pm.globals.set('creditorId', creditorId);",
					"        _pm.globals.set('creditorAccountId', creditorAccountId);",
					"        _pm.globals.set('creditorAgentId', creditorAgentId);",
					"        _pm.globals.set('timestampPacs008', timestampPacs008);",
					"        _pm.globals.set('timestampPacs002', timestampPacs002);",
					"        _pm.globals.set('endToEndId', endToEndId);",
					"        _pm.globals.set('pacs002Sts', pacs002Sts);",
					"        _pm.globals.set('instructedCurrency', instructedCurrency);",
					"        _pm.globals.set('instructedAmount', instructedAmount);",
					"        _pm.globals.set('interbankSettlementCurrency', interbankSettlementCurrency);",
					"        _pm.globals.set('interbankSettlementAmount', interbankSettlementAmount);",
					"        _pm.globals.set('exchangeRateCurrency', exchangeRateCurrency);",
					"        _pm.globals.set('exchangeRate', exchangeRate);",
					"        _pm.globals.set('transactionDescription', transactionDescription);",
					"        _pm.globals.set('transactionPurpose', transactionPurpose);",
					"        _pm.globals.set('transactionLat', transactionLat);",
					"        _pm.globals.set('transactionLong', transactionLong);",
					"        _pm.globals.set('messageIdPacs008', messageIdPacs008);",
					"        _pm.globals.set('messageIdPacs002', messageIdPacs002);",
					"        _pm.globals.set('baseTimestamp', timestampPacs008);",
					"        _pm.globals.set('debtorKey', debtorKey);",
					"        _pm.globals.set('debtorAccountKey', debtorAccountKey);",
					"        _pm.globals.set('creditorKey', creditorKey);",
					"        _pm.globals.set('creditorAccountKey', creditorAccountKey);",
					"        if (activePain001) {",
					"            _pm.globals.set(\"pain001\", JSON.stringify(pain001[0]));",
					"            _pm.globals.set(\"pain013\", JSON.stringify(pain013[0]));",
					"            _pm.globals.set('timestampPain001', timestampPain001);",
					"            _pm.globals.set('timestampPain013', timestampPain013);",
					"            _pm.globals.set('messageIdPain001', messageIdPain001);",
					"            _pm.globals.set('messageIdPain013', messageIdPain013);",
					"            _pm.globals.set('baseTimestamp', timestampPain001);",
					"        }",
					"",
					"        if ((LOGLEVEL === 'DEBUG') || (LOGLEVEL === 'INFO')) {",
					"            if (activePain001) {",
					"                logStatement = {",
					"                    \"pain001\": `${messageIdPain001} at ${timestampPain001}`,",
					"                    \"pain013\": `${messageIdPain013} at ${timestampPain013}`,",
					"                    \"pacs008\": `${messageIdPacs008} at ${timestampPacs008}`,",
					"                    \"pacs002\": `${messageIdPacs002} at ${timestampPacs002}`",
					"                }",
					"                console.log(`Message IDs:`);",
					"                console.log(JSON.stringify(logStatement, null, 2));",
					"            } else {",
					"                logStatement = {",
					"                    \"pain001\": `disabled`,",
					"                    \"pain013\": `disabled`,",
					"                    \"pacs008\": `${messageIdPacs008} at ${timestampPacs008}`,",
					"                    \"pacs002\": `${messageIdPacs002} at ${timestampPacs002}`",
					"                }",
					"                console.log(`Message IDs:`);",
					"                console.log(JSON.stringify(logStatement, null, 2));",
					"            }",
					"            utils.logDataCache(dataCache);",
					"        }",
					"",
					"        return (messageSet);",
					"    },",
					"",
					"    /**",
					"       * Creates a new set of transactions for testing purposes, including all necessary database operations, as if the transactions had been submitted to the TMS API are waiting to be sent to the Event Director. The function stores the pacs.002 message and DataCache object in Postman global environment variables so that the payload for a specific processor can be composed as required to test the function of that processor via a direct POST using the Nats-Utilities program.",
					"       * The transaction set will always contain a pacs.008 and a pacs.002 message.",
					"       * The messages in the set will be linked through the same EndToEndId.",
					"       * The function stashes created data in global variables can be retrieved with the `pm.globals.get()` method.",
					"       *",
					"       * @param {string|null|undefined} [tenantId=null] - Reference identifier for the tenant. Defaults to DEFAULT. The tenantId is appended to the object.",
					"       * @param {number|null|undefined} [numberOfSets=1] - The number of transaction sets to create. Defaults to 1.",
					"       * @param {boolean|null|undefined} [activePain001=false] - Determines if quoting is enabled in the deployment. Defaults to false.",
					"       * @param {number|null|undefined} [timestampEpoch=0] - Epoch timestamp for adjusting transaction timestamps. Defaults to 0.",
					"       * @param {number|null|undefined} [timestampInterval=300000] - The default interval between consecutive message timestamps. Defaults to 300000 (5 minutes).",
					"       * @param {number|null|undefined} [timestampIterationLeap=timestampEpoch/numberOfSets] - the elapsed time between multiple messages.",
					"       * @param {string|null|undefined} [debtorId=null] - Reference identifier for the debtor. If provided, this ID will be used. Defaults to null, which means a new ID will be generated.",
					"       * @param {string|null|undefined} [debtorAccountId=null] - Reference account identifier for the debtor. If provided, this ID will be used. Defaults to null, which means a new ID will be generated.",
					"       * @param {string|null|undefined} [debtorAgentId=null] - Identifier for the debtor's agent. If provided, this ID will be used. Defaults to 'fsp001'.",
					"       * @param {string|null|undefined} [creditorId=null] - Reference identifier for the creditor. If provided, this ID will be used. Defaults to null, which means a new ID will be generated.",
					"       * @param {string|null|undefined} [creditorAccountId=null] - Reference account identifier for the creditor. If provided, this ID will be used. Defaults to null, which means a new ID will be generated.",
					"       * @param {string|null|undefined} [creditorAgentId=null] - Identifier for the creditor's agent. If provided, this ID will be used. Defaults to 'fsp002'.",
					"       * @param {string|null|undefined} [instructedCurrency='XTS'] - Currency code for the transaction amount. Defaults to 'XTS'.",
					"       * @param {number|null|undefined} [instructedAmount] - Transaction amount. Defaults to a random value between 10 and 1000.",
					"       * @param {string|null|undefined} [interbankSettlementCurrency='XTS'] - Currency code for the transaction amount that the creditor will receive. Defaults to instructedCurrency.",
					"       * @param {number|null|undefined} [interbankSettlementAmount] - Transaction amount that the creditor will receive. Defaults to instructedAmount.",
					"       * @param {string|null|undefined} [exchangeRateCurrency='XTS'] - Currency code for the exchange rate. Defaults to instructedCurrency.",
					"       * @param {number|null|undefined} [exchangeRate] - Echange rate to convert instructedAmount to interbankSettlementAmount. Defaults to 1.0.",
					"       * @param {string|null|undefined} [transactionDescription='Generic payment description'] - Description of the transaction. Defaults to 'Generic payment description'.",
					"       * @param {string|null|undefined} [pacs002Sts='ACCC'] - Transaction status for pacs.002.001.12 message. Defaults to 'ACCC' (a successful transaction).",
					"       * @param {number|null|undefined} [debtorAge=25] - Age of the debtor. Defaults to 25.",
					"       * @param {string|null|undefined} [transactionPurpose] - Purpose of the transaction. Defaults to 'TRANSFER' if pain.001/013 ingestion is enabled, otherwise 'MP2P'.",
					"       * @param {number|null|undefined} [transactionLat=-3.1609] - Latitude coordinate of the transaction location. Defaults to -3.1609.",
					"       * @param {number|null|undefined} [transactionLong=38.3588] - Longitude coordinate of the transaction location. Defaults to 38.3588.",
					"       */",
					"    createTransactionSetsInDatabase: async function (tenantId, numberOfSets, activePain001, timestampEpoch, timestampInterval, timestampIterationLeap, forceCreateDBObjects, debtorId, debtorAccountId, debtorAgentId, creditorId, creditorAccountId, creditorAgentId, instructedCurrency, instructedAmount, interbankSettlementCurrency, interbankSettlementAmount, exchangeRateCurrency, exchangeRate, transactionDescription, pacs002Sts, debtorAge, transactionPurpose, transactionLat, transactionLong) {",
					"",
					"        if (LOGLEVEL === 'DEBUG') {",
					"            logStatement = {",
					"                \"tenantId\": `${tenantId}`,",
					"                \"numberOfSets\": `${numberOfSets}`,",
					"                \"activePain001\": `${activePain001}`,",
					"                \"timestampEpoch\": `${timestampEpoch}`,",
					"                \"timestampInterval\": `${timestampInterval}`,",
					"                \"timestampIterationLeap\": `${timestampIterationLeap}`,",
					"                \"forceCreateDBObjects\": `${forceCreateDBObjects}`,",
					"                \"debtorId\": `${debtorId}`,",
					"                \"debtorAccountId\": `${debtorAccountId}`,",
					"                \"debtorAgentId\": `${debtorAgentId}`,",
					"                \"creditorId\": `${creditorId}`,",
					"                \"creditorAccountId\": `${creditorAccountId}`,",
					"                \"creditorAgentId\": `${creditorAgentId}`,",
					"                \"instructedCurrency\": `${instructedCurrency}`,",
					"                \"instructedAmount\": `${instructedAmount}`,",
					"                \"interbankSettlementCurrency\": `${interbankSettlementCurrency}`,",
					"                \"interbankSettlementAmount\": `${interbankSettlementAmount}`,",
					"                \"exchangeRateCurrency\": `${exchangeRateCurrency}`,",
					"                \"exchangeRate\": `${exchangeRate}`,",
					"                \"transactionDescription\": `${transactionDescription}`,",
					"                \"pacs002Sts\": `${pacs002Sts}`,",
					"                \"debtorAge\": `${debtorAge}`,",
					"                \"transactionPurpose\": `${transactionPurpose}`,",
					"                \"transactionLat\": `${transactionLat}`,",
					"                \"transactionLong\": `${transactionLong}`",
					"            }",
					"            console.log(`Input parameters at start:`);",
					"            console.log(JSON.stringify(logStatement, null, 2));",
					"        }",
					"",
					"        // Essential defaults",
					"        tenantId = tenantId ?? TENANT_DEFAULT;",
					"        if ((LOGLEVEL === 'DEBUG') || (LOGLEVEL === 'INFO')) {",
					"            console.log(`Tenant context is: ${tenantId}`)",
					"        }",
					"        numberOfSets = numberOfSets ?? 1;",
					"        activePain001 = activePain001 ?? false;",
					"        if ((LOGLEVEL === 'DEBUG') || (LOGLEVEL === 'INFO')) {",
					"            activePain001 ? console.log(\"pain.001/013 ingestion is enabled\") : console.log(\"pain.001/013 ingestion is disabled\");",
					"        }",
					"        timestampEpoch = timestampEpoch ?? 0;",
					"        timestampInterval = timestampInterval ?? 300000; // 300,000 milliseconds = 5 minutes",
					"        // Time parameters",
					"        if (numberOfSets == 1) {",
					"            timestampIterationLeap = 0  // no off-set between transactions required if we're only producing a single transaction",
					"        } else {",
					"            // If ",
					"            timestampIterationLeap = timestampIterationLeap ?? Math.trunc(timestampEpoch / numberOfSets)",
					"        }",
					"        forceCreateDBObjects = forceCreateDBObjects ?? false;",
					"        debtorAgentId = debtorAgentId ?? DEBTOR_AGENT_ID;",
					"        creditorAgentId = creditorAgentId ?? CREDITOR_AGENT_ID;",
					"",
					"        // Metadata",
					"        transactionDescription = transactionDescription ?? uuid.v4();",
					"        pacs002Sts = pacs002Sts ?? 'ACCC';",
					"        debtorAge = debtorAge ?? 25;",
					"        if (activePain001) {",
					"            transactionPurpose = transactionPurpose ?? 'TRANSFER' // or 'WITHDRAWAL', or 'PAYMENT'",
					"        } else {",
					"            transactionPurpose = transactionPurpose ?? 'MP2P' // or 'MP2B', or 'CASH'",
					"        }",
					"        transactionLat = transactionLat ?? -3.1609",
					"        transactionLong = transactionLong ?? 38.3588",
					"",
					"        // Transformations",
					"",
					"        let debtorDoB = new Date(new Date().setDate(new Date().getDate() - (debtorAge * 366))).toISOString().substring(0, 10);",
					"",
					"        var messageSets = [];",
					"        var messageSet = {",
					"            \"pain001\": {},",
					"            \"pain013\": {},",
					"            \"pacs008\": {},",
					"            \"pacs002\": {}",
					"        }",
					"",
					"        if (LOGLEVEL === 'DEBUG') {",
					"            logStatement = {",
					"                \"tenantId\": `${tenantId}`,",
					"                \"numberOfSets\": `${numberOfSets}`,",
					"                \"activePain001\": `${activePain001}`,",
					"                \"timestampEpoch\": `${timestampEpoch}`,",
					"                \"timestampInterval\": `${timestampInterval}`,",
					"                \"timestampIterationLeap\": `${timestampIterationLeap}`,",
					"                \"forceCreateDBObjects\": `${forceCreateDBObjects}`,",
					"                \"debtorId\": `${debtorId}`,",
					"                \"debtorAccountId\": `${debtorAccountId}`,",
					"                \"debtorAgentId\": `${debtorAgentId}`,",
					"                \"creditorId\": `${creditorId}`,",
					"                \"creditorAccountId\": `${creditorAccountId}`,",
					"                \"creditorAgentId\": `${creditorAgentId}`,",
					"                \"instructedCurrency\": `${instructedCurrency}`,",
					"                \"instructedAmount\": `${instructedAmount}`,",
					"                \"interbankSettlementCurrency\": `${interbankSettlementCurrency}`,",
					"                \"interbankSettlementAmount\": `${interbankSettlementAmount}`,",
					"                \"exchangeRateCurrency\": `${exchangeRateCurrency}`,",
					"                \"exchangeRate\": `${exchangeRate}`,",
					"                \"transactionDescription\": `${transactionDescription}`,",
					"                \"pacs002Sts\": `${pacs002Sts}`,",
					"                \"debtorAge\": `${debtorAge}`,",
					"                \"transactionPurpose\": `${transactionPurpose}`,",
					"                \"transactionLat\": `${transactionLat}`,",
					"                \"transactionLong\": `${transactionLong}`",
					"            }",
					"            console.log(`Input parameters after defaults:`);",
					"            console.log(JSON.stringify(logStatement, null, 2))",
					"        }",
					"",
					"        for (let step = 0; step < numberOfSets; step++) {",
					"",
					"            // Amounts",
					"            let stepInstructedCurrency = instructedCurrency ?? 'XTS';",
					"            let stepInstructedAmount = instructedAmount ?? Math.round((Math.random() * (1000 - 10) + 10) * 100) / 100;",
					"            let stepInterbankSettlementCurrency = interbankSettlementCurrency ?? stepInstructedCurrency;",
					"            let stepInterbankSettlementAmount = interbankSettlementAmount ?? stepInstructedAmount;",
					"            let stepExchangeRateCurrency = exchangeRateCurrency ?? stepInstructedCurrency;",
					"            let stepExchangeRate = exchangeRate ?? 1.0;",
					"",
					"            // Entities and accounts",
					"",
					"            let stepDebtorId = debtorId ?? 'dbtr_' + uuid.v4().replace(/-/g, '');",
					"            let stepDebtorAccountId = debtorAccountId ?? 'dbtrAcct_' + uuid.v4().replace(/-/g, '');",
					"            let stepCreditorId = creditorId ?? 'cdtr_' + uuid.v4().replace(/-/g, '');",
					"            let stepCreditorAccountId = creditorAccountId ?? 'cdtrAcct_' + uuid.v4().replace(/-/g, '');",
					"",
					"            let { debtorKey, debtorAccountKey, creditorKey, creditorAccountKey } = utils.getKeys(stepDebtorId, stepDebtorAccountId, debtorAgentId, stepCreditorId, stepCreditorAccountId, creditorAgentId);",
					"",
					"            let timestampPacs008 = new Date(new Date(Date.now() - timestampEpoch + (timestampIterationLeap * step) - timestampInterval * 1)).toISOString();",
					"            let timestampPacs002 = new Date(new Date(Date.now() - timestampEpoch + (timestampIterationLeap * step) - timestampInterval * 0)).toISOString();",
					"            let endToEndId = uuid.v4().replace(/-/g, '');",
					"            let messageIdPacs008 = uuid.v4().replace(/-/g, '');",
					"            let messageIdPacs002 = uuid.v4().replace(/-/g, '');",
					"",
					"            if ((!debtorId) || (debtorId && forceCreateDBObjects && step == 0)) {",
					"                await utils.createEntity(tenantId, debtorKey);",
					"            }",
					"            if ((!creditorId) || (creditorId && forceCreateDBObjects && step == 0)) {",
					"                await utils.createEntity(tenantId, creditorKey);",
					"            }",
					"            if ((!debtorAccountId) || (debtorAccountId && forceCreateDBObjects && step == 0)) {",
					"                await utils.createAccounts(1, tenantId, debtorKey, debtorAccountKey, timestampPacs008);",
					"            }",
					"            if ((!creditorAccountId) || (creditorAccountId && forceCreateDBObjects && step == 0)) {",
					"                await utils.createAccounts(1, tenantId, creditorKey, creditorAccountKey, timestampPacs008);",
					"            }",
					"",
					"            var messageIdPain001;",
					"            var messageIdPain013;",
					"            var timestampPain001;",
					"            var timestampPain013;",
					"            var pain001;",
					"            var pain013;",
					"            var baseCreDtTm;",
					"",
					"            if (activePain001) {",
					"                messageIdPain001 = uuid.v4().replace(/-/g, '');",
					"                messageIdPain013 = uuid.v4().replace(/-/g, '');",
					"                timestampPain001 = new Date(new Date(Date.now() - timestampEpoch + (timestampIterationLeap * step) - timestampInterval * 3)).toISOString();",
					"                timestampPain013 = new Date(new Date(Date.now() - timestampEpoch + (timestampIterationLeap * step) - timestampInterval * 2)).toISOString();",
					"                baseCreDtTm = timestampPain001;",
					"            } else {",
					"                baseCreDtTm = timestampPacs008;",
					"            }",
					"",
					"            var dataCache = {",
					"                \"dbtrId\": `${debtorKey}`,",
					"                \"cdtrId\": `${creditorKey}`,",
					"                \"dbtrAcctId\": `${debtorAccountKey}`,",
					"                \"cdtrAcctId\": `${creditorAccountKey}`,",
					"                \"creDtTm\": `${baseCreDtTm}`,",
					"                \"instdAmt\": {",
					"                    \"amt\": stepInstructedAmount,",
					"                    \"ccy\": `${stepInstructedCurrency}`",
					"                },",
					"                \"intrBkSttlmAmt\": {",
					"                    \"amt\": stepInterbankSettlementAmount,",
					"                    \"ccy\": `${stepInterbankSettlementCurrency}`",
					"                },",
					"                \"xchgRate\": stepExchangeRate",
					"            };",
					"",
					"            if (LOGLEVEL === 'DEBUG') {",
					"                logStatement = {",
					"                    \"tenantId\": `${tenantId}`,",
					"                    \"messageIdPain001\": `${messageIdPain001}`,",
					"                    \"timestampPain001\": `${timestampPain001}`,",
					"                    \"messageIdPain013\": `${messageIdPain013}`,",
					"                    \"timestampPain013\": `${timestampPain013}`,",
					"                    \"messageIdPacs008\": `${messageIdPacs008}`,",
					"                    \"timestampPacs008\": `${timestampPacs008}`,",
					"                    \"messageIdPacs002\": `${messageIdPacs002}`,",
					"                    \"timestampPacs002\": `${timestampPacs002}`,",
					"                    \"debtorDoB\": `${debtorDoB}`,",
					"                    \"forceCreateDBObjects\": `${forceCreateDBObjects}`,",
					"                    \"debtorId\": `${stepDebtorId}`,",
					"                    \"debtorKey\": `${debtorKey}`,",
					"                    \"debtorAccountId\": `${stepDebtorAccountId}`,",
					"                    \"debtorAccountKey\": `${debtorAccountKey}`,",
					"                    \"creditorId\": `${stepCreditorId}`,",
					"                    \"creditorKey\": `${creditorKey}`,",
					"                    \"creditorAccountId\": `${stepCreditorAccountId}`,",
					"                    \"creditorAccountKey\": `${creditorAccountKey}`,",
					"                    \"endToEndId\": `${endToEndId}`,",
					"                    \"transactionPurpose\": `${transactionPurpose}`,",
					"                    \"stepInstructedCurrency\": `${stepInstructedCurrency}`,",
					"                    \"stepInstructedAmount\": `${stepInstructedAmount}`,",
					"                    \"stepInterbankSettlementCurrency\": `${stepInterbankSettlementCurrency}`,",
					"                    \"stepInterbankSettlementAmount\": `${stepInterbankSettlementAmount}`,",
					"                    \"stepExchangeRateCurrency\": `${stepExchangeRateCurrency}`,",
					"                    \"exchangeRate\": `${exchangeRate}`,",
					"                    \"transactionDescription\": `${transactionDescription}`,",
					"                    \"transactionLat\": `${transactionLat}`,",
					"                    \"transactionLong\": `${transactionLong}`,",
					"                    \"pacs002Sts\": `${pacs002Sts}`",
					"                }",
					"                console.log(`Message creation parameters:`);",
					"                console.log(JSON.stringify(logStatement, null, 2));",
					"                console.log(`\"dataCache\": ${JSON.stringify(dataCache, null, 2)}`);",
					"            }",
					"",
					"            if (activePain001) {",
					"                pain001 = utils.addTenantId(tenantId, prep.prepPain001Msg(messageIdPain001, timestampPain001, debtorDoB, stepDebtorId, DEBTOR_ID_TYPE, stepDebtorAccountId, DEBTOR_ACCOUNT_TYPE, debtorAgentId, endToEndId, transactionPurpose, stepInstructedCurrency, stepInstructedAmount, stepInterbankSettlementCurrency, stepInterbankSettlementAmount, stepExchangeRateCurrency, exchangeRate, stepCreditorId, CREDITOR_ID_TYPE, stepCreditorAccountId, CREDITOR_ACCOUNT_TYPE, creditorAgentId, transactionDescription, transactionLat, transactionLong, dataCache));",
					"                pain013 = utils.addTenantId(tenantId, prep.prepPain013Msg(messageIdPain013, timestampPain013, debtorDoB, stepDebtorId, DEBTOR_ID_TYPE, stepDebtorAccountId, DEBTOR_ACCOUNT_TYPE, debtorAgentId, endToEndId, stepInstructedCurrency, stepInstructedAmount, stepInterbankSettlementCurrency, stepInterbankSettlementAmount, stepCreditorId, CREDITOR_ID_TYPE, stepCreditorAccountId, CREDITOR_ACCOUNT_TYPE, creditorAgentId, transactionLat, transactionLong, dataCache));",
					"            }",
					"",
					"            let pacs008 = utils.addTenantId(tenantId, prep.prepPacs008Msg(messageIdPacs008, timestampPacs008, endToEndId, stepInstructedCurrency, stepInstructedAmount, stepInterbankSettlementCurrency, stepInterbankSettlementAmount, stepExchangeRate, debtorDoB, stepDebtorId, DEBTOR_ID_TYPE, stepDebtorAccountId, DEBTOR_ACCOUNT_TYPE, debtorAgentId, stepCreditorId, CREDITOR_ID_TYPE, stepCreditorAccountId, CREDITOR_ACCOUNT_TYPE, creditorAgentId, transactionPurpose, transactionDescription, transactionLat, transactionLong, dataCache));",
					"            let pacs002 = utils.addTenantId(tenantId, prep.prepPacs002Msg(messageIdPacs002, timestampPacs002, endToEndId, pacs002Sts, debtorAgentId, creditorAgentId, dataCache));",
					"",
					"            var transactions = [];",
					"",
					"            if (activePain001) {",
					"                transactions = prep.prepEventTransactions(tenantId, debtorAccountKey, creditorAccountKey, stepInstructedCurrency, stepInstructedAmount, stepInterbankSettlementCurrency, stepInterbankSettlementAmount, stepExchangeRateCurrency, stepExchangeRate, endToEndId, timestampPacs008, messageIdPacs008, timestampPacs002, messageIdPacs002, pacs002Sts, timestampPain001, messageIdPain001, timestampPain013, messageIdPain013);",
					"",
					"                await utils.saveData({ document: { ...pain001 } }, DB_RAW_HISTORY, DB_RAW_HISTORY_PAIN001)",
					"                    .then(response => {",
					"                        if (LOGLEVEL === 'DEBUG') {",
					"                            console.log('Pain001 created:', response.json());",
					"                        }",
					"                    })",
					"                    .catch(error => console.error('Failed to create Pain001:', error));",
					"                await utils.saveData({ document: { ...pain013 } }, DB_RAW_HISTORY, DB_RAW_HISTORY_PAIN013)",
					"                    .then(response => {",
					"                        if (LOGLEVEL === 'DEBUG') {",
					"                            console.log('Pain013 created:', response.json());",
					"                        }",
					"                    })",
					"                    .catch(error => console.error('Failed to create Pain013:', error));",
					"                await utils.saveData(transactions, DB_EVENT_HISTORY, DB_EVENT_HISTORY_TRANSACTION)",
					"                    .then(response => {",
					"                        if (LOGLEVEL === 'DEBUG') {",
					"                            console.log('Transactions created:', response.json());",
					"                        }",
					"                    })",
					"                    .catch(error => console.error('Failed to create transactions:', error));",
					"            } else {",
					"                transactions = prep.prepEventTransactions(tenantId, debtorAccountKey, creditorAccountKey, stepInstructedCurrency, stepInstructedAmount, stepInterbankSettlementCurrency, stepInterbankSettlementAmount, stepExchangeRateCurrency, stepExchangeRate, endToEndId, timestampPacs008, messageIdPacs008, timestampPacs002, messageIdPacs002, pacs002Sts);",
					"",
					"                await utils.saveData({ document: { ...pacs008 } }, DB_RAW_HISTORY, DB_RAW_HISTORY_PACS008)",
					"                    .then(response => {",
					"                        if (LOGLEVEL === 'DEBUG') {",
					"                            console.log('Pacs008 created:', response.json());",
					"                        }",
					"                    })",
					"                    .catch(error => console.error('Failed to create Pacs008:', error));",
					"                await utils.saveData({ document: { ...pacs002 } }, DB_RAW_HISTORY, DB_RAW_HISTORY_PACS002)",
					"                    .then(response => {",
					"                        if (LOGLEVEL === 'DEBUG') {",
					"                            console.log('Pacs002 created:', response.json());",
					"                        }",
					"                    })",
					"                    .catch(error => console.error('Failed to create Pacs002:', error));",
					"                await utils.saveData(transactions, DB_EVENT_HISTORY, DB_EVENT_HISTORY_TRANSACTION)",
					"                    .then(response => {",
					"                        if (LOGLEVEL === 'DEBUG') {",
					"                            console.log('Transactions created:', response.json());",
					"                        }",
					"                    })",
					"                    .catch(error => console.error('Failed to create transactions:', error));",
					"            }",
					"",
					"            if (activePain001) {",
					"                if ((LOGLEVEL === 'DEBUG') || (LOGLEVEL === 'INFO')) {",
					"                    console.log(`Created transaction set ${step + 1}/${numberOfSets} from ${debtorAccountKey} to ${creditorAccountKey} with EndToEndId ${endToEndId}`);",
					"                }",
					"                messageSet.pain001 = pain001;",
					"                messageSet.pain013 = pain013;",
					"            } else {",
					"                if ((LOGLEVEL === 'DEBUG') || (LOGLEVEL === 'INFO')) {",
					"                    console.log(`Created transaction set ${step + 1}/${numberOfSets} from ${debtorAccountKey} to ${creditorAccountKey} with EndToEndId ${endToEndId}`);",
					"                }",
					"            }",
					"",
					"            messageSet.pacs008 = pacs008;",
					"            messageSet.pacs002 = pacs002;",
					"            messageSets.push(messageSet);",
					"",
					"            if ((LOGLEVEL === 'DEBUG') || (LOGLEVEL === 'INFO')) {",
					"                if (activePain001) {",
					"                    logStatement = {",
					"                        \"pain001\": `${messageIdPain001} at ${timestampPain001}`,",
					"                        \"pain013\": `${messageIdPain013} at ${timestampPain013}`,",
					"                        \"pacs008\": `${messageIdPacs008} at ${timestampPacs008}`,",
					"                        \"pacs002\": `${messageIdPacs002} at ${timestampPacs002}`",
					"                    }",
					"                    console.log(`Message IDs:`);",
					"                    console.log(JSON.stringify(logStatement, null, 2));",
					"                } else {",
					"                    logStatement = {",
					"                        \"pain001\": `disabled`,",
					"                        \"pain013\": `disabled`,",
					"                        \"pacs008\": `${messageIdPacs008} at ${timestampPacs008}`,",
					"                        \"pacs002\": `${messageIdPacs002} at ${timestampPacs002}`",
					"                    }",
					"                    console.log(`Message IDs:`);",
					"                    console.log(JSON.stringify(logStatement, null, 2));",
					"                }",
					"                console.log(messageSets);",
					"                utils.logDataCache(dataCache);",
					"            }",
					"        }",
					"",
					"        return (messageSets);",
					"    },",
					"",
					"    getRuleProcessorBody: function (ruleId, ruleCfgVer, messageBody, dataCache, collectFrom) {",
					"        ruleId = ruleId ?? '901@1.0.0';",
					"        ruleCfgVer = ruleCfgVer ?? '1.0.0';",
					"        const natsSub = `sub-rule-${ruleId}`;",
					"        const natsPub = collectFrom ?? `pub-rule-${ruleId}`;",
					"        const msgId = messageBody.FIToFIPmtSts.GrpHdr.MsgId;",
					"        return JSON.stringify({",
					"            \"destination\": natsSub,",
					"            \"consumer\": natsPub,",
					"            \"functionName\": msgId,",
					"            \"awaitReply\": true,",
					"            \"message\": {",
					"                \"transaction\": messageBody,",
					"                \"DataCache\": dataCache,",
					"                \"networkMap\": {",
					"                    \"name\": \"Rule processor ingestion\",",
					"                    \"active\": true,",
					"                    \"cfg\": \"1.0.0\",",
					"                    \"messages\": [",
					"                        {",
					"                            \"id\": \"004@1.0.0\",",
					"                            \"cfg\": \"1.0.0\",",
					"                            \"txTp\": \"pacs.002.001.12\",",
					"                            \"typologies\": [",
					"                                {",
					"                                    \"id\": \"typology-processor@1.0.0\",",
					"                                    \"cfg\": \"999@1.0.0\",",
					"                                    \"rules\": [",
					"                                        {",
					"                                            \"id\": ruleId,",
					"                                            \"cfg\": ruleCfgVer",
					"                                        }",
					"                                    ]",
					"                                }",
					"                            ]",
					"                        }",
					"                    ]",
					"                },",
					"                \"metaData\": {",
					"                    \"prcgTmDP\": 999,",
					"                    \"prcgTmED\": 999,",
					"                    \"traceParent\": `00-postman-${msgId}-01`",
					"                }",
					"            }",
					"        });",
					"    },",
					"",
					"    getTypologyProcessorBody: function (ruleResult, typologyCfg, messageBody, dataCache, collectFrom, awaitReply) {",
					"        ruleResult = ruleResult ?? { id: '901@1.0.0', cfg: '1.0.0', subRuleRef: '.01', prcgTm: 999 };",
					"        typologyCfg = typologyCfg ?? '999@1.0.0';",
					"        awaitReply = awaitReply ?? false;",
					"        const natsSub = `pub-rule-${ruleResult.id}`;",
					"        const natsPub = collectFrom ? collectFrom : `typology-${typologyCfg}`;",
					"        const msgId = messageBody.FIToFIPmtSts.GrpHdr.MsgId;",
					"        return JSON.stringify({",
					"            \"destination\": natsSub,",
					"            \"consumer\": natsPub,",
					"            \"functionName\": msgId,",
					"            \"awaitReply\": awaitReply,",
					"            \"message\": {",
					"                \"transaction\": messageBody,",
					"                \"DataCache\": dataCache,",
					"                \"networkMap\": {",
					"                    \"name\": \"Typology processor ingestion\",",
					"                    \"active\": true,",
					"                    \"cfg\": \"1.0.0\",",
					"                    \"messages\": [",
					"                        {",
					"                            \"id\": \"004@1.0.0\",",
					"                            \"cfg\": \"1.0.0\",",
					"                            \"txTp\": \"pacs.002.001.12\",",
					"                            \"typologies\": [",
					"                                {",
					"                                    \"id\": \"typology-processor@1.0.0\",",
					"                                    \"cfg\": typologyCfg,",
					"                                    \"rules\": [",
					"                                        {",
					"                                            \"id\": ruleResult.id,",
					"                                            \"cfg\": ruleResult.cfg",
					"                                        }",
					"                                    ]",
					"                                }",
					"                            ]",
					"                        }",
					"                    ]",
					"                },",
					"                \"metaData\": {",
					"                    \"prcgTmDP\": 999,",
					"                    \"prcgTmED\": 999,",
					"                    \"traceParent\": `00-postman-${msgId}-01`",
					"                },",
					"                ruleResult",
					"            }",
					"        });",
					"    },",
					"",
					"    getTADProcBody: function (typologyResult, messageBody, dataCache, awaitReply) {",
					"        typologyResult = typologyResult ?? {",
					"            \"id\": \"typology-processor@1.0.0\",",
					"            \"cfg\": \"999@1.0.0\",",
					"            \"result\": 100,",
					"            \"ruleResults\": [",
					"                {",
					"                    \"id\": \"901@1.0.0\",",
					"                    \"cfg\": \"1.0.0\",",
					"                    \"subRuleRef\": \".01\",",
					"                    \"prcgTm\": 999,",
					"                    \"wght\": 100",
					"                }",
					"            ],",
					"            \"prcgTm\": 999,",
					"            \"review\": false,",
					"            \"workflow\": {",
					"                \"alertThreshold\": 200,",
					"                \"interdictionThreshold\": 400",
					"            }",
					"        };",
					"        awaitReply = awaitReply ?? false;",
					"        const typologyCfg = typologyResult.cfg;",
					"        const ruleResult = typologyResult.ruleResults;",
					"        const natsPub = `typology-${typologyCfg}`;",
					"        const natsSub = `cms`;",
					"        const msgId = messageBody.FIToFIPmtSts.GrpHdr.MsgId;",
					"        return JSON.stringify({",
					"            \"destination\": natsPub,",
					"            \"consumer\": natsSub,",
					"            \"functionName\": msgId,",
					"            \"awaitReply\": awaitReply,",
					"            \"message\": {",
					"                \"transaction\": messageBody,",
					"                \"DataCache\": dataCache,",
					"                \"networkMap\": {",
					"                    \"name\": \"Typology processor ingestion\",",
					"                    \"active\": true,",
					"                    \"cfg\": \"1.0.0\",",
					"                    \"messages\": [",
					"                        {",
					"                            \"id\": \"004@1.0.0\",",
					"                            \"cfg\": \"1.0.0\",",
					"                            \"txTp\": \"pacs.002.001.12\",",
					"                            \"typologies\": [",
					"                                {",
					"                                    \"id\": \"typology-processor@1.0.0\",",
					"                                    \"cfg\": typologyCfg,",
					"                                    \"rules\": [",
					"                                        {",
					"                                            \"id\": ruleResult[0].id,",
					"                                            \"cfg\": ruleResult[0].cfg",
					"                                        }",
					"                                    ]",
					"                                }",
					"                            ]",
					"                        }",
					"                    ]",
					"                },",
					"                \"metaData\": {",
					"                    \"prcgTmDP\": 999,",
					"                    \"prcgTmED\": 999,",
					"                    \"traceParent\": `00-postman-${msgId}-01`",
					"                },",
					"                typologyResult",
					"            }",
					"        });",
					"    },",
					"",
					"    getDebtorIdFromPacs008: function (pacs008Message) {",
					"",
					"        debtorId = {",
					"            \"id\": pacs008Message.FIToFICstmrCdtTrf.CdtTrfTxInf.Dbtr.Id.PrvtId.Othr[0].Id,",
					"            \"schmeNm\": {",
					"                \"prtry\": pacs008Message.FIToFICstmrCdtTrf.CdtTrfTxInf.Dbtr.Id.PrvtId.Othr[0].SchmeNm.Prtry",
					"            }",
					"        }",
					"",
					"        if (LOGLEVEL === \"DEBUG\") {",
					"            console.log(`Debtor ID object: ${JSON.stringify(debtorId, null, 2)}`);",
					"        }",
					"",
					"        return debtorId;",
					"",
					"    },",
					"",
					"    getDebtorAccountIdFromPacs008: function (pacs008Message) {",
					"",
					"        debtorAccountId = {",
					"            \"id\": pacs008Message.FIToFICstmrCdtTrf.CdtTrfTxInf.DbtrAcct.Id.Othr[0].Id,",
					"            \"schmeNm\": {",
					"                \"prtry\": pacs008Message.FIToFICstmrCdtTrf.CdtTrfTxInf.DbtrAcct.Id.Othr[0].SchmeNm.Prtry",
					"            },",
					"            \"agt\": {",
					"                \"finInstnId\": {",
					"                    \"clrSysMmbId\": {",
					"                        \"mmbId\": pacs008Message.FIToFICstmrCdtTrf.CdtTrfTxInf.DbtrAgt.FinInstnId.ClrSysMmbId.MmbId",
					"                    }",
					"                }",
					"            }",
					"        };",
					"",
					"        if (LOGLEVEL === \"DEBUG\") {",
					"            console.log(`Debtor Account ID object: ${JSON.stringify(debtorAccountId, null, 2)}`);",
					"        }",
					"",
					"        return debtorAccountId;",
					"    },",
					"",
					"    getCreditorIdFromPacs008: function (pacs008Message) {",
					"",
					"        creditorId = {",
					"            \"id\": pacs008Message.FIToFICstmrCdtTrf.CdtTrfTxInf.Cdtr.Id.PrvtId.Othr[0].Id,",
					"            \"schmeNm\": {",
					"                \"prtry\": pacs008Message.FIToFICstmrCdtTrf.CdtTrfTxInf.Cdtr.Id.PrvtId.Othr[0].SchmeNm.Prtry",
					"            }",
					"        }",
					"",
					"        if (LOGLEVEL === \"DEBUG\") {",
					"            console.log(`Creditor ID object: ${JSON.stringify(creditorId, null, 2)}`);",
					"        }",
					"",
					"        return creditorId;",
					"    },",
					"",
					"    getCreditorAccountIdFromPacs008: function (pacs008Message) {",
					"",
					"        creditorAccountId = {",
					"            \"id\": pacs008Message.FIToFICstmrCdtTrf.CdtTrfTxInf.CdtrAcct.Id.Othr[0].Id,",
					"            \"schmeNm\": {",
					"                \"prtry\": pacs008Message.FIToFICstmrCdtTrf.CdtTrfTxInf.CdtrAcct.Id.Othr[0].SchmeNm.Prtry",
					"            },",
					"            \"agt\": {",
					"                \"finInstnId\": {",
					"                    \"clrSysMmbId\": {",
					"                        \"mmbId\": pacs008Message.FIToFICstmrCdtTrf.CdtTrfTxInf.CdtrAgt.FinInstnId.ClrSysMmbId.MmbId",
					"                    }",
					"                }",
					"            }",
					"        }",
					"        if (LOGLEVEL === \"DEBUG\") {",
					"            console.log(`Creditor Account ID object: ${JSON.stringify(creditorAccountId, null, 2)}`);",
					"        }",
					"",
					"        return creditorAccountId;",
					"",
					"    },",
					"",
					"    getCreateAccountConditionBody: function (evtTp, condTp, prsptv, incptDtTm, xprtnDtTm, condRsn, acct, forceCret, usr) {",
					"",
					"        evtTp = evtTp ?? [\"pain.001.001.11\", \"pain.013.001.09\", \"pacs.008.001.10\", \"pacs.002.001.12\"];",
					"        condTp = condTp ?? \"non-overridable-block\"; // \"override\" / \"overridable-block\"",
					"        prsptv = prsptv ?? \"both\";",
					"        condRsn = condRsn ?? \"Default Test Condition\";",
					"        acct = acct ?? {",
					"            \"id\": utils.createISOUUID(),",
					"            \"schmeNm\": {",
					"                \"prtry\": \"TAZAMA_AID\"",
					"            },",
					"            \"agt\": {",
					"                \"finInstnId\": {",
					"                    \"clrSysMmbId\": {",
					"                        \"mmbId\": \"fsp001\"",
					"                    }",
					"                }",
					"            }",
					"        };",
					"        forceCret = forceCret ? forceCret : true;",
					"        usr = usr ?? \"POSTMAN\";",
					"",
					"        let messageBody = {",
					"            \"evtTp\": evtTp,",
					"            \"condTp\": condTp,",
					"            \"prsptv\": prsptv,",
					"            \"condRsn\": condRsn,",
					"            \"acct\": acct,",
					"            \"forceCret\": forceCret,",
					"            \"usr\": usr",
					"        };",
					"",
					"        if (condTp.localeCompare(\"override\") === 0) {",
					"            xprtnDtTm = xprtnDtTm ?? new Date(new Date(Date.now() + utils.timeframe(\"days\"))).toISOString();",
					"        }",
					"",
					"        incptDtTm = incptDtTm ? messageBody = lodash.assign({ \"incptDtTm\": incptDtTm }, messageBody) : false;",
					"        xprtnDtTm = xprtnDtTm ? messageBody = lodash.assign({ \"xprtnDtTm\": xprtnDtTm }, messageBody) : false;",
					"",
					"        return JSON.stringify(messageBody);",
					"    },",
					"",
					"    getCreateEntityConditionBody: function (evtTp, condTp, prsptv, incptDtTm, xprtnDtTm, condRsn, ntty, forceCret, usr) {",
					"",
					"        evtTp = evtTp ?? [\"pain.001.001.11\", \"pain.013.001.09\", \"pacs.008.001.10\", \"pacs.002.001.12\"];",
					"        condTp = condTp ?? \"non-overridable-block\"; // \"override\" / \"overridable-block\"",
					"        prsptv = prsptv ?? \"both\"; // \"debtor\" / \"creditor\"",
					"        condRsn = condRsn ?? \"Default Test Condition\";",
					"        ntty = ntty ?? {",
					"            \"id\": utils.createISOUUID(),",
					"            \"schmeNm\": {",
					"                \"prtry\": \"TAZAMA_EID\"",
					"            }",
					"        };",
					"        forceCret = forceCret ? forceCret : true;",
					"        usr = usr ?? \"POSTMAN\";",
					"",
					"        let messageBody = {",
					"            \"evtTp\": evtTp,",
					"            \"condTp\": condTp,",
					"            \"prsptv\": prsptv,",
					"            \"condRsn\": condRsn,",
					"            \"ntty\": ntty,",
					"            \"forceCret\": forceCret,",
					"            \"usr\": usr",
					"        };",
					"",
					"        if (condTp.localeCompare(\"override\") === 0) {",
					"            xprtnDtTm = xprtnDtTm ?? new Date(new Date(Date.now() + utils.timeframe(\"days\"))).toISOString();",
					"        }",
					"",
					"        incptDtTm = incptDtTm ? messageBody = lodash.assign({ \"incptDtTm\": incptDtTm }, messageBody) : false;",
					"        xprtnDtTm = xprtnDtTm ? messageBody = lodash.assign({ \"xprtnDtTm\": xprtnDtTm }, messageBody) : false;",
					"",
					"        return JSON.stringify(messageBody);",
					"",
					"    },",
					"",
					"    getConditionsFromDBPostRequest: function (tenantId, id, activeOnly) {",
					"",
					"        var variables = {",
					"            tenantId: tenantId,",
					"            id: id",
					"        }",
					"",
					"        var activeFilter = {",
					"            \"param\": \"\",",
					"            \"filter\": \"\"",
					"        }",
					"",
					"        if (activeOnly) {",
					"            variables.now = new Date().toISOString();",
					"            activeFilter.param = `, $now: timestamptz!`;",
					"            activeFilter.filter = `_or: [ { xprtndttm: { _is_null: true } }, { xprtndttm: { _gt: $now } } ]`;",
					"        }",
					"",
					"        const query = `query GetGovernedRelationships($tenantId: String!, $id: String!${activeFilter.param}) {",
					"            governed_as_debtor_by(",
					"                where: {",
					"                    tenantid: { _eq: $tenantId }",
					"                    source: { _eq: $id }",
					"                    ${activeFilter.filter}",
					"                }",
					"            ) {",
					"                source",
					"                destination",
					"                evttp",
					"                incptndttm",
					"                xprtndttm",
					"                tenantid",
					"                condition {",
					"                    id",
					"                    tenantid",
					"                    condition",
					"                }",
					"                entity {",
					"                    id",
					"                    tenantid",
					"                    credttm",
					"                }",
					"            }",
					"            governed_as_creditor_by(",
					"                where: {",
					"                    tenantid: { _eq: $tenantId }",
					"                    source: { _eq: $id }",
					"                    ${activeFilter.filter}",
					"                }",
					"            ) {",
					"                source",
					"                destination",
					"                evttp",
					"                incptndttm",
					"                xprtndttm",
					"                tenantid",
					"                condition {",
					"                    id",
					"                    tenantid",
					"                    condition",
					"                }",
					"                entity {",
					"                    id",
					"                    tenantid",
					"                    credttm",
					"                }",
					"            }",
					"            governed_as_debtor_account_by(",
					"                where: {",
					"                    tenantid: { _eq: $tenantId }",
					"                    source: { _eq: $id }",
					"                    ${activeFilter.filter}",
					"                }",
					"            ) {",
					"                source",
					"                destination",
					"                evttp",
					"                incptndttm",
					"                xprtndttm",
					"                tenantid",
					"                condition {",
					"                    id",
					"                    tenantid",
					"                    condition",
					"                }",
					"                account {",
					"                    id",
					"                    tenantid",
					"                }",
					"            }",
					"            governed_as_creditor_account_by(",
					"                where: {",
					"                    tenantid: { _eq: $tenantId }",
					"                    source: { _eq: $id }",
					"                    ${activeFilter.filter}",
					"                }",
					"            ) {",
					"                source",
					"                destination",
					"                evttp",
					"                incptndttm",
					"                xprtndttm",
					"                tenantid",
					"                condition {",
					"                    id",
					"                    tenantid",
					"                    condition",
					"                }",
					"                account {",
					"                    id",
					"                    tenantid",
					"                }",
					"            }",
					"        }`;",
					"",
					"        const postRequest = {",
					"            url: POSTGRES_API_URL,",
					"            method: 'POST',",
					"            header: {",
					"                'Content-Type': 'application/json',",
					"                'x-hasura-role': 'anonymous'",
					"            },",
					"            body: {",
					"                mode: 'raw',",
					"                raw: JSON.stringify({",
					"                    query: query,",
					"                    variables: variables",
					"                })",
					"            }",
					"        };",
					"",
					"        if (LOGLEVEL === \"DEBUG\") {",
					"            console.log('GraphQL Query:', query);",
					"            console.log('Request body:', postRequest);",
					"        }",
					"",
					"        return postRequest;",
					"    },",
					"",
					"    getConditionsGraph: function (graph) {",
					"",
					"        let conditionsGraph = { v: [], e: [] }",
					"",
					"        const allConditions = [",
					"            ...(graph.governed_as_creditor_account_by?.map(item => item.condition) ?? []),",
					"            ...(graph.governed_as_debtor_account_by?.map(item => item.condition) ?? []),",
					"            ...(graph.governed_as_creditor_by?.map(item => item.condition) ?? []),",
					"            ...(graph.governed_as_debtor_by?.map(item => item.condition) ?? [])",
					"        ];",
					"",
					"        const uniqueConditions = Array.from(",
					"            new Map(allConditions.map(cond => [cond.id, cond])).values()",
					"        );",
					"",
					"        uniqueConditions.forEach(item => {",
					"            item._key = `${item.id}`;",
					"            item._id = `conditions/${item.id}`;",
					"            item.usr = item.condition.usr;",
					"            if (item.condition.hasOwnProperty(\"acct\")) {",
					"                item.acct = item.condition.acct;",
					"            }",
					"            if (item.condition.hasOwnProperty(\"ntty\")) {",
					"                item.ntty = item.condition.ntty;",
					"            }",
					"            item.evtTp = item.condition.evtTp;",
					"            item.condId = item.condition.condId;",
					"            item.condTp = item.condition.condTp;",
					"            item.prsptv = item.condition.prsptv;",
					"            item.condRsn = item.condition.condRsn;",
					"            item.creDtTm = item.condition.creDtTm;",
					"            item.tenantId = item.condition.tenantId;",
					"            item.forceCret = item.condition.forceCret;",
					"            item.incptnDtTm = item.condition.incptnDtTm;",
					"            if (item.condition.hasOwnProperty(\"xprtnDtTm\")) {",
					"                item.xprtnDtTm = item.condition.xprtnDtTm;",
					"            }",
					"        });",
					"",
					"        const entitySources = [",
					"            ...(graph.governed_as_creditor_by?.map(item => item.entity) ?? []),",
					"            ...(graph.governed_as_debtor_by?.map(item => item.entity) ?? [])",
					"        ];",
					"",
					"        const uniqueEntitySources = Array.from(",
					"            new Map(entitySources.map(cond => [cond.id, cond])).values()",
					"        );",
					"",
					"        uniqueEntitySources.forEach(item => {",
					"            item._key = `${item.id}`;",
					"            item._id = `entities/${item.id}`;",
					"        });",
					"",
					"        const accountSources = [",
					"            ...(graph.governed_as_creditor_account_by?.map(item => item.account) ?? []),",
					"            ...(graph.governed_as_debtor_account_by?.map(item => item.account) ?? [])",
					"        ];",
					"",
					"        const uniqueAccountSources = Array.from(",
					"            new Map(accountSources.map(cond => [cond.id, cond])).values()",
					"        );",
					"",
					"        uniqueAccountSources.forEach(item => {",
					"            item._key = `${item.id}`;",
					"            item._id = `accounts/${item.id}`;",
					"        });",
					"",
					"        graph.governed_as_creditor_by.forEach(item => {",
					"            item._key = `${utils.createISOUUID()}`;",
					"            item._id = `governed_as_creditor_by/${item._key}`;",
					"            item._from = `entities/${item.source}`;",
					"            item._to = `conditions/${item.destination}`;",
					"        });",
					"",
					"        graph.governed_as_debtor_by.forEach(item => {",
					"            item._key = `${utils.createISOUUID()}`;",
					"            item._id = `governed_as_debtor_by/${item._key}`;",
					"            item._from = `entities/${item.source}`;",
					"            item._to = `conditions/${item.destination}`;",
					"        });",
					"",
					"        graph.governed_as_creditor_account_by.forEach(item => {",
					"            item._key = `${utils.createISOUUID()}`;",
					"            item._id = `governed_as_creditor_account_by/${item._key}`;",
					"            item._from = `accounts/${item.source}`;",
					"            item._to = `conditions/${item.destination}`;",
					"        });",
					"",
					"        graph.governed_as_debtor_account_by.forEach(item => {",
					"            item._key = `${utils.createISOUUID()}`;",
					"            item._id = `governed_as_debtor_account_by/${item._key}`;",
					"            item._from = `accounts/${item.source}`;",
					"            item._to = `conditions/${item.destination}`;",
					"        });",
					"",
					"        conditionsGraph.v = [...uniqueConditions, ...uniqueEntitySources, ...uniqueAccountSources];",
					"        conditionsGraph.e = [...graph.governed_as_creditor_by, ...graph.governed_as_debtor_by, ...graph.governed_as_creditor_account_by, ...graph.governed_as_debtor_account_by];",
					"",
					"        let conditionsGraphString = JSON.stringify(conditionsGraph);",
					"",
					"        conditionsGraphString = conditionsGraphString.replaceAll(\"tenantid\", \"tenantId\");",
					"        conditionsGraphString = conditionsGraphString.replaceAll(\"evttp\", \"evtTp\");",
					"        conditionsGraphString = conditionsGraphString.replaceAll(\"incptndttm\", \"incptnDtTm\");",
					"        conditionsGraphString = conditionsGraphString.replaceAll(\"xprtndttm\", \"xprtnDtTm\");",
					"",
					"        conditionsGraph = JSON.parse(conditionsGraphString);",
					"",
					"        if (LOGLEVEL === \"DEBUG\") {",
					"            console.log(`Conditions graph:`, JSON.stringify(conditionsGraph, null, 2));",
					"        }",
					"",
					"        return conditionsGraph;",
					"",
					"    },",
					"",
					"    getConditionsFromGraph: function (graph, all) {",
					"",
					"        if (LOGLEVEL === \"DEBUG\") {",
					"            console.log(`getConditionsFromGraph:`, JSON.stringify(graph, null, 2));",
					"        }",
					"",
					"        if (all) {",
					"            return graph.v.filter(condition => condition._id.substring(0, condition._id.search('/')) === \"conditions\");    // filter to get the conditions",
					"        } else {",
					"            return graph.v.filter(condition => condition._id.substring(0, condition._id.search('/')) === \"conditions\").map(({ _key }) => _key);    // filter to get the conditions, map to only get the _key;",
					"        }",
					"    },",
					"",
					"    getConditionPerspectivesFromGraph: function (graph, condition, all) {",
					"",
					"        if (LOGLEVEL === \"DEBUG\") {",
					"            console.log(`getConditionPerspectivesFromGraph:`, JSON.stringify(graph, null, 2));",
					"        }",
					"",
					"        if (all) {",
					"            return graph.e.filter(edge => edge._to === \"conditions/\" + condition);   // filter to get the condition's perspectives",
					"        } else {",
					"            return graph.e.filter(edge => edge._to === \"conditions/\" + condition).map(({ _id }) => _id.substring(0, _id.search('/')));    // filter to get the condition's perspectives, map to only get the _id up to the '/'",
					"        }",
					"    },",
					"",
					"    getConditionPerspectiveEventTypesFromGraph: function (graph, condition, perspective) {",
					"",
					"        if (LOGLEVEL === \"DEBUG\") {",
					"            console.log(`getConditionPerspectiveEventTypesFromGraph:`, JSON.stringify(graph, null, 2));",
					"        }",
					"",
					"        return graph.e.filter(edge => edge._to === \"conditions/\" + condition).filter(eventType => eventType._id.substring(0, eventType._id.search('/')) === perspective).map(({ evtTp }) => evtTp);    // filter to get the condition's perspectives, filter to get the specific perspective, map to only get the evtTp",
					"    },",
					"",
					"    getConditionPerspectiveInceptionDateFromGraph: function (graph, condition, perspective) {",
					"",
					"        if (LOGLEVEL === \"DEBUG\") {",
					"            console.log(`getConditionPerspectiveInceptionDateFromGraph:`, JSON.stringify(graph, null, 2));",
					"        }",
					"",
					"        return graph.e.filter(edge => edge._to === \"conditions/\" + condition).filter(eventType => eventType._id.substring(0, eventType._id.search('/')) === perspective).map(({ incptnDtTm }) => incptnDtTm);    // filter to get the condition's perspectives, filter to get the specific perspective, map to only get the incptnDtTm",
					"    },",
					"",
					"    getConditionPerspectiveExpirationDateFromGraph: function (graph, condition, perspective) {",
					"",
					"        if (LOGLEVEL === \"DEBUG\") {",
					"            console.log(`getConditionPerspectiveExpirationDateFromGraph:`, JSON.stringify(graph, null, 2));",
					"        }",
					"",
					"        return graph.e.filter(edge => edge._to === \"conditions/\" + condition).filter(eventType => eventType._id.substring(0, eventType._id.search('/')) === perspective).map(({ xprtnDtTm }) => xprtnDtTm);    // filter to get the condition's perspectives, filter to get the specific perspective, map to only get the incptnDtTm",
					"    }",
					"",
					"}"
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"requests": {},
				"exec": [
					""
				]
			}
		}
	]
}